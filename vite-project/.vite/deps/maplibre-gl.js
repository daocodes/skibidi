import { __commonJS } from "./chunk-BUQ4IUO0.js";

//#region node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = /* @__PURE__ */ __commonJS({ "node_modules/maplibre-gl/dist/maplibre-gl.js": ((exports, module) => {
	/**
	* MapLibre GL JS
	* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.8.0/LICENSE.txt
	*/
	(function(global, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
	})(exports, (function() {
		var maplibregl = {};
		var modules = {};
		function define$1(moduleName, _dependencies, moduleFactory) {
			modules[moduleName] = moduleFactory;
			if (moduleName !== "index") return;
			var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
			var sharedModule = {};
			modules.shared(sharedModule);
			modules.index(maplibregl, sharedModule);
			if (typeof window !== "undefined") maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
			return maplibregl;
		}
		define$1("shared", ["exports"], (function(t) {
			function e(t$1, e$1, r$1, n$1) {
				return new (r$1 || (r$1 = Promise))((function(i$1, s$1) {
					function a$1(t$2) {
						try {
							l$1(n$1.next(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function o$1(t$2) {
						try {
							l$1(n$1.throw(t$2));
						} catch (t$3) {
							s$1(t$3);
						}
					}
					function l$1(t$2) {
						var e$2;
						t$2.done ? i$1(t$2.value) : (e$2 = t$2.value, e$2 instanceof r$1 ? e$2 : new r$1((function(t$3) {
							t$3(e$2);
						}))).then(a$1, o$1);
					}
					l$1((n$1 = n$1.apply(t$1, e$1 || [])).next());
				}));
			}
			function r(t$1, e$1) {
				this.x = t$1, this.y = e$1;
			}
			function n(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var i, s;
			r.prototype = {
				clone() {
					return new r(this.x, this.y);
				},
				add(t$1) {
					return this.clone()._add(t$1);
				},
				sub(t$1) {
					return this.clone()._sub(t$1);
				},
				multByPoint(t$1) {
					return this.clone()._multByPoint(t$1);
				},
				divByPoint(t$1) {
					return this.clone()._divByPoint(t$1);
				},
				mult(t$1) {
					return this.clone()._mult(t$1);
				},
				div(t$1) {
					return this.clone()._div(t$1);
				},
				rotate(t$1) {
					return this.clone()._rotate(t$1);
				},
				rotateAround(t$1, e$1) {
					return this.clone()._rotateAround(t$1, e$1);
				},
				matMult(t$1) {
					return this.clone()._matMult(t$1);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(t$1) {
					return this.x === t$1.x && this.y === t$1.y;
				},
				dist(t$1) {
					return Math.sqrt(this.distSqr(t$1));
				},
				distSqr(t$1) {
					const e$1 = t$1.x - this.x, r$1 = t$1.y - this.y;
					return e$1 * e$1 + r$1 * r$1;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(t$1) {
					return Math.atan2(this.y - t$1.y, this.x - t$1.x);
				},
				angleWith(t$1) {
					return this.angleWithSep(t$1.x, t$1.y);
				},
				angleWithSep(t$1, e$1) {
					return Math.atan2(this.x * e$1 - this.y * t$1, this.x * t$1 + this.y * e$1);
				},
				_matMult(t$1) {
					const e$1 = t$1[2] * this.x + t$1[3] * this.y;
					return this.x = t$1[0] * this.x + t$1[1] * this.y, this.y = e$1, this;
				},
				_add(t$1) {
					return this.x += t$1.x, this.y += t$1.y, this;
				},
				_sub(t$1) {
					return this.x -= t$1.x, this.y -= t$1.y, this;
				},
				_mult(t$1) {
					return this.x *= t$1, this.y *= t$1, this;
				},
				_div(t$1) {
					return this.x /= t$1, this.y /= t$1, this;
				},
				_multByPoint(t$1) {
					return this.x *= t$1.x, this.y *= t$1.y, this;
				},
				_divByPoint(t$1) {
					return this.x /= t$1.x, this.y /= t$1.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					const t$1 = this.y;
					return this.y = this.x, this.x = -t$1, this;
				},
				_rotate(t$1) {
					const e$1 = Math.cos(t$1), r$1 = Math.sin(t$1), n$1 = r$1 * this.x + e$1 * this.y;
					return this.x = e$1 * this.x - r$1 * this.y, this.y = n$1, this;
				},
				_rotateAround(t$1, e$1) {
					const r$1 = Math.cos(t$1), n$1 = Math.sin(t$1), i$1 = e$1.y + n$1 * (this.x - e$1.x) + r$1 * (this.y - e$1.y);
					return this.x = e$1.x + r$1 * (this.x - e$1.x) - n$1 * (this.y - e$1.y), this.y = i$1, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: r
			}, r.convert = function(t$1) {
				if (t$1 instanceof r) return t$1;
				if (Array.isArray(t$1)) return new r(+t$1[0], +t$1[1]);
				if (void 0 !== t$1.x && void 0 !== t$1.y) return new r(+t$1.x, +t$1.y);
				throw new Error("Expected [x, y] or {x, y} point format");
			};
			var a = function() {
				if (s) return i;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return s = 1, i = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a$1 = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a$1 = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a$1) + a$1;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, i;
			}(), o = n(a);
			let l, u;
			function c() {
				return l ??= "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap, l;
			}
			function h() {
				if (null == u && (u = !1, c())) {
					const t$1 = 5, e$1 = new OffscreenCanvas(t$1, t$1).getContext("2d", { willReadFrequently: !0 });
					if (e$1) {
						for (let r$2 = 0; r$2 < t$1 * t$1; r$2++) {
							const n$1 = 4 * r$2;
							e$1.fillStyle = `rgb(${n$1},${n$1 + 1},${n$1 + 2})`, e$1.fillRect(r$2 % t$1, Math.floor(r$2 / t$1), 1, 1);
						}
						const r$1 = e$1.getImageData(0, 0, t$1, t$1).data;
						for (let e$2 = 0; e$2 < t$1 * t$1 * 4; e$2++) if (e$2 % 4 != 3 && r$1[e$2] !== e$2) {
							u = !0;
							break;
						}
					}
				}
				return u || !1;
			}
			var p = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array;
			function d() {
				var t$1 = new f(9);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0), t$1[0] = 1, t$1[4] = 1, t$1[8] = 1, t$1;
			}
			function y(t$1) {
				return t$1[0] = 1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = 1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 1, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}
			function m() {
				var t$1 = new f(3);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1;
			}
			function g(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1], n$1 = t$1[2];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1 + n$1 * n$1);
			}
			function x(t$1, e$1, r$1) {
				var n$1 = new f(3);
				return n$1[0] = t$1, n$1[1] = e$1, n$1[2] = r$1, n$1;
			}
			function v(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] + r$1[0], t$1[1] = e$1[1] + r$1[1], t$1[2] = e$1[2] + r$1[2], t$1;
			}
			function b(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1;
			}
			function w(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a$1 = r$1[0], o$1 = r$1[1], l$1 = r$1[2];
				return t$1[0] = i$1 * l$1 - s$1 * o$1, t$1[1] = s$1 * a$1 - n$1 * l$1, t$1[2] = n$1 * o$1 - i$1 * a$1, t$1;
			}
			var _, S = g;
			function A(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a$1 = e$1[3];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12] * a$1, t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13] * a$1, t$1[2] = r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14] * a$1, t$1[3] = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15] * a$1, t$1;
			}
			function k() {
				var t$1 = new f(4);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0, t$1[2] = 0), t$1[3] = 1, t$1;
			}
			function M(t$1, e$1, r$1, n$1) {
				var i$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx", s$1 = Math.PI / 360;
				e$1 *= s$1, n$1 *= s$1, r$1 *= s$1;
				var a$1 = Math.sin(e$1), o$1 = Math.cos(e$1), l$1 = Math.sin(r$1), u$1 = Math.cos(r$1), c$1 = Math.sin(n$1), h$1 = Math.cos(n$1);
				switch (i$1) {
					case "xyz":
						t$1[0] = a$1 * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a$1 * l$1 * c$1;
						break;
					case "xzy":
						t$1[0] = a$1 * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a$1 * l$1 * c$1;
						break;
					case "yxz":
						t$1[0] = a$1 * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 - a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a$1 * l$1 * c$1;
						break;
					case "yzx":
						t$1[0] = a$1 * u$1 * h$1 + o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a$1 * l$1 * c$1;
						break;
					case "zxy":
						t$1[0] = a$1 * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 + a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 - a$1 * l$1 * c$1;
						break;
					case "zyx":
						t$1[0] = a$1 * u$1 * h$1 - o$1 * l$1 * c$1, t$1[1] = o$1 * l$1 * h$1 + a$1 * u$1 * c$1, t$1[2] = o$1 * u$1 * c$1 - a$1 * l$1 * h$1, t$1[3] = o$1 * u$1 * h$1 + a$1 * l$1 * c$1;
						break;
					default: throw new Error("Unknown angle order " + i$1);
				}
				return t$1;
			}
			function I() {
				var t$1 = new f(2);
				return f != Float32Array && (t$1[0] = 0, t$1[1] = 0), t$1;
			}
			function z(t$1, e$1) {
				var r$1 = new f(2);
				return r$1[0] = t$1, r$1[1] = e$1, r$1;
			}
			m(), _ = new f(4), f != Float32Array && (_[0] = 0, _[1] = 0, _[2] = 0, _[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), k(), k(), d(), I();
			const P = 8192;
			function C(t$1, e$1, r$1) {
				return e$1 * (P / (t$1.tileSize * Math.pow(2, r$1 - t$1.tileID.overscaledZ)));
			}
			function E(t$1, e$1) {
				return (t$1 % e$1 + e$1) % e$1;
			}
			function T(t$1, e$1, r$1) {
				return t$1 * (1 - r$1) + e$1 * r$1;
			}
			function B(t$1) {
				if (t$1 <= 0) return 0;
				if (t$1 >= 1) return 1;
				const e$1 = t$1 * t$1, r$1 = e$1 * t$1;
				return 4 * (t$1 < .5 ? r$1 : 3 * (t$1 - e$1) + r$1 - .75);
			}
			function V(t$1, e$1, r$1, n$1) {
				const i$1 = new o(t$1, e$1, r$1, n$1);
				return (t$2) => i$1.solve(t$2);
			}
			const F = V(.25, .1, .25, 1);
			function D(t$1, e$1, r$1) {
				return Math.min(r$1, Math.max(e$1, t$1));
			}
			function $(t$1, e$1, r$1) {
				const n$1 = r$1 - e$1, i$1 = ((t$1 - e$1) % n$1 + n$1) % n$1 + e$1;
				return i$1 === e$1 ? r$1 : i$1;
			}
			function L(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			let O = 1;
			function R(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) n$1[r$2] = e$1.call(this, t$1[r$2], r$2, t$1);
				return n$1;
			}
			function U(t$1, e$1, r$1) {
				const n$1 = {};
				for (const r$2 in t$1) e$1.call(this, t$1[r$2], r$2, t$1) && (n$1[r$2] = t$1[r$2]);
				return n$1;
			}
			function j(t$1) {
				return Array.isArray(t$1) ? t$1.map(j) : "object" == typeof t$1 && t$1 ? R(t$1, j) : t$1;
			}
			const N = {};
			function q(t$1) {
				N[t$1] || ("undefined" != typeof console && console.warn(t$1), N[t$1] = !0);
			}
			function G(t$1, e$1, r$1) {
				return (r$1.y - t$1.y) * (e$1.x - t$1.x) > (e$1.y - t$1.y) * (r$1.x - t$1.x);
			}
			function X(t$1) {
				return "undefined" != typeof WorkerGlobalScope && void 0 !== t$1 && t$1 instanceof WorkerGlobalScope;
			}
			let Z = null;
			function Y(t$1) {
				return "undefined" != typeof ImageBitmap && t$1 instanceof ImageBitmap;
			}
			const H = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			function K(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
					const e$1 = new VideoFrame(t$1, { timestamp: 0 });
					try {
						const a$1 = null == e$1 ? void 0 : e$1.format;
						if (!a$1 || !a$1.startsWith("BGR") && !a$1.startsWith("RGB")) throw new Error(`Unrecognized format ${a$1}`);
						const o$1 = a$1.startsWith("BGR"), l$1 = new Uint8ClampedArray(i$1 * s$1 * 4);
						if (yield e$1.copyTo(l$1, function(t$2, e$2, r$2, n$2, i$2) {
							const s$2 = 4 * Math.max(-e$2, 0), a$2 = (Math.max(0, r$2) - r$2) * n$2 * 4 + s$2, o$2 = 4 * n$2, l$2 = Math.max(0, e$2), u$1 = Math.max(0, r$2);
							return {
								rect: {
									x: l$2,
									y: u$1,
									width: Math.min(t$2.width, e$2 + n$2) - l$2,
									height: Math.min(t$2.height, r$2 + i$2) - u$1
								},
								layout: [{
									offset: a$2,
									stride: o$2
								}]
							};
						}(t$1, r$1, n$1, i$1, s$1)), o$1) for (let t$2 = 0; t$2 < l$1.length; t$2 += 4) {
							const e$2 = l$1[t$2];
							l$1[t$2] = l$1[t$2 + 2], l$1[t$2 + 2] = e$2;
						}
						return l$1;
					} finally {
						e$1.close();
					}
				}));
			}
			let J, W;
			function Q(t$1, e$1, r$1, n$1) {
				return t$1.addEventListener(e$1, r$1, n$1), { unsubscribe: () => {
					t$1.removeEventListener(e$1, r$1, n$1);
				} };
			}
			function tt(t$1) {
				return t$1 * Math.PI / 180;
			}
			function et(t$1) {
				return t$1 / Math.PI * 180;
			}
			const rt = {
				touchstart: !0,
				touchmove: !0,
				touchmoveWindow: !0,
				touchend: !0,
				touchcancel: !0
			}, nt = {
				dblclick: !0,
				click: !0,
				mouseover: !0,
				mouseout: !0,
				mousedown: !0,
				mousemove: !0,
				mousemoveWindow: !0,
				mouseup: !0,
				mouseupWindow: !0,
				contextmenu: !0,
				wheel: !0
			}, it = "AbortError";
			function st() {
				return new Error(it);
			}
			const at = {
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
				MAX_TILE_CACHE_ZOOM_LEVELS: 5,
				REGISTERED_PROTOCOLS: {},
				WORKER_URL: ""
			};
			function ot(t$1) {
				return at.REGISTERED_PROTOCOLS[t$1.substring(0, t$1.indexOf("://"))];
			}
			const lt = "global-dispatcher";
			class ut extends Error {
				constructor(t$1, e$1, r$1, n$1) {
					super(`AJAXError: ${e$1} (${t$1}): ${r$1}`), this.status = t$1, this.statusText = e$1, this.url = r$1, this.body = n$1;
				}
			}
			const ct = () => X(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, ht = function(t$1, r$1) {
				if (/:\/\//.test(t$1.url) && !/^https?:|^file:/.test(t$1.url)) {
					const e$1 = ot(t$1.url);
					if (e$1) return e$1(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						targetMapId: lt
					}, r$1);
				}
				if (!(/^file:/.test(n$1 = t$1.url) || /^file:/.test(ct()) && !/^\w+:/.test(n$1))) {
					if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t$2, r$2) {
						return e(this, void 0, void 0, (function* () {
							const e$1 = new Request(t$2.url, {
								method: t$2.method || "GET",
								body: t$2.body,
								credentials: t$2.credentials,
								headers: t$2.headers,
								cache: t$2.cache,
								referrer: ct(),
								signal: r$2.signal
							});
							let n$2, i$1;
							"json" !== t$2.type || e$1.headers.has("Accept") || e$1.headers.set("Accept", "application/json");
							try {
								n$2 = yield fetch(e$1);
							} catch (e$2) {
								throw new ut(0, e$2.message, t$2.url, new Blob());
							}
							if (!n$2.ok) {
								const e$2 = yield n$2.blob();
								throw new ut(n$2.status, n$2.statusText, t$2.url, e$2);
							}
							i$1 = "arrayBuffer" === t$2.type || "image" === t$2.type ? n$2.arrayBuffer() : "json" === t$2.type ? n$2.json() : n$2.text();
							const s$1 = yield i$1;
							if (r$2.signal.aborted) throw st();
							return {
								data: s$1,
								cacheControl: n$2.headers.get("Cache-Control"),
								expires: n$2.headers.get("Expires")
							};
						}));
					}(t$1, r$1);
					if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: t$1,
						mustQueue: !0,
						targetMapId: lt
					}, r$1);
				}
				var n$1;
				return function(t$2, e$1) {
					return new Promise(((r$2, n$2) => {
						var i$1;
						const s$1 = new XMLHttpRequest();
						s$1.open(t$2.method || "GET", t$2.url, !0), "arrayBuffer" !== t$2.type && "image" !== t$2.type || (s$1.responseType = "arraybuffer");
						for (const e$2 in t$2.headers) s$1.setRequestHeader(e$2, t$2.headers[e$2]);
						"json" === t$2.type && (s$1.responseType = "text", !(null === (i$1 = t$2.headers) || void 0 === i$1) && i$1.Accept || s$1.setRequestHeader("Accept", "application/json")), s$1.withCredentials = "include" === t$2.credentials, s$1.onerror = () => {
							n$2(new Error(s$1.statusText));
						}, s$1.onload = () => {
							if (!e$1.signal.aborted) if ((s$1.status >= 200 && s$1.status < 300 || 0 === s$1.status) && null !== s$1.response) {
								let e$2 = s$1.response;
								if ("json" === t$2.type) try {
									e$2 = JSON.parse(s$1.response);
								} catch (t$3) {
									n$2(t$3);
									return;
								}
								r$2({
									data: e$2,
									cacheControl: s$1.getResponseHeader("Cache-Control"),
									expires: s$1.getResponseHeader("Expires")
								});
							} else {
								const e$2 = new Blob([s$1.response], { type: s$1.getResponseHeader("Content-Type") });
								n$2(new ut(s$1.status, s$1.statusText, t$2.url, e$2));
							}
						}, e$1.signal.addEventListener("abort", (() => {
							s$1.abort(), n$2(st());
						})), s$1.send(t$2.body);
					}));
				}(t$1, r$1);
			};
			function pt(t$1) {
				if (!t$1 || t$1.indexOf("://") <= 0 || 0 === t$1.indexOf("data:image/") || 0 === t$1.indexOf("blob:")) return !0;
				const e$1 = new URL(t$1), r$1 = window.location;
				return e$1.protocol === r$1.protocol && e$1.host === r$1.host;
			}
			function ft(t$1, e$1, r$1) {
				r$1[t$1] && -1 !== r$1[t$1].indexOf(e$1) || (r$1[t$1] = r$1[t$1] || [], r$1[t$1].push(e$1));
			}
			function dt(t$1, e$1, r$1) {
				if (r$1 && r$1[t$1]) {
					const n$1 = r$1[t$1].indexOf(e$1);
					-1 !== n$1 && r$1[t$1].splice(n$1, 1);
				}
			}
			class yt {
				constructor(t$1, e$1 = {}) {
					L(this, e$1), this.type = t$1;
				}
			}
			class mt extends yt {
				constructor(t$1, e$1 = {}) {
					super("error", L({ error: t$1 }, e$1));
				}
			}
			class gt {
				on(t$1, e$1) {
					return this._listeners = this._listeners || {}, ft(t$1, e$1, this._listeners), { unsubscribe: () => {
						this.off(t$1, e$1);
					} };
				}
				off(t$1, e$1) {
					return dt(t$1, e$1, this._listeners), dt(t$1, e$1, this._oneTimeListeners), this;
				}
				once(t$1, e$1) {
					return e$1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, ft(t$1, e$1, this._oneTimeListeners), this) : new Promise(((e$2) => this.once(t$1, e$2)));
				}
				fire(t$1, e$1) {
					"string" == typeof t$1 && (t$1 = new yt(t$1, e$1 || {}));
					const r$1 = t$1.type;
					if (this.listens(r$1)) {
						t$1.target = this;
						const e$2 = this._listeners && this._listeners[r$1] ? this._listeners[r$1].slice() : [];
						for (const r$2 of e$2) r$2.call(this, t$1);
						const n$1 = this._oneTimeListeners && this._oneTimeListeners[r$1] ? this._oneTimeListeners[r$1].slice() : [];
						for (const e$3 of n$1) dt(r$1, e$3, this._oneTimeListeners), e$3.call(this, t$1);
						const i$1 = this._eventedParent;
						i$1 && (L(t$1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i$1.fire(t$1));
					} else t$1 instanceof mt && console.error(t$1.error);
					return this;
				}
				listens(t$1) {
					return this._listeners && this._listeners[t$1] && this._listeners[t$1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t$1] && this._oneTimeListeners[t$1].length > 0 || this._eventedParent && this._eventedParent.listens(t$1);
				}
				setEventedParent(t$1, e$1) {
					return this._eventedParent = t$1, this._eventedParentData = e$1, this;
				}
			}
			var xt = {
				$version: 8,
				$root: {
					version: {
						required: !0,
						type: "enum",
						values: [8]
					},
					name: { type: "string" },
					metadata: { type: "*" },
					center: {
						type: "array",
						value: "number"
					},
					centerAltitude: { type: "number" },
					zoom: { type: "number" },
					bearing: {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees"
					},
					pitch: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					roll: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					state: {
						type: "state",
						default: {}
					},
					light: { type: "light" },
					sky: { type: "sky" },
					projection: { type: "projection" },
					terrain: { type: "terrain" },
					sources: {
						required: !0,
						type: "sources"
					},
					sprite: { type: "sprite" },
					glyphs: { type: "string" },
					"font-faces": {
						type: "array",
						value: "fontFaces"
					},
					transition: { type: "transition" },
					layers: {
						required: !0,
						type: "array",
						value: "layer"
					}
				},
				sources: { "*": { type: "source" } },
				source: [
					"source_vector",
					"source_raster",
					"source_raster_dem",
					"source_geojson",
					"source_video",
					"source_image"
				],
				source_vector: {
					type: {
						required: !0,
						type: "enum",
						values: { vector: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					attribution: { type: "string" },
					promoteId: { type: "promoteId" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster: {
					type: {
						required: !0,
						type: "enum",
						values: { raster: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					attribution: { type: "string" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster_dem: {
					type: {
						required: !0,
						type: "enum",
						values: { "raster-dem": {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					attribution: { type: "string" },
					encoding: {
						type: "enum",
						values: {
							terrarium: {},
							mapbox: {},
							custom: {}
						},
						default: "mapbox"
					},
					redFactor: {
						type: "number",
						default: 1
					},
					blueFactor: {
						type: "number",
						default: 1
					},
					greenFactor: {
						type: "number",
						default: 1
					},
					baseShift: {
						type: "number",
						default: 0
					},
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_geojson: {
					type: {
						required: !0,
						type: "enum",
						values: { geojson: {} }
					},
					data: {
						required: !0,
						type: "*"
					},
					maxzoom: {
						type: "number",
						default: 18
					},
					attribution: { type: "string" },
					buffer: {
						type: "number",
						default: 128,
						maximum: 512,
						minimum: 0
					},
					filter: { type: "*" },
					tolerance: {
						type: "number",
						default: .375
					},
					cluster: {
						type: "boolean",
						default: !1
					},
					clusterRadius: {
						type: "number",
						default: 50,
						minimum: 0
					},
					clusterMaxZoom: { type: "number" },
					clusterMinPoints: { type: "number" },
					clusterProperties: { type: "*" },
					lineMetrics: {
						type: "boolean",
						default: !1
					},
					generateId: {
						type: "boolean",
						default: !1
					},
					promoteId: { type: "promoteId" }
				},
				source_video: {
					type: {
						required: !0,
						type: "enum",
						values: { video: {} }
					},
					urls: {
						required: !0,
						type: "array",
						value: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				source_image: {
					type: {
						required: !0,
						type: "enum",
						values: { image: {} }
					},
					url: {
						required: !0,
						type: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				layer: {
					id: {
						type: "string",
						required: !0
					},
					type: {
						type: "enum",
						values: {
							fill: {},
							line: {},
							symbol: {},
							circle: {},
							heatmap: {},
							"fill-extrusion": {},
							raster: {},
							hillshade: {},
							"color-relief": {},
							background: {}
						},
						required: !0
					},
					metadata: { type: "*" },
					source: { type: "string" },
					"source-layer": { type: "string" },
					minzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					maxzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					filter: { type: "filter" },
					layout: { type: "layout" },
					paint: { type: "paint" }
				},
				layout: [
					"layout_fill",
					"layout_line",
					"layout_circle",
					"layout_heatmap",
					"layout_fill-extrusion",
					"layout_symbol",
					"layout_raster",
					"layout_hillshade",
					"layout_color-relief",
					"layout_background"
				],
				layout_background: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_fill: {
					"fill-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_circle: {
					"circle-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_heatmap: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_fill-extrusion": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_line: {
					"line-cap": {
						type: "enum",
						values: {
							butt: {},
							round: {},
							square: {}
						},
						default: "butt",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-join": {
						type: "enum",
						values: {
							bevel: {},
							round: {},
							miter: {}
						},
						default: "miter",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"line-miter-limit": {
						type: "number",
						default: 2,
						requires: [{ "line-join": "miter" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-round-limit": {
						type: "number",
						default: 1.05,
						requires: [{ "line-join": "round" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_symbol: {
					"symbol-placement": {
						type: "enum",
						values: {
							point: {},
							line: {},
							"line-center": {}
						},
						default: "point",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-spacing": {
						type: "number",
						default: 250,
						minimum: 1,
						units: "pixels",
						requires: [{ "symbol-placement": "line" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-avoid-edges": {
						type: "boolean",
						default: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"symbol-z-order": {
						type: "enum",
						values: {
							auto: {},
							"viewport-y": {},
							source: {}
						},
						default: "auto",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", { "!": "icon-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-optional": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-size": {
						type: "number",
						default: 1,
						minimum: 0,
						units: "factor of the original icon size",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-text-fit": {
						type: "enum",
						values: {
							none: {},
							width: {},
							height: {},
							both: {}
						},
						default: "none",
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-text-fit-padding": {
						type: "array",
						value: "number",
						length: 4,
						default: [
							0,
							0,
							0,
							0
						],
						units: "pixels",
						requires: [
							"icon-image",
							"text-field",
							{ "icon-text-fit": [
								"both",
								"width",
								"height"
							] }
						],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-image": {
						type: "resolvedImage",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-padding": {
						type: "padding",
						default: [2],
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-keep-upright": {
						type: "boolean",
						default: !1,
						requires: [
							"icon-image",
							{ "icon-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-offset": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							"viewport-glyph": {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-field": {
						type: "formatted",
						default: "",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-font": {
						type: "array",
						value: "string",
						default: ["Open Sans Regular", "Arial Unicode MS Regular"],
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-size": {
						type: "number",
						default: 16,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-width": {
						type: "number",
						default: 10,
						minimum: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-line-height": {
						type: "number",
						default: 1.2,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-letter-spacing": {
						type: "number",
						default: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-justify": {
						type: "enum",
						values: {
							auto: {},
							left: {},
							center: {},
							right: {}
						},
						default: "center",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-radial-offset": {
						type: "number",
						units: "ems",
						default: 0,
						requires: ["text-field"],
						"property-type": "data-driven",
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						}
					},
					"text-variable-anchor": {
						type: "array",
						value: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-variable-anchor-offset": {
						type: "variableAnchorOffsetCollection",
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["text-field", { "!": "text-variable-anchor" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-angle": {
						type: "number",
						default: 45,
						units: "degrees",
						requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-writing-mode": {
						type: "array",
						value: "enum",
						values: {
							horizontal: {},
							vertical: {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-padding": {
						type: "number",
						default: 2,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-keep-upright": {
						type: "boolean",
						default: !0,
						requires: [
							"text-field",
							{ "text-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-transform": {
						type: "enum",
						values: {
							none: {},
							uppercase: {},
							lowercase: {}
						},
						default: "none",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-offset": {
						type: "array",
						value: "number",
						units: "ems",
						length: 2,
						default: [0, 0],
						requires: ["text-field", { "!": "text-radial-offset" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["text-field", { "!": "text-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-optional": {
						type: "boolean",
						default: !1,
						requires: ["text-field", "icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_raster: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_hillshade: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_color-relief": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				filter: {
					type: "array",
					value: "*"
				},
				filter_operator: {
					type: "enum",
					values: {
						"==": {},
						"!=": {},
						">": {},
						">=": {},
						"<": {},
						"<=": {},
						in: {},
						"!in": {},
						all: {},
						any: {},
						none: {},
						has: {},
						"!has": {}
					}
				},
				geometry_type: {
					type: "enum",
					values: {
						Point: {},
						LineString: {},
						Polygon: {}
					}
				},
				function: {
					expression: { type: "expression" },
					stops: {
						type: "array",
						value: "function_stop"
					},
					base: {
						type: "number",
						default: 1,
						minimum: 0
					},
					property: {
						type: "string",
						default: "$zoom"
					},
					type: {
						type: "enum",
						values: {
							identity: {},
							exponential: {},
							interval: {},
							categorical: {}
						},
						default: "exponential"
					},
					colorSpace: {
						type: "enum",
						values: {
							rgb: {},
							lab: {},
							hcl: {}
						},
						default: "rgb"
					},
					default: {
						type: "*",
						required: !1
					}
				},
				function_stop: {
					type: "array",
					minimum: 0,
					maximum: 24,
					value: ["number", "color"],
					length: 2
				},
				expression: {
					type: "array",
					value: "*",
					minimum: 1
				},
				light: {
					anchor: {
						type: "enum",
						default: "viewport",
						values: {
							map: {},
							viewport: {}
						},
						"property-type": "data-constant",
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						}
					},
					position: {
						type: "array",
						default: [
							1.15,
							210,
							30
						],
						length: 3,
						value: "number",
						"property-type": "data-constant",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						}
					},
					color: {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					intensity: {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				sky: {
					"sky-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#88C6FC",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-ground-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-fog-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"sky-horizon-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"atmosphere-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				terrain: {
					source: {
						type: "string",
						required: !0
					},
					exaggeration: {
						type: "number",
						minimum: 0,
						default: 1
					}
				},
				projection: { type: {
					type: "projectionDefinition",
					default: "mercator",
					"property-type": "data-constant",
					transition: !1,
					expression: {
						interpolated: !0,
						parameters: ["zoom"]
					}
				} },
				paint: [
					"paint_fill",
					"paint_line",
					"paint_circle",
					"paint_heatmap",
					"paint_fill-extrusion",
					"paint_symbol",
					"paint_raster",
					"paint_hillshade",
					"paint_color-relief",
					"paint_background"
				],
				paint_fill: {
					"fill-antialias": {
						type: "boolean",
						default: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-outline-color": {
						type: "color",
						transition: !0,
						requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					}
				},
				"paint_fill-extrusion": {
					"fill-extrusion-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-extrusion-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-extrusion-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"fill-extrusion-height": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-base": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						requires: ["fill-extrusion-height"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-vertical-gradient": {
						type: "boolean",
						default: !0,
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_line: {
					"line-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["line-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-width": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-gap-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-offset": {
						type: "number",
						default: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-dasharray": {
						type: "array",
						value: "number",
						minimum: 0,
						transition: !0,
						units: "line widths",
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-gradient": {
						type: "color",
						transition: !1,
						requires: [
							{ "!": "line-dasharray" },
							{ "!": "line-pattern" },
							{
								source: "geojson",
								has: { lineMetrics: !0 }
							}
						],
						expression: {
							interpolated: !0,
							parameters: ["line-progress"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_circle: {
					"circle-radius": {
						type: "number",
						default: 5,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-blur": {
						type: "number",
						default: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["circle-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-scale": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-stroke-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					}
				},
				paint_heatmap: {
					"heatmap-radius": {
						type: "number",
						default: 30,
						minimum: 1,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-weight": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-intensity": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"heatmap-color": {
						type: "color",
						default: [
							"interpolate",
							["linear"],
							["heatmap-density"],
							0,
							"rgba(0, 0, 255, 0)",
							.1,
							"royalblue",
							.3,
							"cyan",
							.5,
							"lime",
							.7,
							"yellow",
							1,
							"red"
						],
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["heatmap-density"]
						},
						"property-type": "color-ramp"
					},
					"heatmap-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_symbol: {
					"icon-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["icon-image", "icon-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						overridable: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["text-field", "text-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_raster: {
					"raster-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-hue-rotate": {
						type: "number",
						default: 0,
						period: 360,
						transition: !0,
						units: "degrees",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-min": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-max": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-saturation": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-contrast": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-resampling": {
						type: "enum",
						values: {
							linear: {},
							nearest: {}
						},
						default: "linear",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-fade-duration": {
						type: "number",
						default: 300,
						minimum: 0,
						transition: !1,
						units: "milliseconds",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_hillshade: {
					"hillshade-illumination-direction": {
						type: "numberArray",
						default: 335,
						minimum: 0,
						maximum: 359,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-altitude": {
						type: "numberArray",
						default: 45,
						minimum: 0,
						maximum: 90,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-exaggeration": {
						type: "number",
						default: .5,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-shadow-color": {
						type: "colorArray",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-highlight-color": {
						type: "colorArray",
						default: "#FFFFFF",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-accent-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-method": {
						type: "enum",
						values: {
							standard: {},
							basic: {},
							combined: {},
							igor: {},
							multidirectional: {}
						},
						default: "standard",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				"paint_color-relief": {
					"color-relief-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"color-relief-color": {
						type: "color",
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["elevation"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_background: {
					"background-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "background-pattern" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"background-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"background-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				transition: {
					duration: {
						type: "number",
						default: 300,
						minimum: 0,
						units: "milliseconds"
					},
					delay: {
						type: "number",
						default: 0,
						minimum: 0,
						units: "milliseconds"
					}
				},
				"property-type": {
					"data-driven": { type: "property-type" },
					"cross-faded": { type: "property-type" },
					"cross-faded-data-driven": { type: "property-type" },
					"color-ramp": { type: "property-type" },
					"data-constant": { type: "property-type" },
					constant: { type: "property-type" }
				},
				promoteId: { "*": { type: "string" } }
			};
			const vt = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			];
			function bt(t$1, e$1) {
				const r$1 = {};
				for (const e$2 in t$1) "ref" !== e$2 && (r$1[e$2] = t$1[e$2]);
				return vt.forEach(((t$2) => {
					t$2 in e$1 && (r$1[t$2] = e$1[t$2]);
				})), r$1;
			}
			function wt(t$1, e$1) {
				if (Array.isArray(t$1)) {
					if (!Array.isArray(e$1) || t$1.length !== e$1.length) return !1;
					for (let r$1 = 0; r$1 < t$1.length; r$1++) if (!wt(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				if ("object" == typeof t$1 && null !== t$1 && null !== e$1) {
					if ("object" != typeof e$1) return !1;
					if (Object.keys(t$1).length !== Object.keys(e$1).length) return !1;
					for (const r$1 in t$1) if (!wt(t$1[r$1], e$1[r$1])) return !1;
					return !0;
				}
				return t$1 === e$1;
			}
			function _t(t$1, e$1) {
				t$1.push(e$1);
			}
			function St(t$1, e$1, r$1) {
				_t(r$1, {
					command: "addSource",
					args: [t$1, e$1[t$1]]
				});
			}
			function At(t$1, e$1, r$1) {
				_t(e$1, {
					command: "removeSource",
					args: [t$1]
				}), r$1[t$1] = !0;
			}
			function kt(t$1, e$1, r$1, n$1) {
				At(t$1, r$1, n$1), St(t$1, e$1, r$1);
			}
			function Mt(t$1, e$1, r$1) {
				let n$1;
				for (n$1 in t$1[r$1]) if (Object.prototype.hasOwnProperty.call(t$1[r$1], n$1) && "data" !== n$1 && !wt(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				for (n$1 in e$1[r$1]) if (Object.prototype.hasOwnProperty.call(e$1[r$1], n$1) && "data" !== n$1 && !wt(t$1[r$1][n$1], e$1[r$1][n$1])) return !1;
				return !0;
			}
			function It(t$1, e$1, r$1, n$1, i$1, s$1) {
				t$1 = t$1 || {}, e$1 = e$1 || {};
				for (const a$1 in t$1) Object.prototype.hasOwnProperty.call(t$1, a$1) && (wt(t$1[a$1], e$1[a$1]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a$1,
						e$1[a$1],
						i$1
					]
				}));
				for (const a$1 in e$1) Object.prototype.hasOwnProperty.call(e$1, a$1) && !Object.prototype.hasOwnProperty.call(t$1, a$1) && (wt(t$1[a$1], e$1[a$1]) || r$1.push({
					command: s$1,
					args: [
						n$1,
						a$1,
						e$1[a$1],
						i$1
					]
				}));
			}
			function zt(t$1) {
				return t$1.id;
			}
			function Pt(t$1, e$1) {
				return t$1[e$1.id] = e$1, t$1;
			}
			class Ct {
				constructor(t$1, e$1, r$1, n$1) {
					this.message = (t$1 ? `${t$1}: ` : "") + r$1, n$1 && (this.identifier = n$1), null != e$1 && e$1.__line__ && (this.line = e$1.__line__);
				}
			}
			function Et(t$1, ...e$1) {
				for (const r$1 of e$1) for (const e$2 in r$1) t$1[e$2] = r$1[e$2];
				return t$1;
			}
			class Tt extends Error {
				constructor(t$1, e$1) {
					super(e$1), this.message = e$1, this.key = t$1;
				}
			}
			class Bt {
				constructor(t$1, e$1 = []) {
					this.parent = t$1, this.bindings = {};
					for (const [t$2, r$1] of e$1) this.bindings[t$2] = r$1;
				}
				concat(t$1) {
					return new Bt(this, t$1);
				}
				get(t$1) {
					if (this.bindings[t$1]) return this.bindings[t$1];
					if (this.parent) return this.parent.get(t$1);
					throw new Error(`${t$1} not found in scope.`);
				}
				has(t$1) {
					return !!this.bindings[t$1] || !!this.parent && this.parent.has(t$1);
				}
			}
			const Vt = { kind: "null" }, Ft = { kind: "number" }, Dt = { kind: "string" }, $t = { kind: "boolean" }, Lt = { kind: "color" }, Ot = { kind: "projectionDefinition" }, Rt = { kind: "object" }, Ut = { kind: "value" }, jt = { kind: "collator" }, Nt = { kind: "formatted" }, qt = { kind: "padding" }, Gt = { kind: "colorArray" }, Xt = { kind: "numberArray" }, Zt = { kind: "resolvedImage" }, Yt = { kind: "variableAnchorOffsetCollection" };
			function Ht(t$1, e$1) {
				return {
					kind: "array",
					itemType: t$1,
					N: e$1
				};
			}
			function Kt(t$1) {
				if ("array" === t$1.kind) {
					const e$1 = Kt(t$1.itemType);
					return "number" == typeof t$1.N ? `array<${e$1}, ${t$1.N}>` : "value" === t$1.itemType.kind ? "array" : `array<${e$1}>`;
				}
				return t$1.kind;
			}
			const Jt = [
				Vt,
				Ft,
				Dt,
				$t,
				Lt,
				Ot,
				Nt,
				Rt,
				Ht(Ut),
				qt,
				Xt,
				Gt,
				Zt,
				Yt
			];
			function Wt(t$1, e$1) {
				if ("error" === e$1.kind) return null;
				if ("array" === t$1.kind) {
					if ("array" === e$1.kind && (0 === e$1.N && "value" === e$1.itemType.kind || !Wt(t$1.itemType, e$1.itemType)) && ("number" != typeof t$1.N || t$1.N === e$1.N)) return null;
				} else {
					if (t$1.kind === e$1.kind) return null;
					if ("value" === t$1.kind) {
						for (const t$2 of Jt) if (!Wt(t$2, e$1)) return null;
					}
				}
				return `Expected ${Kt(t$1)} but found ${Kt(e$1)} instead.`;
			}
			function Qt(t$1, e$1) {
				return e$1.some(((e$2) => e$2.kind === t$1.kind));
			}
			function te(t$1, e$1) {
				return e$1.some(((e$2) => "null" === e$2 ? null === t$1 : "array" === e$2 ? Array.isArray(t$1) : "object" === e$2 ? t$1 && !Array.isArray(t$1) && "object" == typeof t$1 : e$2 === typeof t$1));
			}
			function ee(t$1, e$1) {
				return "array" === t$1.kind && "array" === e$1.kind ? t$1.itemType.kind === e$1.itemType.kind && "number" == typeof t$1.N : t$1.kind === e$1.kind;
			}
			const re = .96422, ne = .82521, ie = 4 / 29, se = 6 / 29, ae = 3 * se * se, oe = se * se * se, le = Math.PI / 180, ue = 180 / Math.PI;
			function ce(t$1) {
				return (t$1 %= 360) < 0 && (t$1 += 360), t$1;
			}
			function he([t$1, e$1, r$1, n$1]) {
				let i$1, s$1;
				const a$1 = fe((.2225045 * (t$1 = pe(t$1)) + .7168786 * (e$1 = pe(e$1)) + .0606169 * (r$1 = pe(r$1))) / 1);
				t$1 === e$1 && e$1 === r$1 ? i$1 = s$1 = a$1 : (i$1 = fe((.4360747 * t$1 + .3850649 * e$1 + .1430804 * r$1) / re), s$1 = fe((.0139322 * t$1 + .0971045 * e$1 + .7141733 * r$1) / ne));
				const o$1 = 116 * a$1 - 16;
				return [
					o$1 < 0 ? 0 : o$1,
					500 * (i$1 - a$1),
					200 * (a$1 - s$1),
					n$1
				];
			}
			function pe(t$1) {
				return t$1 <= .04045 ? t$1 / 12.92 : Math.pow((t$1 + .055) / 1.055, 2.4);
			}
			function fe(t$1) {
				return t$1 > oe ? Math.pow(t$1, 1 / 3) : t$1 / ae + ie;
			}
			function de([t$1, e$1, r$1, n$1]) {
				let i$1 = (t$1 + 16) / 116, s$1 = isNaN(e$1) ? i$1 : i$1 + e$1 / 500, a$1 = isNaN(r$1) ? i$1 : i$1 - r$1 / 200;
				return i$1 = 1 * me(i$1), s$1 = re * me(s$1), a$1 = ne * me(a$1), [
					ye(3.1338561 * s$1 - 1.6168667 * i$1 - .4906146 * a$1),
					ye(-.9787684 * s$1 + 1.9161415 * i$1 + .033454 * a$1),
					ye(.0719453 * s$1 - .2289914 * i$1 + 1.4052427 * a$1),
					n$1
				];
			}
			function ye(t$1) {
				return (t$1 = t$1 <= .00304 ? 12.92 * t$1 : 1.055 * Math.pow(t$1, 1 / 2.4) - .055) < 0 ? 0 : t$1 > 1 ? 1 : t$1;
			}
			function me(t$1) {
				return t$1 > se ? t$1 * t$1 * t$1 : ae * (t$1 - ie);
			}
			const ge = Object.hasOwn || function(t$1, e$1) {
				return Object.prototype.hasOwnProperty.call(t$1, e$1);
			};
			function xe(t$1, e$1) {
				return ge(t$1, e$1) ? t$1[e$1] : void 0;
			}
			function ve(t$1) {
				return parseInt(t$1.padEnd(2, t$1), 16) / 255;
			}
			function be(t$1, e$1) {
				return we(e$1 ? t$1 / 100 : t$1, 0, 1);
			}
			function we(t$1, e$1, r$1) {
				return Math.min(Math.max(e$1, t$1), r$1);
			}
			function _e(t$1) {
				return !t$1.some(Number.isNaN);
			}
			const Se = {
				aliceblue: [
					240,
					248,
					255
				],
				antiquewhite: [
					250,
					235,
					215
				],
				aqua: [
					0,
					255,
					255
				],
				aquamarine: [
					127,
					255,
					212
				],
				azure: [
					240,
					255,
					255
				],
				beige: [
					245,
					245,
					220
				],
				bisque: [
					255,
					228,
					196
				],
				black: [
					0,
					0,
					0
				],
				blanchedalmond: [
					255,
					235,
					205
				],
				blue: [
					0,
					0,
					255
				],
				blueviolet: [
					138,
					43,
					226
				],
				brown: [
					165,
					42,
					42
				],
				burlywood: [
					222,
					184,
					135
				],
				cadetblue: [
					95,
					158,
					160
				],
				chartreuse: [
					127,
					255,
					0
				],
				chocolate: [
					210,
					105,
					30
				],
				coral: [
					255,
					127,
					80
				],
				cornflowerblue: [
					100,
					149,
					237
				],
				cornsilk: [
					255,
					248,
					220
				],
				crimson: [
					220,
					20,
					60
				],
				cyan: [
					0,
					255,
					255
				],
				darkblue: [
					0,
					0,
					139
				],
				darkcyan: [
					0,
					139,
					139
				],
				darkgoldenrod: [
					184,
					134,
					11
				],
				darkgray: [
					169,
					169,
					169
				],
				darkgreen: [
					0,
					100,
					0
				],
				darkgrey: [
					169,
					169,
					169
				],
				darkkhaki: [
					189,
					183,
					107
				],
				darkmagenta: [
					139,
					0,
					139
				],
				darkolivegreen: [
					85,
					107,
					47
				],
				darkorange: [
					255,
					140,
					0
				],
				darkorchid: [
					153,
					50,
					204
				],
				darkred: [
					139,
					0,
					0
				],
				darksalmon: [
					233,
					150,
					122
				],
				darkseagreen: [
					143,
					188,
					143
				],
				darkslateblue: [
					72,
					61,
					139
				],
				darkslategray: [
					47,
					79,
					79
				],
				darkslategrey: [
					47,
					79,
					79
				],
				darkturquoise: [
					0,
					206,
					209
				],
				darkviolet: [
					148,
					0,
					211
				],
				deeppink: [
					255,
					20,
					147
				],
				deepskyblue: [
					0,
					191,
					255
				],
				dimgray: [
					105,
					105,
					105
				],
				dimgrey: [
					105,
					105,
					105
				],
				dodgerblue: [
					30,
					144,
					255
				],
				firebrick: [
					178,
					34,
					34
				],
				floralwhite: [
					255,
					250,
					240
				],
				forestgreen: [
					34,
					139,
					34
				],
				fuchsia: [
					255,
					0,
					255
				],
				gainsboro: [
					220,
					220,
					220
				],
				ghostwhite: [
					248,
					248,
					255
				],
				gold: [
					255,
					215,
					0
				],
				goldenrod: [
					218,
					165,
					32
				],
				gray: [
					128,
					128,
					128
				],
				green: [
					0,
					128,
					0
				],
				greenyellow: [
					173,
					255,
					47
				],
				grey: [
					128,
					128,
					128
				],
				honeydew: [
					240,
					255,
					240
				],
				hotpink: [
					255,
					105,
					180
				],
				indianred: [
					205,
					92,
					92
				],
				indigo: [
					75,
					0,
					130
				],
				ivory: [
					255,
					255,
					240
				],
				khaki: [
					240,
					230,
					140
				],
				lavender: [
					230,
					230,
					250
				],
				lavenderblush: [
					255,
					240,
					245
				],
				lawngreen: [
					124,
					252,
					0
				],
				lemonchiffon: [
					255,
					250,
					205
				],
				lightblue: [
					173,
					216,
					230
				],
				lightcoral: [
					240,
					128,
					128
				],
				lightcyan: [
					224,
					255,
					255
				],
				lightgoldenrodyellow: [
					250,
					250,
					210
				],
				lightgray: [
					211,
					211,
					211
				],
				lightgreen: [
					144,
					238,
					144
				],
				lightgrey: [
					211,
					211,
					211
				],
				lightpink: [
					255,
					182,
					193
				],
				lightsalmon: [
					255,
					160,
					122
				],
				lightseagreen: [
					32,
					178,
					170
				],
				lightskyblue: [
					135,
					206,
					250
				],
				lightslategray: [
					119,
					136,
					153
				],
				lightslategrey: [
					119,
					136,
					153
				],
				lightsteelblue: [
					176,
					196,
					222
				],
				lightyellow: [
					255,
					255,
					224
				],
				lime: [
					0,
					255,
					0
				],
				limegreen: [
					50,
					205,
					50
				],
				linen: [
					250,
					240,
					230
				],
				magenta: [
					255,
					0,
					255
				],
				maroon: [
					128,
					0,
					0
				],
				mediumaquamarine: [
					102,
					205,
					170
				],
				mediumblue: [
					0,
					0,
					205
				],
				mediumorchid: [
					186,
					85,
					211
				],
				mediumpurple: [
					147,
					112,
					219
				],
				mediumseagreen: [
					60,
					179,
					113
				],
				mediumslateblue: [
					123,
					104,
					238
				],
				mediumspringgreen: [
					0,
					250,
					154
				],
				mediumturquoise: [
					72,
					209,
					204
				],
				mediumvioletred: [
					199,
					21,
					133
				],
				midnightblue: [
					25,
					25,
					112
				],
				mintcream: [
					245,
					255,
					250
				],
				mistyrose: [
					255,
					228,
					225
				],
				moccasin: [
					255,
					228,
					181
				],
				navajowhite: [
					255,
					222,
					173
				],
				navy: [
					0,
					0,
					128
				],
				oldlace: [
					253,
					245,
					230
				],
				olive: [
					128,
					128,
					0
				],
				olivedrab: [
					107,
					142,
					35
				],
				orange: [
					255,
					165,
					0
				],
				orangered: [
					255,
					69,
					0
				],
				orchid: [
					218,
					112,
					214
				],
				palegoldenrod: [
					238,
					232,
					170
				],
				palegreen: [
					152,
					251,
					152
				],
				paleturquoise: [
					175,
					238,
					238
				],
				palevioletred: [
					219,
					112,
					147
				],
				papayawhip: [
					255,
					239,
					213
				],
				peachpuff: [
					255,
					218,
					185
				],
				peru: [
					205,
					133,
					63
				],
				pink: [
					255,
					192,
					203
				],
				plum: [
					221,
					160,
					221
				],
				powderblue: [
					176,
					224,
					230
				],
				purple: [
					128,
					0,
					128
				],
				rebeccapurple: [
					102,
					51,
					153
				],
				red: [
					255,
					0,
					0
				],
				rosybrown: [
					188,
					143,
					143
				],
				royalblue: [
					65,
					105,
					225
				],
				saddlebrown: [
					139,
					69,
					19
				],
				salmon: [
					250,
					128,
					114
				],
				sandybrown: [
					244,
					164,
					96
				],
				seagreen: [
					46,
					139,
					87
				],
				seashell: [
					255,
					245,
					238
				],
				sienna: [
					160,
					82,
					45
				],
				silver: [
					192,
					192,
					192
				],
				skyblue: [
					135,
					206,
					235
				],
				slateblue: [
					106,
					90,
					205
				],
				slategray: [
					112,
					128,
					144
				],
				slategrey: [
					112,
					128,
					144
				],
				snow: [
					255,
					250,
					250
				],
				springgreen: [
					0,
					255,
					127
				],
				steelblue: [
					70,
					130,
					180
				],
				tan: [
					210,
					180,
					140
				],
				teal: [
					0,
					128,
					128
				],
				thistle: [
					216,
					191,
					216
				],
				tomato: [
					255,
					99,
					71
				],
				turquoise: [
					64,
					224,
					208
				],
				violet: [
					238,
					130,
					238
				],
				wheat: [
					245,
					222,
					179
				],
				white: [
					255,
					255,
					255
				],
				whitesmoke: [
					245,
					245,
					245
				],
				yellow: [
					255,
					255,
					0
				],
				yellowgreen: [
					154,
					205,
					50
				]
			};
			function Ae(t$1, e$1, r$1) {
				return t$1 + r$1 * (e$1 - t$1);
			}
			function ke(t$1, e$1, r$1) {
				return t$1.map(((t$2, n$1) => Ae(t$2, e$1[n$1], r$1)));
			}
			class Me {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = !0) {
					this.r = t$1, this.g = e$1, this.b = r$1, this.a = n$1, i$1 || (this.r *= n$1, this.g *= n$1, this.b *= n$1, n$1 || this.overwriteGetter("rgb", [
						t$1,
						e$1,
						r$1,
						n$1
					]));
				}
				static parse(t$1) {
					if (t$1 instanceof Me) return t$1;
					if ("string" != typeof t$1) return;
					const e$1 = function(t$2) {
						if ("transparent" === (t$2 = t$2.toLowerCase().trim())) return [
							0,
							0,
							0,
							0
						];
						const e$2 = xe(Se, t$2);
						if (e$2) {
							const [t$3, r$2, n$1] = e$2;
							return [
								t$3 / 255,
								r$2 / 255,
								n$1 / 255,
								1
							];
						}
						if (t$2.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t$2)) {
							const e$3 = t$2.length < 6 ? 1 : 2;
							let r$2 = 1;
							return [
								ve(t$2.slice(r$2, r$2 += e$3)),
								ve(t$2.slice(r$2, r$2 += e$3)),
								ve(t$2.slice(r$2, r$2 += e$3)),
								ve(t$2.slice(r$2, r$2 + e$3) || "ff")
							];
						}
						if (t$2.startsWith("rgb")) {
							const e$3 = t$2.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
							if (e$3) {
								const [t$3, r$2, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1] = e$3, f$1 = [
									i$1 || " ",
									o$1 || " ",
									c$1
								].join("");
								if ("  " === f$1 || "  /" === f$1 || ",," === f$1 || ",,," === f$1) {
									const t$4 = [
										n$1,
										a$1,
										u$1
									].join(""), e$4 = "%%%" === t$4 ? 100 : "" === t$4 ? 255 : 0;
									if (e$4) {
										const t$5 = [
											we(+r$2 / e$4, 0, 1),
											we(+s$1 / e$4, 0, 1),
											we(+l$1 / e$4, 0, 1),
											h$1 ? be(+h$1, p$1) : 1
										];
										if (_e(t$5)) return t$5;
									}
								}
								return;
							}
						}
						const r$1 = t$2.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
						if (r$1) {
							const [t$3, e$3, n$1, i$1, s$1, a$1, o$1, l$1, u$1] = r$1, c$1 = [
								n$1 || " ",
								s$1 || " ",
								o$1
							].join("");
							if ("  " === c$1 || "  /" === c$1 || ",," === c$1 || ",,," === c$1) {
								const t$4 = [
									+e$3,
									we(+i$1, 0, 100),
									we(+a$1, 0, 100),
									l$1 ? be(+l$1, u$1) : 1
								];
								if (_e(t$4)) return function([t$5, e$4, r$2, n$2]) {
									function i$2(n$3) {
										const i$3 = (n$3 + t$5 / 30) % 12, s$2 = e$4 * Math.min(r$2, 1 - r$2);
										return r$2 - s$2 * Math.max(-1, Math.min(i$3 - 3, 9 - i$3, 1));
									}
									return t$5 = ce(t$5), e$4 /= 100, r$2 /= 100, [
										i$2(0),
										i$2(8),
										i$2(4),
										n$2
									];
								}(t$4);
							}
						}
					}(t$1);
					return e$1 ? new Me(...e$1, !1) : void 0;
				}
				get rgb() {
					const { r: t$1, g: e$1, b: r$1, a: n$1 } = this, i$1 = n$1 || Infinity;
					return this.overwriteGetter("rgb", [
						t$1 / i$1,
						e$1 / i$1,
						r$1 / i$1,
						n$1
					]);
				}
				get hcl() {
					return this.overwriteGetter("hcl", function(t$1) {
						const [e$1, r$1, n$1, i$1] = he(t$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
						return [
							Math.round(1e4 * s$1) ? ce(Math.atan2(n$1, r$1) * ue) : NaN,
							s$1,
							e$1,
							i$1
						];
					}(this.rgb));
				}
				get lab() {
					return this.overwriteGetter("lab", he(this.rgb));
				}
				overwriteGetter(t$1, e$1) {
					return Object.defineProperty(this, t$1, { value: e$1 }), e$1;
				}
				toString() {
					const [t$1, e$1, r$1, n$1] = this.rgb;
					return `rgba(${[
						t$1,
						e$1,
						r$1
					].map(((t$2) => Math.round(255 * t$2))).join(",")},${n$1})`;
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					switch (n$1) {
						case "rgb": {
							const [n$2, i$1, s$1, a$1] = ke(t$1.rgb, e$1.rgb, r$1);
							return new Me(n$2, i$1, s$1, a$1, !1);
						}
						case "hcl": {
							const [n$2, i$1, s$1, a$1] = t$1.hcl, [o$1, l$1, u$1, c$1] = e$1.hcl;
							let h$1, p$1;
							if (isNaN(n$2) || isNaN(o$1)) isNaN(n$2) ? isNaN(o$1) ? h$1 = NaN : (h$1 = o$1, 1 !== s$1 && 0 !== s$1 || (p$1 = l$1)) : (h$1 = n$2, 1 !== u$1 && 0 !== u$1 || (p$1 = i$1));
							else {
								let t$2 = o$1 - n$2;
								o$1 > n$2 && t$2 > 180 ? t$2 -= 360 : o$1 < n$2 && n$2 - o$1 > 180 && (t$2 += 360), h$1 = n$2 + r$1 * t$2;
							}
							const [f$1, d$1, y$1, m$1] = function([t$2, e$2, r$2, n$3]) {
								return t$2 = isNaN(t$2) ? 0 : t$2 * le, de([
									r$2,
									Math.cos(t$2) * e$2,
									Math.sin(t$2) * e$2,
									n$3
								]);
							}([
								h$1,
								null != p$1 ? p$1 : Ae(i$1, l$1, r$1),
								Ae(s$1, u$1, r$1),
								Ae(a$1, c$1, r$1)
							]);
							return new Me(f$1, d$1, y$1, m$1, !1);
						}
						case "lab": {
							const [n$2, i$1, s$1, a$1] = de(ke(t$1.lab, e$1.lab, r$1));
							return new Me(n$2, i$1, s$1, a$1, !1);
						}
					}
				}
			}
			Me.black = new Me(0, 0, 0, 1), Me.white = new Me(1, 1, 1, 1), Me.transparent = new Me(0, 0, 0, 0), Me.red = new Me(1, 0, 0, 1);
			class Ie {
				constructor(t$1, e$1, r$1) {
					this.sensitivity = t$1 ? e$1 ? "variant" : "case" : e$1 ? "accent" : "base", this.locale = r$1, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(t$1, e$1) {
					return this.collator.compare(t$1, e$1);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			const ze = [
				"bottom",
				"center",
				"top"
			];
			class Pe {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.text = t$1, this.image = e$1, this.scale = r$1, this.fontStack = n$1, this.textColor = i$1, this.verticalAlign = s$1;
				}
			}
			class Ce {
				constructor(t$1) {
					this.sections = t$1;
				}
				static fromString(t$1) {
					return new Ce([new Pe(t$1, null, null, null, null, null)]);
				}
				isEmpty() {
					return 0 === this.sections.length || !this.sections.some(((t$1) => 0 !== t$1.text.length || t$1.image && 0 !== t$1.image.name.length));
				}
				static factory(t$1) {
					return t$1 instanceof Ce ? t$1 : Ce.fromString(t$1);
				}
				toString() {
					return 0 === this.sections.length ? "" : this.sections.map(((t$1) => t$1.text)).join("");
				}
			}
			class Ee {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Ee) return t$1;
					if ("number" == typeof t$1) return new Ee([
						t$1,
						t$1,
						t$1,
						t$1
					]);
					if (Array.isArray(t$1) && !(t$1.length < 1 || t$1.length > 4)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						switch (t$1.length) {
							case 1:
								t$1 = [
									t$1[0],
									t$1[0],
									t$1[0],
									t$1[0]
								];
								break;
							case 2:
								t$1 = [
									t$1[0],
									t$1[1],
									t$1[0],
									t$1[1]
								];
								break;
							case 3: t$1 = [
								t$1[0],
								t$1[1],
								t$1[2],
								t$1[1]
							];
						}
						return new Ee(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Ee(ke(t$1.values, e$1.values, r$1));
				}
			}
			class Te {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Te) return t$1;
					if ("number" == typeof t$1) return new Te([t$1]);
					if (Array.isArray(t$1)) {
						for (const e$1 of t$1) if ("number" != typeof e$1) return;
						return new Te(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					return new Te(ke(t$1.values, e$1.values, r$1));
				}
			}
			class Be {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof Be) return t$1;
					if ("string" == typeof t$1) {
						const e$2 = Me.parse(t$1);
						if (!e$2) return;
						return new Be([e$2]);
					}
					if (!Array.isArray(t$1)) return;
					const e$1 = [];
					for (const r$1 of t$1) {
						if ("string" != typeof r$1) return;
						const t$2 = Me.parse(r$1);
						if (!t$2) return;
						e$1.push(t$2);
					}
					return new Be(e$1);
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1, n$1 = "rgb") {
					const i$1 = [];
					if (t$1.values.length != e$1.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t$1.values.length} vs. ${e$1.values.length}), cannot interpolate.`);
					for (let s$1 = 0; s$1 < t$1.values.length; s$1++) i$1.push(Me.interpolate(t$1.values[s$1], e$1.values[s$1], r$1, n$1));
					return new Be(i$1);
				}
			}
			class Ve extends Error {
				constructor(t$1) {
					super(t$1), this.name = "RuntimeError";
				}
				toJSON() {
					return this.message;
				}
			}
			const Fe = new Set([
				"center",
				"left",
				"right",
				"top",
				"bottom",
				"top-left",
				"top-right",
				"bottom-left",
				"bottom-right"
			]);
			class De {
				constructor(t$1) {
					this.values = t$1.slice();
				}
				static parse(t$1) {
					if (t$1 instanceof De) return t$1;
					if (Array.isArray(t$1) && !(t$1.length < 1) && t$1.length % 2 == 0) {
						for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
							const r$1 = t$1[e$1], n$1 = t$1[e$1 + 1];
							if ("string" != typeof r$1 || !Fe.has(r$1)) return;
							if (!Array.isArray(n$1) || 2 !== n$1.length || "number" != typeof n$1[0] || "number" != typeof n$1[1]) return;
						}
						return new De(t$1);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(t$1, e$1, r$1) {
					const n$1 = t$1.values, i$1 = e$1.values;
					if (n$1.length !== i$1.length) throw new Ve(`Cannot interpolate values of different length. from: ${t$1.toString()}, to: ${e$1.toString()}`);
					const s$1 = [];
					for (let t$2 = 0; t$2 < n$1.length; t$2 += 2) {
						if (n$1[t$2] !== i$1[t$2]) throw new Ve(`Cannot interpolate values containing mismatched anchors. from[${t$2}]: ${n$1[t$2]}, to[${t$2}]: ${i$1[t$2]}`);
						s$1.push(n$1[t$2]);
						const [e$2, a$1] = n$1[t$2 + 1], [o$1, l$1] = i$1[t$2 + 1];
						s$1.push([Ae(e$2, o$1, r$1), Ae(a$1, l$1, r$1)]);
					}
					return new De(s$1);
				}
			}
			class $e {
				constructor(t$1) {
					this.name = t$1.name, this.available = t$1.available;
				}
				toString() {
					return this.name;
				}
				static fromString(t$1) {
					return t$1 ? new $e({
						name: t$1,
						available: !1
					}) : null;
				}
			}
			class Le {
				constructor(t$1, e$1, r$1) {
					this.from = t$1, this.to = e$1, this.transition = r$1;
				}
				static interpolate(t$1, e$1, r$1) {
					return new Le(t$1, e$1, r$1);
				}
				static parse(t$1) {
					return t$1 instanceof Le ? t$1 : Array.isArray(t$1) && 3 === t$1.length && "string" == typeof t$1[0] && "string" == typeof t$1[1] && "number" == typeof t$1[2] ? new Le(t$1[0], t$1[1], t$1[2]) : "object" == typeof t$1 && "string" == typeof t$1.from && "string" == typeof t$1.to && "number" == typeof t$1.transition ? new Le(t$1.from, t$1.to, t$1.transition) : "string" == typeof t$1 ? new Le(t$1, t$1, 1) : void 0;
				}
			}
			function Oe(t$1, e$1, r$1, n$1) {
				return "number" == typeof t$1 && t$1 >= 0 && t$1 <= 255 && "number" == typeof e$1 && e$1 >= 0 && e$1 <= 255 && "number" == typeof r$1 && r$1 >= 0 && r$1 <= 255 ? void 0 === n$1 || "number" == typeof n$1 && n$1 >= 0 && n$1 <= 1 ? null : `Invalid rgba value [${[
					t$1,
					e$1,
					r$1,
					n$1
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n$1 ? [
					t$1,
					e$1,
					r$1,
					n$1
				] : [
					t$1,
					e$1,
					r$1
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function Re(t$1) {
				if (null === t$1 || "string" == typeof t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || t$1 instanceof Le || t$1 instanceof Me || t$1 instanceof Ie || t$1 instanceof Ce || t$1 instanceof Ee || t$1 instanceof Te || t$1 instanceof Be || t$1 instanceof De || t$1 instanceof $e) return !0;
				if (Array.isArray(t$1)) {
					for (const e$1 of t$1) if (!Re(e$1)) return !1;
					return !0;
				}
				if ("object" == typeof t$1) {
					for (const e$1 in t$1) if (!Re(t$1[e$1])) return !1;
					return !0;
				}
				return !1;
			}
			function Ue(t$1) {
				if (null === t$1) return Vt;
				if ("string" == typeof t$1) return Dt;
				if ("boolean" == typeof t$1) return $t;
				if ("number" == typeof t$1) return Ft;
				if (t$1 instanceof Me) return Lt;
				if (t$1 instanceof Le) return Ot;
				if (t$1 instanceof Ie) return jt;
				if (t$1 instanceof Ce) return Nt;
				if (t$1 instanceof Ee) return qt;
				if (t$1 instanceof Te) return Xt;
				if (t$1 instanceof Be) return Gt;
				if (t$1 instanceof De) return Yt;
				if (t$1 instanceof $e) return Zt;
				if (Array.isArray(t$1)) {
					const e$1 = t$1.length;
					let r$1;
					for (const e$2 of t$1) {
						const t$2 = Ue(e$2);
						if (r$1) {
							if (r$1 === t$2) continue;
							r$1 = Ut;
							break;
						}
						r$1 = t$2;
					}
					return Ht(r$1 || Ut, e$1);
				}
				return Rt;
			}
			function je(t$1) {
				const e$1 = typeof t$1;
				return null === t$1 ? "" : "string" === e$1 || "number" === e$1 || "boolean" === e$1 ? String(t$1) : t$1 instanceof Me || t$1 instanceof Le || t$1 instanceof Ce || t$1 instanceof Ee || t$1 instanceof Te || t$1 instanceof Be || t$1 instanceof De || t$1 instanceof $e ? t$1.toString() : JSON.stringify(t$1);
			}
			class Ne {
				constructor(t$1, e$1) {
					this.type = t$1, this.value = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'literal' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (!Re(t$1[1])) return e$1.error("invalid value");
					const r$1 = t$1[1];
					let n$1 = Ue(r$1);
					const i$1 = e$1.expectedType;
					return "array" !== n$1.kind || 0 !== n$1.N || !i$1 || "array" !== i$1.kind || "number" == typeof i$1.N && 0 !== i$1.N || (n$1 = i$1), new Ne(n$1, r$1);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			const qe = {
				string: Dt,
				number: Ft,
				boolean: $t,
				object: Rt
			};
			class Ge {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1, n$1 = 1;
					const i$1 = t$1[0];
					if ("array" === i$1) {
						let i$2, s$2;
						if (t$1.length > 2) {
							const r$2 = t$1[1];
							if ("string" != typeof r$2 || !(r$2 in qe) || "object" === r$2) return e$1.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							i$2 = qe[r$2], n$1++;
						} else i$2 = Ut;
						if (t$1.length > 3) {
							if (null !== t$1[2] && ("number" != typeof t$1[2] || t$1[2] < 0 || t$1[2] !== Math.floor(t$1[2]))) return e$1.error("The length argument to \"array\" must be a positive integer literal", 2);
							s$2 = t$1[2], n$1++;
						}
						r$1 = Ht(i$2, s$2);
					} else {
						if (!qe[i$1]) throw new Error(`Types doesn't contain name = ${i$1}`);
						r$1 = qe[i$1];
					}
					const s$1 = [];
					for (; n$1 < t$1.length; n$1++) {
						const r$2 = e$1.parse(t$1[n$1], n$1, Ut);
						if (!r$2) return null;
						s$1.push(r$2);
					}
					return new Ge(r$1, s$1);
				}
				evaluate(t$1) {
					for (let e$1 = 0; e$1 < this.args.length; e$1++) {
						const r$1 = this.args[e$1].evaluate(t$1);
						if (!Wt(this.type, Ue(r$1))) return r$1;
						if (e$1 === this.args.length - 1) throw new Ve(`Expected value to be of type ${Kt(this.type)}, but found ${Kt(Ue(r$1))} instead.`);
					}
					throw new Error();
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Xe = {
				"to-boolean": $t,
				"to-color": Lt,
				"to-number": Ft,
				"to-string": Dt
			};
			class Ze {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[0];
					if (!Xe[r$1]) throw new Error(`Can't parse ${r$1} as it is not part of the known types`);
					if (("to-boolean" === r$1 || "to-string" === r$1) && 2 !== t$1.length) return e$1.error("Expected one argument.");
					const n$1 = Xe[r$1], i$1 = [];
					for (let r$2 = 1; r$2 < t$1.length; r$2++) {
						const n$2 = e$1.parse(t$1[r$2], r$2, Ut);
						if (!n$2) return null;
						i$1.push(n$2);
					}
					return new Ze(n$1, i$1);
				}
				evaluate(t$1) {
					switch (this.type.kind) {
						case "boolean": return Boolean(this.args[0].evaluate(t$1));
						case "color": {
							let e$1, r$1;
							for (const n$1 of this.args) {
								if (e$1 = n$1.evaluate(t$1), r$1 = null, e$1 instanceof Me) return e$1;
								if ("string" == typeof e$1) {
									const r$2 = t$1.parseColor(e$1);
									if (r$2) return r$2;
								} else if (Array.isArray(e$1) && (r$1 = e$1.length < 3 || e$1.length > 4 ? `Invalid rgba value ${JSON.stringify(e$1)}: expected an array containing either three or four numeric values.` : Oe(e$1[0], e$1[1], e$1[2], e$1[3]), !r$1)) return new Me(e$1[0] / 255, e$1[1] / 255, e$1[2] / 255, e$1[3]);
							}
							throw new Ve(r$1 || `Could not parse color from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "padding": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Ee.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse padding from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "numberArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Te.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse numberArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "colorArray": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = Be.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse colorArray from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "variableAnchorOffsetCollection": {
							let e$1;
							for (const r$1 of this.args) {
								e$1 = r$1.evaluate(t$1);
								const n$1 = De.parse(e$1);
								if (n$1) return n$1;
							}
							throw new Ve(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e$1 ? e$1 : JSON.stringify(e$1)}'`);
						}
						case "number": {
							let e$1 = null;
							for (const r$1 of this.args) {
								if (e$1 = r$1.evaluate(t$1), null === e$1) return 0;
								const n$1 = Number(e$1);
								if (!isNaN(n$1)) return n$1;
							}
							throw new Ve(`Could not convert ${JSON.stringify(e$1)} to number.`);
						}
						case "formatted": return Ce.fromString(je(this.args[0].evaluate(t$1)));
						case "resolvedImage": return $e.fromString(je(this.args[0].evaluate(t$1)));
						case "projectionDefinition": return this.args[0].evaluate(t$1);
						default: return je(this.args[0].evaluate(t$1));
					}
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			const Ye = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class He {
				constructor() {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
				}
				id() {
					return this.feature && "id" in this.feature ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? "number" == typeof this.feature.type ? Ye[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				parseColor(t$1) {
					let e$1 = this._parseColorCache.get(t$1);
					return e$1 || (e$1 = Me.parse(t$1), this._parseColorCache.set(t$1, e$1)), e$1;
				}
			}
			class Ke {
				constructor(t$1, e$1, r$1 = [], n$1, i$1 = new Bt(), s$1 = []) {
					this.registry = t$1, this.path = r$1, this.key = r$1.map(((t$2) => `[${t$2}]`)).join(""), this.scope = i$1, this.errors = s$1, this.expectedType = n$1, this._isConstant = e$1;
				}
				parse(t$1, e$1, r$1, n$1, i$1 = {}) {
					return e$1 ? this.concat(e$1, r$1, n$1)._parse(t$1, i$1) : this._parse(t$1, i$1);
				}
				_parse(t$1, e$1) {
					function r$1(t$2, e$2, r$2) {
						return "assert" === r$2 ? new Ge(e$2, [t$2]) : "coerce" === r$2 ? new Ze(e$2, [t$2]) : t$2;
					}
					if (null !== t$1 && "string" != typeof t$1 && "boolean" != typeof t$1 && "number" != typeof t$1 || (t$1 = ["literal", t$1]), Array.isArray(t$1)) {
						if (0 === t$1.length) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						const n$1 = t$1[0];
						if ("string" != typeof n$1) return this.error(`Expression name must be a string, but found ${typeof n$1} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
						const i$1 = this.registry[n$1];
						if (i$1) {
							let n$2 = i$1.parse(t$1, this);
							if (!n$2) return null;
							if (this.expectedType) {
								const t$2 = this.expectedType, i$2 = n$2.type;
								if ("string" !== t$2.kind && "number" !== t$2.kind && "boolean" !== t$2.kind && "object" !== t$2.kind && "array" !== t$2.kind || "value" !== i$2.kind) {
									if ("projectionDefinition" === t$2.kind && ["string", "array"].includes(i$2.kind) || [
										"color",
										"formatted",
										"resolvedImage"
									].includes(t$2.kind) && ["value", "string"].includes(i$2.kind) || ["padding", "numberArray"].includes(t$2.kind) && [
										"value",
										"number",
										"array"
									].includes(i$2.kind) || "colorArray" === t$2.kind && [
										"value",
										"string",
										"array"
									].includes(i$2.kind) || "variableAnchorOffsetCollection" === t$2.kind && ["value", "array"].includes(i$2.kind)) n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "coerce");
									else if (this.checkSubtype(t$2, i$2)) return null;
								} else n$2 = r$1(n$2, t$2, e$1.typeAnnotation || "assert");
							}
							if (!(n$2 instanceof Ne) && "resolvedImage" !== n$2.type.kind && this._isConstant(n$2)) {
								const t$2 = new He();
								try {
									n$2 = new Ne(n$2.type, n$2.evaluate(t$2));
								} catch (t$3) {
									return this.error(t$3.message), null;
								}
							}
							return n$2;
						}
						return this.error(`Unknown expression "${n$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					}
					return this.error(void 0 === t$1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t$1 ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof t$1} instead.`);
				}
				concat(t$1, e$1, r$1) {
					const n$1 = "number" == typeof t$1 ? this.path.concat(t$1) : this.path, i$1 = r$1 ? this.scope.concat(r$1) : this.scope;
					return new Ke(this.registry, this._isConstant, n$1, e$1 || null, i$1, this.errors);
				}
				error(t$1, ...e$1) {
					const r$1 = `${this.key}${e$1.map(((t$2) => `[${t$2}]`)).join("")}`;
					this.errors.push(new Tt(r$1, t$1));
				}
				checkSubtype(t$1, e$1) {
					const r$1 = Wt(t$1, e$1);
					return r$1 && this.error(r$1), r$1;
				}
			}
			class Je {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.bindings = [].concat(t$1), this.result = e$1;
				}
				evaluate(t$1) {
					return this.result.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const e$1 of this.bindings) t$1(e$1[1]);
					t$1(this.result);
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = [];
					for (let n$2 = 1; n$2 < t$1.length - 1; n$2 += 2) {
						const i$1 = t$1[n$2];
						if ("string" != typeof i$1) return e$1.error(`Expected string, but found ${typeof i$1} instead.`, n$2);
						if (/[^a-zA-Z0-9_]/.test(i$1)) return e$1.error("Variable names must contain only alphanumeric characters or '_'.", n$2);
						const s$1 = e$1.parse(t$1[n$2 + 1], n$2 + 1);
						if (!s$1) return null;
						r$1.push([i$1, s$1]);
					}
					const n$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, e$1.expectedType, r$1);
					return n$1 ? new Je(r$1, n$1) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
			}
			class We {
				constructor(t$1, e$1) {
					this.type = e$1.type, this.name = t$1, this.boundExpression = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length || "string" != typeof t$1[1]) return e$1.error("'var' expression requires exactly one string literal argument.");
					const r$1 = t$1[1];
					return e$1.scope.has(r$1) ? new We(r$1, e$1.scope.get(r$1)) : e$1.error(`Unknown variable "${r$1}". Make sure "${r$1}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(t$1) {
					return this.boundExpression.evaluate(t$1);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			class Qe {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.index = e$1, this.input = r$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ft), n$1 = e$1.parse(t$1[2], 2, Ht(e$1.expectedType || Ut));
					return r$1 && n$1 ? new Qe(n$1.type.itemType, r$1, n$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.index.evaluate(t$1), r$1 = this.input.evaluate(t$1);
					if (e$1 < 0) throw new Ve(`Array index out of bounds: ${e$1} < 0.`);
					if (e$1 >= r$1.length) throw new Ve(`Array index out of bounds: ${e$1} > ${r$1.length - 1}.`);
					if (e$1 !== Math.floor(e$1)) throw new Ve(`Array index must be an integer, but found ${e$1} instead.`);
					return r$1[e$1];
				}
				eachChild(t$1) {
					t$1(this.index), t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class tr {
				constructor(t$1, e$1) {
					this.type = $t, this.needle = t$1, this.haystack = e$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error(`Expected 2 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ut);
					return r$1 && n$1 ? Qt(r$1.type, [
						$t,
						Dt,
						Ft,
						Vt,
						Ut
					]) ? new tr(r$1, n$1) : e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Kt(r$1.type)} instead`) : null;
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!r$1) return !1;
					if (!te(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve(`Expected first argument to be of type boolean, string, number or null, but found ${Kt(Ue(e$1))} instead.`);
					if (!te(r$1, ["string", "array"])) throw new Ve(`Expected second argument to be of type array or string, but found ${Kt(Ue(r$1))} instead.`);
					return r$1.indexOf(e$1) >= 0;
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack);
				}
				outputDefined() {
					return !0;
				}
			}
			class er {
				constructor(t$1, e$1, r$1) {
					this.type = Ft, this.needle = t$1, this.haystack = e$1, this.fromIndex = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ut);
					if (!r$1 || !n$1) return null;
					if (!Qt(r$1.type, [
						$t,
						Dt,
						Ft,
						Vt,
						Ut
					])) return e$1.error(`Expected first argument to be of type boolean, string, number or null, but found ${Kt(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ft);
						return i$1 ? new er(r$1, n$1, i$1) : null;
					}
					return new er(r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.needle.evaluate(t$1), r$1 = this.haystack.evaluate(t$1);
					if (!te(e$1, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Ve(`Expected first argument to be of type boolean, string, number or null, but found ${Kt(Ue(e$1))} instead.`);
					let n$1;
					if (this.fromIndex && (n$1 = this.fromIndex.evaluate(t$1)), te(r$1, ["string"])) {
						const t$2 = r$1.indexOf(e$1, n$1);
						return -1 === t$2 ? -1 : [...r$1.slice(0, t$2)].length;
					}
					if (te(r$1, ["array"])) return r$1.indexOf(e$1, n$1);
					throw new Ve(`Expected second argument to be of type array or string, but found ${Kt(Ue(r$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.needle), t$1(this.haystack), this.fromIndex && t$1(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			class rr {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.inputType = t$1, this.type = e$1, this.input = r$1, this.cases = n$1, this.outputs = i$1, this.otherwise = s$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 5) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 1) return e$1.error("Expected an even number of arguments.");
					let r$1, n$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (n$1 = e$1.expectedType);
					const i$1 = {}, s$1 = [];
					for (let a$2 = 2; a$2 < t$1.length - 1; a$2 += 2) {
						let o$2 = t$1[a$2];
						const l$1 = t$1[a$2 + 1];
						Array.isArray(o$2) || (o$2 = [o$2]);
						const u$1 = e$1.concat(a$2);
						if (0 === o$2.length) return u$1.error("Expected at least one branch label.");
						for (const t$2 of o$2) {
							if ("number" != typeof t$2 && "string" != typeof t$2) return u$1.error("Branch labels must be numbers or strings.");
							if ("number" == typeof t$2 && Math.abs(t$2) > Number.MAX_SAFE_INTEGER) return u$1.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
							if ("number" == typeof t$2 && Math.floor(t$2) !== t$2) return u$1.error("Numeric branch labels must be integer values.");
							if (r$1) {
								if (u$1.checkSubtype(r$1, Ue(t$2))) return null;
							} else r$1 = Ue(t$2);
							if (void 0 !== i$1[String(t$2)]) return u$1.error("Branch labels must be unique.");
							i$1[String(t$2)] = s$1.length;
						}
						const c$1 = e$1.parse(l$1, a$2, n$1);
						if (!c$1) return null;
						n$1 = n$1 || c$1.type, s$1.push(c$1);
					}
					const a$1 = e$1.parse(t$1[1], 1, Ut);
					if (!a$1) return null;
					const o$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, n$1);
					return o$1 ? "value" !== a$1.type.kind && e$1.concat(1).checkSubtype(r$1, a$1.type) ? null : new rr(r$1, n$1, a$1, i$1, s$1, o$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					return (Ue(e$1) === this.inputType && this.outputs[this.cases[e$1]] || this.otherwise).evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input), this.outputs.forEach(t$1), t$1(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class nr {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.branches = e$1, this.otherwise = r$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 4) return e$1.error(`Expected at least 3 arguments, but found only ${t$1.length - 1}.`);
					if (t$1.length % 2 != 0) return e$1.error("Expected an odd number of arguments.");
					let r$1;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (r$1 = e$1.expectedType);
					const n$1 = [];
					for (let i$2 = 1; i$2 < t$1.length - 1; i$2 += 2) {
						const s$1 = e$1.parse(t$1[i$2], i$2, $t);
						if (!s$1) return null;
						const a$1 = e$1.parse(t$1[i$2 + 1], i$2 + 1, r$1);
						if (!a$1) return null;
						n$1.push([s$1, a$1]), r$1 = r$1 || a$1.type;
					}
					const i$1 = e$1.parse(t$1[t$1.length - 1], t$1.length - 1, r$1);
					if (!i$1) return null;
					if (!r$1) throw new Error("Can't infer output type");
					return new nr(r$1, n$1, i$1);
				}
				evaluate(t$1) {
					for (const [e$1, r$1] of this.branches) if (e$1.evaluate(t$1)) return r$1.evaluate(t$1);
					return this.otherwise.evaluate(t$1);
				}
				eachChild(t$1) {
					for (const [e$1, r$1] of this.branches) t$1(e$1), t$1(r$1);
					t$1(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([t$1, e$1]) => e$1.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class ir {
				constructor(t$1, e$1, r$1, n$1) {
					this.type = t$1, this.input = e$1, this.beginIndex = r$1, this.endIndex = n$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length <= 2 || t$1.length >= 5) return e$1.error(`Expected 2 or 3 arguments, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1, Ut), n$1 = e$1.parse(t$1[2], 2, Ft);
					if (!r$1 || !n$1) return null;
					if (!Qt(r$1.type, [
						Ht(Ut),
						Dt,
						Ut
					])) return e$1.error(`Expected first argument to be of type array or string, but found ${Kt(r$1.type)} instead`);
					if (4 === t$1.length) {
						const i$1 = e$1.parse(t$1[3], 3, Ft);
						return i$1 ? new ir(r$1.type, r$1, n$1, i$1) : null;
					}
					return new ir(r$1.type, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = this.beginIndex.evaluate(t$1);
					let n$1;
					if (this.endIndex && (n$1 = this.endIndex.evaluate(t$1)), te(e$1, ["string"])) return [...e$1].slice(r$1, n$1).join("");
					if (te(e$1, ["array"])) return e$1.slice(r$1, n$1);
					throw new Ve(`Expected first argument to be of type array or string, but found ${Kt(Ue(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input), t$1(this.beginIndex), this.endIndex && t$1(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			function sr(t$1, e$1) {
				const r$1 = t$1.length - 1;
				let n$1, i$1, s$1 = 0, a$1 = r$1, o$1 = 0;
				for (; s$1 <= a$1;) if (o$1 = Math.floor((s$1 + a$1) / 2), n$1 = t$1[o$1], i$1 = t$1[o$1 + 1], n$1 <= e$1) {
					if (o$1 === r$1 || e$1 < i$1) return o$1;
					s$1 = o$1 + 1;
				} else {
					if (!(n$1 > e$1)) throw new Ve("Input is not a number.");
					a$1 = o$1 - 1;
				}
				return 0;
			}
			class ar {
				constructor(t$1, e$1, r$1) {
					this.type = t$1, this.input = e$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of r$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static parse(t$1, e$1) {
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ft);
					if (!r$1) return null;
					const n$1 = [];
					let i$1 = null;
					e$1.expectedType && "value" !== e$1.expectedType.kind && (i$1 = e$1.expectedType);
					for (let r$2 = 1; r$2 < t$1.length; r$2 += 2) {
						const s$1 = 1 === r$2 ? -Infinity : t$1[r$2], a$1 = t$1[r$2 + 1], o$1 = r$2, l$1 = r$2 + 1;
						if ("number" != typeof s$1) return e$1.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", o$1);
						if (n$1.length && n$1[n$1.length - 1][0] >= s$1) return e$1.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", o$1);
						const u$1 = e$1.parse(a$1, l$1, i$1);
						if (!u$1) return null;
						i$1 = i$1 || u$1.type, n$1.push([s$1, u$1]);
					}
					return new ar(i$1, r$1, n$1);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					return n$1 >= e$1[i$1 - 1] ? r$1[i$1 - 1].evaluate(t$1) : r$1[sr(e$1, n$1)].evaluate(t$1);
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function or(t$1) {
				return t$1 && t$1.__esModule && Object.prototype.hasOwnProperty.call(t$1, "default") ? t$1.default : t$1;
			}
			var lr, ur, cr = function() {
				if (ur) return lr;
				function t$1(t$2, e$1, r$1, n$1) {
					this.cx = 3 * t$2, this.bx = 3 * (r$1 - t$2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e$1, this.by = 3 * (n$1 - e$1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t$2, this.p1y = e$1, this.p2x = r$1, this.p2y = n$1;
				}
				return ur = 1, lr = t$1, t$1.prototype = {
					sampleCurveX: function(t$2) {
						return ((this.ax * t$2 + this.bx) * t$2 + this.cx) * t$2;
					},
					sampleCurveY: function(t$2) {
						return ((this.ay * t$2 + this.by) * t$2 + this.cy) * t$2;
					},
					sampleCurveDerivativeX: function(t$2) {
						return (3 * this.ax * t$2 + 2 * this.bx) * t$2 + this.cx;
					},
					solveCurveX: function(t$2, e$1) {
						if (void 0 === e$1 && (e$1 = 1e-6), t$2 < 0) return 0;
						if (t$2 > 1) return 1;
						for (var r$1 = t$2, n$1 = 0; n$1 < 8; n$1++) {
							var i$1 = this.sampleCurveX(r$1) - t$2;
							if (Math.abs(i$1) < e$1) return r$1;
							var s$1 = this.sampleCurveDerivativeX(r$1);
							if (Math.abs(s$1) < 1e-6) break;
							r$1 -= i$1 / s$1;
						}
						var a$1 = 0, o$1 = 1;
						for (r$1 = t$2, n$1 = 0; n$1 < 20 && (i$1 = this.sampleCurveX(r$1), !(Math.abs(i$1 - t$2) < e$1)); n$1++) t$2 > i$1 ? a$1 = r$1 : o$1 = r$1, r$1 = .5 * (o$1 - a$1) + a$1;
						return r$1;
					},
					solve: function(t$2, e$1) {
						return this.sampleCurveY(this.solveCurveX(t$2, e$1));
					}
				}, lr;
			}(), hr = or(cr);
			class pr {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = t$1, this.operator = e$1, this.interpolation = r$1, this.input = n$1, this.labels = [], this.outputs = [];
					for (const [t$2, e$2] of i$1) this.labels.push(t$2), this.outputs.push(e$2);
				}
				static interpolationFactor(t$1, e$1, r$1, n$1) {
					let i$1 = 0;
					if ("exponential" === t$1.name) i$1 = fr(e$1, t$1.base, r$1, n$1);
					else if ("linear" === t$1.name) i$1 = fr(e$1, 1, r$1, n$1);
					else if ("cubic-bezier" === t$1.name) {
						const s$1 = t$1.controlPoints;
						i$1 = new hr(s$1[0], s$1[1], s$1[2], s$1[3]).solve(fr(e$1, 1, r$1, n$1));
					}
					return i$1;
				}
				static parse(t$1, e$1) {
					let [r$1, n$1, i$1, ...s$1] = t$1;
					if (!Array.isArray(n$1) || 0 === n$1.length) return e$1.error("Expected an interpolation type expression.", 1);
					if ("linear" === n$1[0]) n$1 = { name: "linear" };
					else if ("exponential" === n$1[0]) {
						const t$2 = n$1[1];
						if ("number" != typeof t$2) return e$1.error("Exponential interpolation requires a numeric base.", 1, 1);
						n$1 = {
							name: "exponential",
							base: t$2
						};
					} else {
						if ("cubic-bezier" !== n$1[0]) return e$1.error(`Unknown interpolation type ${String(n$1[0])}`, 1, 0);
						{
							const t$2 = n$1.slice(1);
							if (4 !== t$2.length || t$2.some(((t$3) => "number" != typeof t$3 || t$3 < 0 || t$3 > 1))) return e$1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							n$1 = {
								name: "cubic-bezier",
								controlPoints: t$2
							};
						}
					}
					if (t$1.length - 1 < 4) return e$1.error(`Expected at least 4 arguments, but found only ${t$1.length - 1}.`);
					if ((t$1.length - 1) % 2 != 0) return e$1.error("Expected an even number of arguments.");
					if (i$1 = e$1.parse(i$1, 2, Ft), !i$1) return null;
					const a$1 = [];
					let o$1 = null;
					"interpolate-hcl" !== r$1 && "interpolate-lab" !== r$1 || e$1.expectedType == Gt ? e$1.expectedType && "value" !== e$1.expectedType.kind && (o$1 = e$1.expectedType) : o$1 = Lt;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 2) {
						const r$2 = s$1[t$2], n$2 = s$1[t$2 + 1], i$2 = t$2 + 3, l$1 = t$2 + 4;
						if ("number" != typeof r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", i$2);
						if (a$1.length && a$1[a$1.length - 1][0] >= r$2) return e$1.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", i$2);
						const u$1 = e$1.parse(n$2, l$1, o$1);
						if (!u$1) return null;
						o$1 = o$1 || u$1.type, a$1.push([r$2, u$1]);
					}
					return ee(o$1, Ft) || ee(o$1, Ot) || ee(o$1, Lt) || ee(o$1, qt) || ee(o$1, Xt) || ee(o$1, Gt) || ee(o$1, Yt) || ee(o$1, Ht(Ft)) ? new pr(o$1, r$1, n$1, i$1, a$1) : e$1.error(`Type ${Kt(o$1)} is not interpolatable.`);
				}
				evaluate(t$1) {
					const e$1 = this.labels, r$1 = this.outputs;
					if (1 === e$1.length) return r$1[0].evaluate(t$1);
					const n$1 = this.input.evaluate(t$1);
					if (n$1 <= e$1[0]) return r$1[0].evaluate(t$1);
					const i$1 = e$1.length;
					if (n$1 >= e$1[i$1 - 1]) return r$1[i$1 - 1].evaluate(t$1);
					const s$1 = sr(e$1, n$1), a$1 = pr.interpolationFactor(this.interpolation, n$1, e$1[s$1], e$1[s$1 + 1]), o$1 = r$1[s$1].evaluate(t$1), l$1 = r$1[s$1 + 1].evaluate(t$1);
					switch (this.operator) {
						case "interpolate": switch (this.type.kind) {
							case "number": return Ae(o$1, l$1, a$1);
							case "color": return Me.interpolate(o$1, l$1, a$1);
							case "padding": return Ee.interpolate(o$1, l$1, a$1);
							case "colorArray": return Be.interpolate(o$1, l$1, a$1);
							case "numberArray": return Te.interpolate(o$1, l$1, a$1);
							case "variableAnchorOffsetCollection": return De.interpolate(o$1, l$1, a$1);
							case "array": return ke(o$1, l$1, a$1);
							case "projectionDefinition": return Le.interpolate(o$1, l$1, a$1);
						}
						case "interpolate-hcl": switch (this.type.kind) {
							case "color": return Me.interpolate(o$1, l$1, a$1, "hcl");
							case "colorArray": return Be.interpolate(o$1, l$1, a$1, "hcl");
						}
						case "interpolate-lab": switch (this.type.kind) {
							case "color": return Me.interpolate(o$1, l$1, a$1, "lab");
							case "colorArray": return Be.interpolate(o$1, l$1, a$1, "lab");
						}
					}
				}
				eachChild(t$1) {
					t$1(this.input);
					for (const e$1 of this.outputs) t$1(e$1);
				}
				outputDefined() {
					return this.outputs.every(((t$1) => t$1.outputDefined()));
				}
			}
			function fr(t$1, e$1, r$1, n$1) {
				const i$1 = n$1 - r$1, s$1 = t$1 - r$1;
				return 0 === i$1 ? 0 : 1 === e$1 ? s$1 / i$1 : (Math.pow(e$1, s$1) - 1) / (Math.pow(e$1, i$1) - 1);
			}
			const dr = {
				color: Me.interpolate,
				number: Ae,
				padding: Ee.interpolate,
				numberArray: Te.interpolate,
				colorArray: Be.interpolate,
				variableAnchorOffsetCollection: De.interpolate,
				array: ke
			};
			class yr {
				constructor(t$1, e$1) {
					this.type = t$1, this.args = e$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					let r$1 = null;
					const n$1 = e$1.expectedType;
					n$1 && "value" !== n$1.kind && (r$1 = n$1);
					const i$1 = [];
					for (const n$2 of t$1.slice(1)) {
						const t$2 = e$1.parse(n$2, 1 + i$1.length, r$1, void 0, { typeAnnotation: "omit" });
						if (!t$2) return null;
						r$1 = r$1 || t$2.type, i$1.push(t$2);
					}
					if (!r$1) throw new Error("No output type");
					const s$1 = n$1 && i$1.some(((t$2) => Wt(n$1, t$2.type)));
					return new yr(s$1 ? Ut : r$1, i$1);
				}
				evaluate(t$1) {
					let e$1, r$1 = null, n$1 = 0;
					for (const i$1 of this.args) if (n$1++, r$1 = i$1.evaluate(t$1), r$1 && r$1 instanceof $e && !r$1.available && (e$1 || (e$1 = r$1.name), r$1 = null, n$1 === this.args.length && (r$1 = e$1)), null !== r$1) break;
					return r$1;
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return this.args.every(((t$1) => t$1.outputDefined()));
				}
			}
			function mr(t$1, e$1) {
				return "==" === t$1 || "!=" === t$1 ? "boolean" === e$1.kind || "string" === e$1.kind || "number" === e$1.kind || "null" === e$1.kind || "value" === e$1.kind : "string" === e$1.kind || "number" === e$1.kind || "value" === e$1.kind;
			}
			function gr(t$1, e$1, r$1, n$1) {
				return 0 === n$1.compare(e$1, r$1);
			}
			function xr(t$1, e$1, r$1) {
				const n$1 = "==" !== t$1 && "!=" !== t$1;
				return class i$1 {
					constructor(t$2, e$2, r$2) {
						this.type = $t, this.lhs = t$2, this.rhs = e$2, this.collator = r$2, this.hasUntypedArgument = "value" === t$2.type.kind || "value" === e$2.type.kind;
					}
					static parse(t$2, e$2) {
						if (3 !== t$2.length && 4 !== t$2.length) return e$2.error("Expected two or three arguments.");
						const r$2 = t$2[0];
						let s$1 = e$2.parse(t$2[1], 1, Ut);
						if (!s$1) return null;
						if (!mr(r$2, s$1.type)) return e$2.concat(1).error(`"${r$2}" comparisons are not supported for type '${Kt(s$1.type)}'.`);
						let a$1 = e$2.parse(t$2[2], 2, Ut);
						if (!a$1) return null;
						if (!mr(r$2, a$1.type)) return e$2.concat(2).error(`"${r$2}" comparisons are not supported for type '${Kt(a$1.type)}'.`);
						if (s$1.type.kind !== a$1.type.kind && "value" !== s$1.type.kind && "value" !== a$1.type.kind) return e$2.error(`Cannot compare types '${Kt(s$1.type)}' and '${Kt(a$1.type)}'.`);
						n$1 && ("value" === s$1.type.kind && "value" !== a$1.type.kind ? s$1 = new Ge(a$1.type, [s$1]) : "value" !== s$1.type.kind && "value" === a$1.type.kind && (a$1 = new Ge(s$1.type, [a$1])));
						let o$1 = null;
						if (4 === t$2.length) {
							if ("string" !== s$1.type.kind && "string" !== a$1.type.kind && "value" !== s$1.type.kind && "value" !== a$1.type.kind) return e$2.error("Cannot use collator to compare non-string types.");
							if (o$1 = e$2.parse(t$2[3], 3, jt), !o$1) return null;
						}
						return new i$1(s$1, a$1, o$1);
					}
					evaluate(i$2) {
						const s$1 = this.lhs.evaluate(i$2), a$1 = this.rhs.evaluate(i$2);
						if (n$1 && this.hasUntypedArgument) {
							const e$2 = Ue(s$1), r$2 = Ue(a$1);
							if (e$2.kind !== r$2.kind || "string" !== e$2.kind && "number" !== e$2.kind) throw new Ve(`Expected arguments for "${t$1}" to be (string, string) or (number, number), but found (${e$2.kind}, ${r$2.kind}) instead.`);
						}
						if (this.collator && !n$1 && this.hasUntypedArgument) {
							const t$2 = Ue(s$1), r$2 = Ue(a$1);
							if ("string" !== t$2.kind || "string" !== r$2.kind) return e$1(i$2, s$1, a$1);
						}
						return this.collator ? r$1(i$2, s$1, a$1, this.collator.evaluate(i$2)) : e$1(i$2, s$1, a$1);
					}
					eachChild(t$2) {
						t$2(this.lhs), t$2(this.rhs), this.collator && t$2(this.collator);
					}
					outputDefined() {
						return !0;
					}
				};
			}
			const vr = xr("==", (function(t$1, e$1, r$1) {
				return e$1 === r$1;
			}), gr), br = xr("!=", (function(t$1, e$1, r$1) {
				return e$1 !== r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return !gr(0, e$1, r$1, n$1);
			})), wr = xr("<", (function(t$1, e$1, r$1) {
				return e$1 < r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) < 0;
			})), _r = xr(">", (function(t$1, e$1, r$1) {
				return e$1 > r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) > 0;
			})), Sr = xr("<=", (function(t$1, e$1, r$1) {
				return e$1 <= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) <= 0;
			})), Ar = xr(">=", (function(t$1, e$1, r$1) {
				return e$1 >= r$1;
			}), (function(t$1, e$1, r$1, n$1) {
				return n$1.compare(e$1, r$1) >= 0;
			}));
			class kr {
				constructor(t$1, e$1, r$1) {
					this.type = jt, this.locale = r$1, this.caseSensitive = t$1, this.diacriticSensitive = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected one argument.");
					const r$1 = t$1[1];
					if ("object" != typeof r$1 || Array.isArray(r$1)) return e$1.error("Collator options argument must be an object.");
					const n$1 = e$1.parse(void 0 !== r$1["case-sensitive"] && r$1["case-sensitive"], 1, $t);
					if (!n$1) return null;
					const i$1 = e$1.parse(void 0 !== r$1["diacritic-sensitive"] && r$1["diacritic-sensitive"], 1, $t);
					if (!i$1) return null;
					let s$1 = null;
					return r$1.locale && (s$1 = e$1.parse(r$1.locale, 1, Dt), !s$1) ? null : new kr(n$1, i$1, s$1);
				}
				evaluate(t$1) {
					return new Ie(this.caseSensitive.evaluate(t$1), this.diacriticSensitive.evaluate(t$1), this.locale ? this.locale.evaluate(t$1) : null);
				}
				eachChild(t$1) {
					t$1(this.caseSensitive), t$1(this.diacriticSensitive), this.locale && t$1(this.locale);
				}
				outputDefined() {
					return !1;
				}
			}
			class Mr {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = Dt, this.number = t$1, this.locale = e$1, this.currency = r$1, this.minFractionDigits = n$1, this.maxFractionDigits = i$1;
				}
				static parse(t$1, e$1) {
					if (3 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Ft);
					if (!r$1) return null;
					const n$1 = t$1[2];
					if ("object" != typeof n$1 || Array.isArray(n$1)) return e$1.error("NumberFormat options argument must be an object.");
					let i$1 = null;
					if (n$1.locale && (i$1 = e$1.parse(n$1.locale, 1, Dt), !i$1)) return null;
					let s$1 = null;
					if (n$1.currency && (s$1 = e$1.parse(n$1.currency, 1, Dt), !s$1)) return null;
					let a$1 = null;
					if (n$1["min-fraction-digits"] && (a$1 = e$1.parse(n$1["min-fraction-digits"], 1, Ft), !a$1)) return null;
					let o$1 = null;
					return n$1["max-fraction-digits"] && (o$1 = e$1.parse(n$1["max-fraction-digits"], 1, Ft), !o$1) ? null : new Mr(r$1, i$1, s$1, a$1, o$1);
				}
				evaluate(t$1) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t$1) : [], {
						style: this.currency ? "currency" : "decimal",
						currency: this.currency ? this.currency.evaluate(t$1) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t$1) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t$1) : void 0
					}).format(this.number.evaluate(t$1));
				}
				eachChild(t$1) {
					t$1(this.number), this.locale && t$1(this.locale), this.currency && t$1(this.currency), this.minFractionDigits && t$1(this.minFractionDigits), this.maxFractionDigits && t$1(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
			}
			class Ir {
				constructor(t$1) {
					this.type = Nt, this.sections = t$1;
				}
				static parse(t$1, e$1) {
					if (t$1.length < 2) return e$1.error("Expected at least one argument.");
					const r$1 = t$1[1];
					if (!Array.isArray(r$1) && "object" == typeof r$1) return e$1.error("First argument must be an image or text section.");
					const n$1 = [];
					let i$1 = !1;
					for (let r$2 = 1; r$2 <= t$1.length - 1; ++r$2) {
						const s$1 = t$1[r$2];
						if (i$1 && "object" == typeof s$1 && !Array.isArray(s$1)) {
							i$1 = !1;
							let t$2 = null;
							if (s$1["font-scale"] && (t$2 = e$1.parse(s$1["font-scale"], 1, Ft), !t$2)) return null;
							let r$3 = null;
							if (s$1["text-font"] && (r$3 = e$1.parse(s$1["text-font"], 1, Ht(Dt)), !r$3)) return null;
							let a$1 = null;
							if (s$1["text-color"] && (a$1 = e$1.parse(s$1["text-color"], 1, Lt), !a$1)) return null;
							let o$1 = null;
							if (s$1["vertical-align"]) {
								if ("string" == typeof s$1["vertical-align"] && !ze.includes(s$1["vertical-align"])) return e$1.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s$1["vertical-align"]}' instead.`);
								if (o$1 = e$1.parse(s$1["vertical-align"], 1, Dt), !o$1) return null;
							}
							const l$1 = n$1[n$1.length - 1];
							l$1.scale = t$2, l$1.font = r$3, l$1.textColor = a$1, l$1.verticalAlign = o$1;
						} else {
							const s$2 = e$1.parse(t$1[r$2], 1, Ut);
							if (!s$2) return null;
							const a$1 = s$2.type.kind;
							if ("string" !== a$1 && "value" !== a$1 && "null" !== a$1 && "resolvedImage" !== a$1) return e$1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							i$1 = !0, n$1.push({
								content: s$2,
								scale: null,
								font: null,
								textColor: null,
								verticalAlign: null
							});
						}
					}
					return new Ir(n$1);
				}
				evaluate(t$1) {
					return new Ce(this.sections.map(((e$1) => {
						const r$1 = e$1.content.evaluate(t$1);
						return Ue(r$1) === Zt ? new Pe("", r$1, null, null, null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null) : new Pe(je(r$1), null, e$1.scale ? e$1.scale.evaluate(t$1) : null, e$1.font ? e$1.font.evaluate(t$1).join(",") : null, e$1.textColor ? e$1.textColor.evaluate(t$1) : null, e$1.verticalAlign ? e$1.verticalAlign.evaluate(t$1) : null);
					})));
				}
				eachChild(t$1) {
					for (const e$1 of this.sections) t$1(e$1.content), e$1.scale && t$1(e$1.scale), e$1.font && t$1(e$1.font), e$1.textColor && t$1(e$1.textColor), e$1.verticalAlign && t$1(e$1.verticalAlign);
				}
				outputDefined() {
					return !1;
				}
			}
			class zr {
				constructor(t$1) {
					this.type = Zt, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error("Expected two arguments.");
					const r$1 = e$1.parse(t$1[1], 1, Dt);
					return r$1 ? new zr(r$1) : e$1.error("No image name provided.");
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1), r$1 = $e.fromString(e$1);
					return r$1 && t$1.availableImages && (r$1.available = t$1.availableImages.indexOf(e$1) > -1), r$1;
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class Pr {
				constructor(t$1) {
					this.type = Ft, this.input = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = e$1.parse(t$1[1], 1);
					return r$1 ? "array" !== r$1.type.kind && "string" !== r$1.type.kind && "value" !== r$1.type.kind ? e$1.error(`Expected argument of type string or array, but found ${Kt(r$1.type)} instead.`) : new Pr(r$1) : null;
				}
				evaluate(t$1) {
					const e$1 = this.input.evaluate(t$1);
					if ("string" == typeof e$1) return [...e$1].length;
					if (Array.isArray(e$1)) return e$1.length;
					throw new Ve(`Expected value to be of type string or array, but found ${Kt(Ue(e$1))} instead.`);
				}
				eachChild(t$1) {
					t$1(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			const Cr = 8192;
			function Er(t$1, e$1) {
				const r$1 = (180 + t$1[0]) / 360, n$1 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1[1] * Math.PI / 360))) / 360, i$1 = Math.pow(2, e$1.z);
				return [Math.round(r$1 * i$1 * Cr), Math.round(n$1 * i$1 * Cr)];
			}
			function Tr(t$1, e$1) {
				const r$1 = Math.pow(2, e$1.z);
				return [(i$1 = (t$1[0] / Cr + e$1.x) / r$1, 360 * i$1 - 180), (n$1 = (t$1[1] / Cr + e$1.y) / r$1, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n$1) * Math.PI / 180)) - 90)];
				var n$1, i$1;
			}
			function Br(t$1, e$1) {
				t$1[0] = Math.min(t$1[0], e$1[0]), t$1[1] = Math.min(t$1[1], e$1[1]), t$1[2] = Math.max(t$1[2], e$1[0]), t$1[3] = Math.max(t$1[3], e$1[1]);
			}
			function Vr(t$1, e$1) {
				return !(t$1[0] <= e$1[0] || t$1[2] >= e$1[2] || t$1[1] <= e$1[1] || t$1[3] >= e$1[3]);
			}
			function Fr(t$1, e$1, r$1) {
				const n$1 = t$1[0] - e$1[0], i$1 = t$1[1] - e$1[1], s$1 = t$1[0] - r$1[0], a$1 = t$1[1] - r$1[1];
				return n$1 * a$1 - s$1 * i$1 == 0 && n$1 * s$1 <= 0 && i$1 * a$1 <= 0;
			}
			function Dr(t$1, e$1, r$1, n$1) {
				return 0 != (i$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]])[0] * (s$1 = [e$1[0] - t$1[0], e$1[1] - t$1[1]])[1] - i$1[1] * s$1[0] && !(!jr(t$1, e$1, r$1, n$1) || !jr(r$1, n$1, t$1, e$1));
				var i$1, s$1;
			}
			function $r(t$1, e$1, r$1) {
				for (const n$1 of r$1) for (let r$2 = 0; r$2 < n$1.length - 1; ++r$2) if (Dr(t$1, e$1, n$1[r$2], n$1[r$2 + 1])) return !0;
				return !1;
			}
			function Lr(t$1, e$1, r$1 = !1) {
				let n$1 = !1;
				for (const o$1 of e$1) for (let e$2 = 0; e$2 < o$1.length - 1; e$2++) {
					if (Fr(t$1, o$1[e$2], o$1[e$2 + 1])) return r$1;
					(s$1 = o$1[e$2])[1] > (i$1 = t$1)[1] != (a$1 = o$1[e$2 + 1])[1] > i$1[1] && i$1[0] < (a$1[0] - s$1[0]) * (i$1[1] - s$1[1]) / (a$1[1] - s$1[1]) + s$1[0] && (n$1 = !n$1);
				}
				var i$1, s$1, a$1;
				return n$1;
			}
			function Or(t$1, e$1) {
				for (const r$1 of e$1) if (Lr(t$1, r$1)) return !0;
				return !1;
			}
			function Rr(t$1, e$1) {
				for (const r$1 of t$1) if (!Lr(r$1, e$1)) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; ++r$1) if ($r(t$1[r$1], t$1[r$1 + 1], e$1)) return !1;
				return !0;
			}
			function Ur(t$1, e$1) {
				for (const r$1 of e$1) if (Rr(t$1, r$1)) return !0;
				return !1;
			}
			function jr(t$1, e$1, r$1, n$1) {
				const i$1 = n$1[0] - r$1[0], s$1 = n$1[1] - r$1[1], a$1 = (t$1[0] - r$1[0]) * s$1 - i$1 * (t$1[1] - r$1[1]), o$1 = (e$1[0] - r$1[0]) * s$1 - i$1 * (e$1[1] - r$1[1]);
				return a$1 > 0 && o$1 < 0 || a$1 < 0 && o$1 > 0;
			}
			function Nr(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = [];
					for (let n$2 = 0; n$2 < t$1[i$1].length; n$2++) {
						const a$1 = Er(t$1[i$1][n$2], r$1);
						Br(e$1, a$1), s$1.push(a$1);
					}
					n$1.push(s$1);
				}
				return n$1;
			}
			function qr(t$1, e$1, r$1) {
				const n$1 = [];
				for (let i$1 = 0; i$1 < t$1.length; i$1++) {
					const s$1 = Nr(t$1[i$1], e$1, r$1);
					n$1.push(s$1);
				}
				return n$1;
			}
			function Gr(t$1, e$1, r$1, n$1) {
				if (t$1[0] < r$1[0] || t$1[0] > r$1[2]) {
					const e$2 = .5 * n$1;
					let i$1 = t$1[0] - r$1[0] > e$2 ? -n$1 : r$1[0] - t$1[0] > e$2 ? n$1 : 0;
					0 === i$1 && (i$1 = t$1[0] - r$1[2] > e$2 ? -n$1 : r$1[2] - t$1[0] > e$2 ? n$1 : 0), t$1[0] += i$1;
				}
				Br(e$1, t$1);
			}
			function Xr(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Cr, s$1 = [n$1.x * Cr, n$1.y * Cr], a$1 = [];
				for (const n$2 of t$1) for (const t$2 of n$2) {
					const n$3 = [t$2.x + s$1[0], t$2.y + s$1[1]];
					Gr(n$3, e$1, r$1, i$1), a$1.push(n$3);
				}
				return a$1;
			}
			function Zr(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(2, n$1.z) * Cr, s$1 = [n$1.x * Cr, n$1.y * Cr], a$1 = [];
				for (const r$2 of t$1) {
					const t$2 = [];
					for (const n$2 of r$2) {
						const r$3 = [n$2.x + s$1[0], n$2.y + s$1[1]];
						Br(e$1, r$3), t$2.push(r$3);
					}
					a$1.push(t$2);
				}
				if (e$1[2] - e$1[0] <= i$1 / 2) {
					(o$1 = e$1)[0] = o$1[1] = Infinity, o$1[2] = o$1[3] = -Infinity;
					for (const t$2 of a$1) for (const n$2 of t$2) Gr(n$2, e$1, r$1, i$1);
				}
				var o$1;
				return a$1;
			}
			class Yr {
				constructor(t$1, e$1) {
					this.type = $t, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'within' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (Re(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) {
							const t$2 = [];
							for (const r$1 of e$2.features) {
								const { type: e$3, coordinates: n$1 } = r$1.geometry;
								"Polygon" === e$3 && t$2.push(n$1), "MultiPolygon" === e$3 && t$2.push(...n$1);
							}
							if (t$2.length) return new Yr(e$2, {
								type: "MultiPolygon",
								coordinates: t$2
							});
						} else if ("Feature" === e$2.type) {
							const t$2 = e$2.geometry.type;
							if ("Polygon" === t$2 || "MultiPolygon" === t$2) return new Yr(e$2, e$2.geometry);
						} else if ("Polygon" === e$2.type || "MultiPolygon" === e$2.type) return new Yr(e$2, e$2);
					}
					return e$1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = Nr(e$1.coordinates, n$1, i$1), a$1 = Xr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a$1) if (!Lr(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = qr(e$1.coordinates, n$1, i$1), a$1 = Xr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a$1) if (!Or(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], n$1 = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i$1 = t$2.canonicalID();
							if ("Polygon" === e$1.type) {
								const s$1 = Nr(e$1.coordinates, n$1, i$1), a$1 = Zr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a$1) if (!Rr(t$3, s$1)) return !1;
							}
							if ("MultiPolygon" === e$1.type) {
								const s$1 = qr(e$1.coordinates, n$1, i$1), a$1 = Zr(t$2.geometry(), r$1, n$1, i$1);
								if (!Vr(r$1, n$1)) return !1;
								for (const t$3 of a$1) if (!Ur(t$3, s$1)) return !1;
							}
							return !0;
						}(t$1, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let Hr = class {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			};
			function Kr(t$1, e$1, r$1 = 0, n$1 = t$1.length - 1, i$1 = Wr) {
				for (; n$1 > r$1;) {
					if (n$1 - r$1 > 600) {
						const s$2 = n$1 - r$1 + 1, a$2 = e$1 - r$1 + 1, o$2 = Math.log(s$2), l$1 = .5 * Math.exp(2 * o$2 / 3), u$1 = .5 * Math.sqrt(o$2 * l$1 * (s$2 - l$1) / s$2) * (a$2 - s$2 / 2 < 0 ? -1 : 1);
						Kr(t$1, e$1, Math.max(r$1, Math.floor(e$1 - a$2 * l$1 / s$2 + u$1)), Math.min(n$1, Math.floor(e$1 + (s$2 - a$2) * l$1 / s$2 + u$1)), i$1);
					}
					const s$1 = t$1[e$1];
					let a$1 = r$1, o$1 = n$1;
					for (Jr(t$1, r$1, e$1), i$1(t$1[n$1], s$1) > 0 && Jr(t$1, r$1, n$1); a$1 < o$1;) {
						for (Jr(t$1, a$1, o$1), a$1++, o$1--; i$1(t$1[a$1], s$1) < 0;) a$1++;
						for (; i$1(t$1[o$1], s$1) > 0;) o$1--;
					}
					0 === i$1(t$1[r$1], s$1) ? Jr(t$1, r$1, o$1) : (o$1++, Jr(t$1, o$1, n$1)), o$1 <= e$1 && (r$1 = o$1 + 1), e$1 <= o$1 && (n$1 = o$1 - 1);
				}
			}
			function Jr(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Wr(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function Qr(t$1, e$1) {
				if (t$1.length <= 1) return [t$1];
				const r$1 = [];
				let n$1, i$1;
				for (const e$2 of t$1) {
					const t$2 = en(e$2);
					0 !== t$2 && (e$2.area = Math.abs(t$2), void 0 === i$1 && (i$1 = t$2 < 0), i$1 === t$2 < 0 ? (n$1 && r$1.push(n$1), n$1 = [e$2]) : n$1.push(e$2));
				}
				if (n$1 && r$1.push(n$1), e$1 > 1) for (let t$2 = 0; t$2 < r$1.length; t$2++) r$1[t$2].length <= e$1 || (Kr(r$1[t$2], e$1, 1, r$1[t$2].length - 1, tn), r$1[t$2] = r$1[t$2].slice(0, e$1));
				return r$1;
			}
			function tn(t$1, e$1) {
				return e$1.area - t$1.area;
			}
			function en(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a$1 = s$1 - 1; i$1 < s$1; a$1 = i$1++) r$1 = t$1[i$1], n$1 = t$1[a$1], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			const rn = 1 / 298.257223563, nn = rn * (2 - rn), sn = Math.PI / 180;
			class an {
				constructor(t$1) {
					const e$1 = 6378.137 * sn * 1e3, r$1 = Math.cos(t$1 * sn), n$1 = 1 / (1 - nn * (1 - r$1 * r$1)), i$1 = Math.sqrt(n$1);
					this.kx = e$1 * i$1 * r$1, this.ky = e$1 * i$1 * n$1 * (1 - nn);
				}
				distance(t$1, e$1) {
					const r$1 = this.wrap(t$1[0] - e$1[0]) * this.kx, n$1 = (t$1[1] - e$1[1]) * this.ky;
					return Math.sqrt(r$1 * r$1 + n$1 * n$1);
				}
				pointOnLine(t$1, e$1) {
					let r$1, n$1, i$1, s$1, a$1 = Infinity;
					for (let o$1 = 0; o$1 < t$1.length - 1; o$1++) {
						let l$1 = t$1[o$1][0], u$1 = t$1[o$1][1], c$1 = this.wrap(t$1[o$1 + 1][0] - l$1) * this.kx, h$1 = (t$1[o$1 + 1][1] - u$1) * this.ky, p$1 = 0;
						0 === c$1 && 0 === h$1 || (p$1 = (this.wrap(e$1[0] - l$1) * this.kx * c$1 + (e$1[1] - u$1) * this.ky * h$1) / (c$1 * c$1 + h$1 * h$1), p$1 > 1 ? (l$1 = t$1[o$1 + 1][0], u$1 = t$1[o$1 + 1][1]) : p$1 > 0 && (l$1 += c$1 / this.kx * p$1, u$1 += h$1 / this.ky * p$1)), c$1 = this.wrap(e$1[0] - l$1) * this.kx, h$1 = (e$1[1] - u$1) * this.ky;
						const f$1 = c$1 * c$1 + h$1 * h$1;
						f$1 < a$1 && (a$1 = f$1, r$1 = l$1, n$1 = u$1, i$1 = o$1, s$1 = p$1);
					}
					return {
						point: [r$1, n$1],
						index: i$1,
						t: Math.max(0, Math.min(1, s$1))
					};
				}
				wrap(t$1) {
					for (; t$1 < -180;) t$1 += 360;
					for (; t$1 > 180;) t$1 -= 360;
					return t$1;
				}
			}
			function on(t$1, e$1) {
				return e$1[0] - t$1[0];
			}
			function ln(t$1) {
				return t$1[1] - t$1[0] + 1;
			}
			function un(t$1, e$1) {
				return t$1[1] >= t$1[0] && t$1[1] < e$1;
			}
			function cn(t$1, e$1) {
				if (t$1[0] > t$1[1]) return [null, null];
				const r$1 = ln(t$1);
				if (e$1) {
					if (2 === r$1) return [t$1, null];
					const e$2 = Math.floor(r$1 / 2);
					return [[t$1[0], t$1[0] + e$2], [t$1[0] + e$2, t$1[1]]];
				}
				if (1 === r$1) return [t$1, null];
				const n$1 = Math.floor(r$1 / 2) - 1;
				return [[t$1[0], t$1[0] + n$1], [t$1[0] + n$1 + 1, t$1[1]]];
			}
			function hn(t$1, e$1) {
				if (!un(e$1, t$1.length)) return [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				const r$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let n$1 = e$1[0]; n$1 <= e$1[1]; ++n$1) Br(r$1, t$1[n$1]);
				return r$1;
			}
			function pn(t$1) {
				const e$1 = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (const r$1 of t$1) for (const t$2 of r$1) Br(e$1, t$2);
				return e$1;
			}
			function fn(t$1) {
				return t$1[0] !== -Infinity && t$1[1] !== -Infinity && t$1[2] !== Infinity && t$1[3] !== Infinity;
			}
			function dn(t$1, e$1, r$1) {
				if (!fn(t$1) || !fn(e$1)) return NaN;
				let n$1 = 0, i$1 = 0;
				return t$1[2] < e$1[0] && (n$1 = e$1[0] - t$1[2]), t$1[0] > e$1[2] && (n$1 = t$1[0] - e$1[2]), t$1[1] > e$1[3] && (i$1 = t$1[1] - e$1[3]), t$1[3] < e$1[1] && (i$1 = e$1[1] - t$1[3]), r$1.distance([0, 0], [n$1, i$1]);
			}
			function yn(t$1, e$1, r$1) {
				const n$1 = r$1.pointOnLine(e$1, t$1);
				return r$1.distance(t$1, n$1.point);
			}
			function mn(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = Math.min(yn(t$1, [r$1, n$1], i$1), yn(e$1, [r$1, n$1], i$1)), a$1 = Math.min(yn(r$1, [t$1, e$1], i$1), yn(n$1, [t$1, e$1], i$1));
				return Math.min(s$1, a$1);
			}
			function gn(t$1, e$1, r$1, n$1, i$1) {
				if (!un(e$1, t$1.length) || !un(n$1, r$1.length)) return Infinity;
				let s$1 = Infinity;
				for (let a$1 = e$1[0]; a$1 < e$1[1]; ++a$1) {
					const e$2 = t$1[a$1], o$1 = t$1[a$1 + 1];
					for (let t$2 = n$1[0]; t$2 < n$1[1]; ++t$2) {
						const n$2 = r$1[t$2], a$2 = r$1[t$2 + 1];
						if (Dr(e$2, o$1, n$2, a$2)) return 0;
						s$1 = Math.min(s$1, mn(e$2, o$1, n$2, a$2, i$1));
					}
				}
				return s$1;
			}
			function xn(t$1, e$1, r$1, n$1, i$1) {
				if (!un(e$1, t$1.length) || !un(n$1, r$1.length)) return NaN;
				let s$1 = Infinity;
				for (let a$1 = e$1[0]; a$1 <= e$1[1]; ++a$1) for (let e$2 = n$1[0]; e$2 <= n$1[1]; ++e$2) if (s$1 = Math.min(s$1, i$1.distance(t$1[a$1], r$1[e$2])), 0 === s$1) return s$1;
				return s$1;
			}
			function vn(t$1, e$1, r$1) {
				if (Lr(t$1, e$1, !0)) return 0;
				let n$1 = Infinity;
				for (const i$1 of e$1) {
					const e$2 = i$1[0], s$1 = i$1[i$1.length - 1];
					if (e$2 !== s$1 && (n$1 = Math.min(n$1, yn(t$1, [s$1, e$2], r$1)), 0 === n$1)) return n$1;
					const a$1 = r$1.pointOnLine(i$1, t$1);
					if (n$1 = Math.min(n$1, r$1.distance(t$1, a$1.point)), 0 === n$1) return n$1;
				}
				return n$1;
			}
			function bn(t$1, e$1, r$1, n$1) {
				if (!un(e$1, t$1.length)) return NaN;
				for (let n$2 = e$1[0]; n$2 <= e$1[1]; ++n$2) if (Lr(t$1[n$2], r$1, !0)) return 0;
				let i$1 = Infinity;
				for (let s$1 = e$1[0]; s$1 < e$1[1]; ++s$1) {
					const e$2 = t$1[s$1], a$1 = t$1[s$1 + 1];
					for (const t$2 of r$1) for (let r$2 = 0, s$2 = t$2.length, o$1 = s$2 - 1; r$2 < s$2; o$1 = r$2++) {
						const s$3 = t$2[o$1], l$1 = t$2[r$2];
						if (Dr(e$2, a$1, s$3, l$1)) return 0;
						i$1 = Math.min(i$1, mn(e$2, a$1, s$3, l$1, n$1));
					}
				}
				return i$1;
			}
			function wn(t$1, e$1) {
				for (const r$1 of t$1) for (const t$2 of r$1) if (Lr(t$2, e$1, !0)) return !0;
				return !1;
			}
			function _n(t$1, e$1, r$1, n$1 = Infinity) {
				const i$1 = pn(t$1), s$1 = pn(e$1);
				if (n$1 !== Infinity && dn(i$1, s$1, r$1) >= n$1) return n$1;
				if (Vr(i$1, s$1)) {
					if (wn(t$1, e$1)) return 0;
				} else if (wn(e$1, t$1)) return 0;
				let a$1 = Infinity;
				for (const n$2 of t$1) for (let t$2 = 0, i$2 = n$2.length, s$2 = i$2 - 1; t$2 < i$2; s$2 = t$2++) {
					const i$3 = n$2[s$2], o$1 = n$2[t$2];
					for (const t$3 of e$1) for (let e$2 = 0, n$3 = t$3.length, s$3 = n$3 - 1; e$2 < n$3; s$3 = e$2++) {
						const n$4 = t$3[s$3], l$1 = t$3[e$2];
						if (Dr(i$3, o$1, n$4, l$1)) return 0;
						a$1 = Math.min(a$1, mn(i$3, o$1, n$4, l$1, r$1));
					}
				}
				return a$1;
			}
			function Sn(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!s$1) return;
				const a$1 = dn(hn(n$1, s$1), i$1, r$1);
				a$1 < e$1 && t$1.push([
					a$1,
					s$1,
					[0, 0]
				]);
			}
			function An(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
				if (!s$1 || !a$1) return;
				const o$1 = dn(hn(n$1, s$1), hn(i$1, a$1), r$1);
				o$1 < e$1 && t$1.push([
					o$1,
					s$1,
					a$1
				]);
			}
			function kn(t$1, e$1, r$1, n$1, i$1 = Infinity) {
				let s$1 = Math.min(n$1.distance(t$1[0], r$1[0][0]), i$1);
				if (0 === s$1) return s$1;
				const a$1 = new Hr([[
					0,
					[0, t$1.length - 1],
					[0, 0]
				]], on), o$1 = pn(r$1);
				for (; a$1.length > 0;) {
					const i$2 = a$1.pop();
					if (i$2[0] >= s$1) continue;
					const l$1 = i$2[1], u$1 = e$1 ? 50 : 100;
					if (ln(l$1) <= u$1) {
						if (!un(l$1, t$1.length)) return NaN;
						if (e$1) {
							const e$2 = bn(t$1, l$1, r$1, n$1);
							if (isNaN(e$2) || 0 === e$2) return e$2;
							s$1 = Math.min(s$1, e$2);
						} else for (let e$2 = l$1[0]; e$2 <= l$1[1]; ++e$2) {
							const i$3 = vn(t$1[e$2], r$1, n$1);
							if (s$1 = Math.min(s$1, i$3), 0 === s$1) return 0;
						}
					} else {
						const r$2 = cn(l$1, e$1);
						Sn(a$1, s$1, n$1, t$1, o$1, r$2[0]), Sn(a$1, s$1, n$1, t$1, o$1, r$2[1]);
					}
				}
				return s$1;
			}
			function Mn(t$1, e$1, r$1, n$1, i$1, s$1 = Infinity) {
				let a$1 = Math.min(s$1, i$1.distance(t$1[0], r$1[0]));
				if (0 === a$1) return a$1;
				const o$1 = new Hr([[
					0,
					[0, t$1.length - 1],
					[0, r$1.length - 1]
				]], on);
				for (; o$1.length > 0;) {
					const s$2 = o$1.pop();
					if (s$2[0] >= a$1) continue;
					const l$1 = s$2[1], u$1 = s$2[2], c$1 = e$1 ? 50 : 100, h$1 = n$1 ? 50 : 100;
					if (ln(l$1) <= c$1 && ln(u$1) <= h$1) {
						if (!un(l$1, t$1.length) && un(u$1, r$1.length)) return NaN;
						let s$3;
						if (e$1 && n$1) s$3 = gn(t$1, l$1, r$1, u$1, i$1), a$1 = Math.min(a$1, s$3);
						else if (e$1 && !n$1) {
							const e$2 = t$1.slice(l$1[0], l$1[1] + 1);
							for (let t$2 = u$1[0]; t$2 <= u$1[1]; ++t$2) if (s$3 = yn(r$1[t$2], e$2, i$1), a$1 = Math.min(a$1, s$3), 0 === a$1) return a$1;
						} else if (!e$1 && n$1) {
							const e$2 = r$1.slice(u$1[0], u$1[1] + 1);
							for (let r$2 = l$1[0]; r$2 <= l$1[1]; ++r$2) if (s$3 = yn(t$1[r$2], e$2, i$1), a$1 = Math.min(a$1, s$3), 0 === a$1) return a$1;
						} else s$3 = xn(t$1, l$1, r$1, u$1, i$1), a$1 = Math.min(a$1, s$3);
					} else {
						const s$3 = cn(l$1, e$1), c$2 = cn(u$1, n$1);
						An(o$1, a$1, i$1, t$1, r$1, s$3[0], c$2[0]), An(o$1, a$1, i$1, t$1, r$1, s$3[0], c$2[1]), An(o$1, a$1, i$1, t$1, r$1, s$3[1], c$2[0]), An(o$1, a$1, i$1, t$1, r$1, s$3[1], c$2[1]);
					}
				}
				return a$1;
			}
			function In(t$1) {
				return "MultiPolygon" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Polygon",
					coordinates: t$2
				}))) : "MultiLineString" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "LineString",
					coordinates: t$2
				}))) : "MultiPoint" === t$1.type ? t$1.coordinates.map(((t$2) => ({
					type: "Point",
					coordinates: t$2
				}))) : [t$1];
			}
			class zn {
				constructor(t$1, e$1) {
					this.type = Ft, this.geojson = t$1, this.geometries = e$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`'distance' expression requires exactly one argument, but found ${t$1.length - 1} instead.`);
					if (Re(t$1[1])) {
						const e$2 = t$1[1];
						if ("FeatureCollection" === e$2.type) return new zn(e$2, e$2.features.map(((t$2) => In(t$2.geometry))).flat());
						if ("Feature" === e$2.type) return new zn(e$2, In(e$2.geometry));
						if ("type" in e$2 && "coordinates" in e$2) return new zn(e$2, In(e$2));
					}
					return e$1.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(t$1) {
					if (null != t$1.geometry() && null != t$1.canonicalID()) {
						if ("Point" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Tr([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Mn(n$1, !1, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Mn(n$1, !1, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, kn(n$1, !1, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("LineString" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry(), n$1 = r$1.flat().map(((e$2) => Tr([e$2.x, e$2.y], t$2.canonical)));
							if (0 === r$1.length) return NaN;
							const i$1 = new an(n$1[0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, Mn(n$1, !0, [t$3.coordinates], !1, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, Mn(n$1, !0, t$3.coordinates, !0, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, kn(n$1, !0, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
						if ("Polygon" === t$1.geometryType()) return function(t$2, e$1) {
							const r$1 = t$2.geometry();
							if (0 === r$1.length || 0 === r$1[0].length) return NaN;
							const n$1 = Qr(r$1, 0).map(((e$2) => e$2.map(((e$3) => e$3.map(((e$4) => Tr([e$4.x, e$4.y], t$2.canonical))))))), i$1 = new an(n$1[0][0][0][1]);
							let s$1 = Infinity;
							for (const t$3 of e$1) for (const e$2 of n$1) {
								switch (t$3.type) {
									case "Point":
										s$1 = Math.min(s$1, kn([t$3.coordinates], !1, e$2, i$1, s$1));
										break;
									case "LineString":
										s$1 = Math.min(s$1, kn(t$3.coordinates, !0, e$2, i$1, s$1));
										break;
									case "Polygon": s$1 = Math.min(s$1, _n(e$2, t$3.coordinates, i$1, s$1));
								}
								if (0 === s$1) return s$1;
							}
							return s$1;
						}(t$1, this.geometries);
					}
					return NaN;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			class Pn {
				constructor(t$1) {
					this.type = Ut, this.key = t$1;
				}
				static parse(t$1, e$1) {
					if (2 !== t$1.length) return e$1.error(`Expected 1 argument, but found ${t$1.length - 1} instead.`);
					const r$1 = t$1[1];
					return null == r$1 ? e$1.error("Global state property must be defined.") : "string" != typeof r$1 ? e$1.error(`Global state property must be string, but found ${typeof t$1[1]} instead.`) : new Pn(r$1);
				}
				evaluate(t$1) {
					var e$1;
					const r$1 = null === (e$1 = t$1.globals) || void 0 === e$1 ? void 0 : e$1.globalState;
					return r$1 && 0 !== Object.keys(r$1).length ? xe(r$1, this.key) : null;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			const Cn = {
				"==": vr,
				"!=": br,
				">": _r,
				"<": wr,
				">=": Ar,
				"<=": Sr,
				array: Ge,
				at: Qe,
				boolean: Ge,
				case: nr,
				coalesce: yr,
				collator: kr,
				format: Ir,
				image: zr,
				in: tr,
				"index-of": er,
				interpolate: pr,
				"interpolate-hcl": pr,
				"interpolate-lab": pr,
				length: Pr,
				let: Je,
				literal: Ne,
				match: rr,
				number: Ge,
				"number-format": Mr,
				object: Ge,
				slice: ir,
				step: ar,
				string: Ge,
				"to-boolean": Ze,
				"to-color": Ze,
				"to-number": Ze,
				"to-string": Ze,
				var: We,
				within: Yr,
				distance: zn,
				"global-state": Pn
			};
			class En {
				constructor(t$1, e$1, r$1, n$1) {
					this.name = t$1, this.type = e$1, this._evaluate = r$1, this.args = n$1;
				}
				evaluate(t$1) {
					return this._evaluate(t$1, this.args);
				}
				eachChild(t$1) {
					this.args.forEach(t$1);
				}
				outputDefined() {
					return !1;
				}
				static parse(t$1, e$1) {
					const r$1 = t$1[0], n$1 = En.definitions[r$1];
					if (!n$1) return e$1.error(`Unknown expression "${r$1}". If you wanted a literal array, use ["literal", [...]].`, 0);
					const i$1 = Array.isArray(n$1) ? n$1[0] : n$1.type, s$1 = Array.isArray(n$1) ? [[n$1[1], n$1[2]]] : n$1.overloads, a$1 = s$1.filter((([e$2]) => !Array.isArray(e$2) || e$2.length === t$1.length - 1));
					let o$1 = null;
					for (const [n$2, s$2] of a$1) {
						o$1 = new Ke(e$1.registry, Dn, e$1.path, null, e$1.scope);
						const a$2 = [];
						let l$1 = !1;
						for (let e$2 = 1; e$2 < t$1.length; e$2++) {
							const r$2 = t$1[e$2], i$2 = Array.isArray(n$2) ? n$2[e$2 - 1] : n$2.type, s$3 = o$1.parse(r$2, 1 + a$2.length, i$2);
							if (!s$3) {
								l$1 = !0;
								break;
							}
							a$2.push(s$3);
						}
						if (!l$1) if (Array.isArray(n$2) && n$2.length !== a$2.length) o$1.error(`Expected ${n$2.length} arguments, but found ${a$2.length} instead.`);
						else {
							for (let t$2 = 0; t$2 < a$2.length; t$2++) {
								const e$2 = Array.isArray(n$2) ? n$2[t$2] : n$2.type, r$2 = a$2[t$2];
								o$1.concat(t$2 + 1).checkSubtype(e$2, r$2.type);
							}
							if (0 === o$1.errors.length) return new En(r$1, i$1, s$2, a$2);
						}
					}
					if (1 === a$1.length) e$1.errors.push(...o$1.errors);
					else {
						const r$2 = (a$1.length ? a$1 : s$1).map((([t$2]) => {
							return e$2 = t$2, Array.isArray(e$2) ? `(${e$2.map(Kt).join(", ")})` : `(${Kt(e$2.type)}...)`;
							var e$2;
						})).join(" | "), n$2 = [];
						for (let r$3 = 1; r$3 < t$1.length; r$3++) {
							const i$2 = e$1.parse(t$1[r$3], 1 + n$2.length);
							if (!i$2) return null;
							n$2.push(Kt(i$2.type));
						}
						e$1.error(`Expected arguments of type ${r$2}, but found (${n$2.join(", ")}) instead.`);
					}
					return null;
				}
				static register(t$1, e$1) {
					En.definitions = e$1;
					for (const r$1 in e$1) t$1[r$1] = En;
				}
			}
			function Tn(t$1, [e$1, r$1, n$1, i$1]) {
				e$1 = e$1.evaluate(t$1), r$1 = r$1.evaluate(t$1), n$1 = n$1.evaluate(t$1);
				const s$1 = i$1 ? i$1.evaluate(t$1) : 1, a$1 = Oe(e$1, r$1, n$1, s$1);
				if (a$1) throw new Ve(a$1);
				return new Me(e$1 / 255, r$1 / 255, n$1 / 255, s$1, !1);
			}
			function Bn(t$1, e$1) {
				return t$1 in e$1;
			}
			function Vn(t$1, e$1) {
				const r$1 = e$1[t$1];
				return void 0 === r$1 ? null : r$1;
			}
			function Fn(t$1) {
				return { type: t$1 };
			}
			function Dn(t$1) {
				if (t$1 instanceof We) return Dn(t$1.boundExpression);
				if (t$1 instanceof En && "error" === t$1.name) return !1;
				if (t$1 instanceof kr) return !1;
				if (t$1 instanceof Yr) return !1;
				if (t$1 instanceof zn) return !1;
				if (t$1 instanceof Pn) return !1;
				const e$1 = t$1 instanceof Ze || t$1 instanceof Ge;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 = e$1 ? r$1 && Dn(t$2) : r$1 && t$2 instanceof Ne;
				})), !!r$1 && $n(t$1) && On(t$1, [
					"zoom",
					"heatmap-density",
					"elevation",
					"line-progress",
					"accumulated",
					"is-supported-script"
				]);
			}
			function $n(t$1) {
				if (t$1 instanceof En) {
					if ("get" === t$1.name && 1 === t$1.args.length) return !1;
					if ("feature-state" === t$1.name) return !1;
					if ("has" === t$1.name && 1 === t$1.args.length) return !1;
					if ("properties" === t$1.name || "geometry-type" === t$1.name || "id" === t$1.name) return !1;
					if (/^filter-/.test(t$1.name)) return !1;
				}
				if (t$1 instanceof Yr) return !1;
				if (t$1 instanceof zn) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !$n(t$2) && (e$1 = !1);
				})), e$1;
			}
			function Ln(t$1) {
				if (t$1 instanceof En && "feature-state" === t$1.name) return !1;
				let e$1 = !0;
				return t$1.eachChild(((t$2) => {
					e$1 && !Ln(t$2) && (e$1 = !1);
				})), e$1;
			}
			function On(t$1, e$1) {
				if (t$1 instanceof En && e$1.indexOf(t$1.name) >= 0) return !1;
				let r$1 = !0;
				return t$1.eachChild(((t$2) => {
					r$1 && !On(t$2, e$1) && (r$1 = !1);
				})), r$1;
			}
			function Rn(t$1) {
				return {
					result: "success",
					value: t$1
				};
			}
			function Un(t$1) {
				return {
					result: "error",
					value: t$1
				};
			}
			function jn(t$1) {
				return "data-driven" === t$1["property-type"] || "cross-faded-data-driven" === t$1["property-type"];
			}
			function Nn(t$1) {
				return !!t$1.expression && t$1.expression.parameters.indexOf("zoom") > -1;
			}
			function qn(t$1) {
				return !!t$1.expression && t$1.expression.interpolated;
			}
			function Gn(t$1) {
				return t$1 instanceof Number ? "number" : t$1 instanceof String ? "string" : t$1 instanceof Boolean ? "boolean" : Array.isArray(t$1) ? "array" : null === t$1 ? "null" : typeof t$1;
			}
			function Xn(t$1) {
				return "object" == typeof t$1 && null !== t$1 && !Array.isArray(t$1) && Ue(t$1) === Rt;
			}
			function Zn(t$1) {
				return t$1;
			}
			function Yn(t$1, e$1) {
				const r$1 = t$1.stops && "object" == typeof t$1.stops[0][0], n$1 = r$1 || !(r$1 || void 0 !== t$1.property), i$1 = t$1.type || (qn(e$1) ? "exponential" : "interval"), s$1 = function(t$2) {
					switch (t$2.type) {
						case "color": return Me.parse;
						case "padding": return Ee.parse;
						case "numberArray": return Te.parse;
						case "colorArray": return Be.parse;
						default: return null;
					}
				}(e$1);
				if (s$1 && ((t$1 = Et({}, t$1)).stops && (t$1.stops = t$1.stops.map(((t$2) => [t$2[0], s$1(t$2[1])]))), t$1.default = s$1(t$1.default ? t$1.default : e$1.default)), t$1.colorSpace && "rgb" !== (a$1 = t$1.colorSpace) && "hcl" !== a$1 && "lab" !== a$1) throw new Error(`Unknown color space: "${t$1.colorSpace}"`);
				var a$1;
				const o$1 = function(t$2) {
					switch (t$2) {
						case "exponential": return Wn;
						case "interval": return Jn;
						case "categorical": return Kn;
						case "identity": return Qn;
						default: throw new Error(`Unknown function type "${t$2}"`);
					}
				}(i$1);
				let l$1, u$1;
				if ("categorical" === i$1) {
					l$1 = Object.create(null);
					for (const e$2 of t$1.stops) l$1[e$2[0]] = e$2[1];
					u$1 = typeof t$1.stops[0][0];
				}
				if (r$1) {
					const r$2 = {}, n$2 = [];
					for (let e$2 = 0; e$2 < t$1.stops.length; e$2++) {
						const i$3 = t$1.stops[e$2], s$3 = i$3[0].zoom;
						void 0 === r$2[s$3] && (r$2[s$3] = {
							zoom: s$3,
							type: t$1.type,
							property: t$1.property,
							default: t$1.default,
							stops: []
						}, n$2.push(s$3)), r$2[s$3].stops.push([i$3[0].value, i$3[1]]);
					}
					const i$2 = [];
					for (const t$2 of n$2) i$2.push([r$2[t$2].zoom, Yn(r$2[t$2], e$1)]);
					const s$2 = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: s$2,
						interpolationFactor: pr.interpolationFactor.bind(void 0, s$2),
						zoomStops: i$2.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }, n$3) => Wn({
							stops: i$2,
							base: t$1.base
						}, e$1, r$3).evaluate(r$3, n$3)
					};
				}
				if (n$1) {
					const r$2 = "exponential" === i$1 ? {
						name: "exponential",
						base: void 0 !== t$1.base ? t$1.base : 1
					} : null;
					return {
						kind: "camera",
						interpolationType: r$2,
						interpolationFactor: pr.interpolationFactor.bind(void 0, r$2),
						zoomStops: t$1.stops.map(((t$2) => t$2[0])),
						evaluate: ({ zoom: r$3 }) => o$1(t$1, e$1, r$3, l$1, u$1)
					};
				}
				return {
					kind: "source",
					evaluate(r$2, n$2) {
						const i$2 = n$2 && n$2.properties ? n$2.properties[t$1.property] : void 0;
						return void 0 === i$2 ? Hn(t$1.default, e$1.default) : o$1(t$1, e$1, i$2, l$1, u$1);
					}
				};
			}
			function Hn(t$1, e$1, r$1) {
				return void 0 !== t$1 ? t$1 : void 0 !== e$1 ? e$1 : void 0 !== r$1 ? r$1 : void 0;
			}
			function Kn(t$1, e$1, r$1, n$1, i$1) {
				return Hn(typeof r$1 === i$1 ? n$1[r$1] : void 0, t$1.default, e$1.default);
			}
			function Jn(t$1, e$1, r$1) {
				if ("number" !== Gn(r$1)) return Hn(t$1.default, e$1.default);
				const n$1 = t$1.stops.length;
				if (1 === n$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[n$1 - 1][0]) return t$1.stops[n$1 - 1][1];
				const i$1 = sr(t$1.stops.map(((t$2) => t$2[0])), r$1);
				return t$1.stops[i$1][1];
			}
			function Wn(t$1, e$1, r$1) {
				const n$1 = void 0 !== t$1.base ? t$1.base : 1;
				if ("number" !== Gn(r$1)) return Hn(t$1.default, e$1.default);
				const i$1 = t$1.stops.length;
				if (1 === i$1) return t$1.stops[0][1];
				if (r$1 <= t$1.stops[0][0]) return t$1.stops[0][1];
				if (r$1 >= t$1.stops[i$1 - 1][0]) return t$1.stops[i$1 - 1][1];
				const s$1 = sr(t$1.stops.map(((t$2) => t$2[0])), r$1), a$1 = function(t$2, e$2, r$2, n$2) {
					const i$2 = n$2 - r$2, s$2 = t$2 - r$2;
					return 0 === i$2 ? 0 : 1 === e$2 ? s$2 / i$2 : (Math.pow(e$2, s$2) - 1) / (Math.pow(e$2, i$2) - 1);
				}(r$1, n$1, t$1.stops[s$1][0], t$1.stops[s$1 + 1][0]), o$1 = t$1.stops[s$1][1], l$1 = t$1.stops[s$1 + 1][1], u$1 = dr[e$1.type] || Zn;
				return "function" == typeof o$1.evaluate ? { evaluate(...e$2) {
					const r$2 = o$1.evaluate.apply(void 0, e$2), n$2 = l$1.evaluate.apply(void 0, e$2);
					if (void 0 !== r$2 && void 0 !== n$2) return u$1(r$2, n$2, a$1, t$1.colorSpace);
				} } : u$1(o$1, l$1, a$1, t$1.colorSpace);
			}
			function Qn(t$1, e$1, r$1) {
				switch (e$1.type) {
					case "color":
						r$1 = Me.parse(r$1);
						break;
					case "formatted":
						r$1 = Ce.fromString(r$1.toString());
						break;
					case "resolvedImage":
						r$1 = $e.fromString(r$1.toString());
						break;
					case "padding":
						r$1 = Ee.parse(r$1);
						break;
					case "colorArray":
						r$1 = Be.parse(r$1);
						break;
					case "numberArray":
						r$1 = Te.parse(r$1);
						break;
					default: Gn(r$1) === e$1.type || "enum" === e$1.type && e$1.values[r$1] || (r$1 = void 0);
				}
				return Hn(r$1, t$1.default, e$1.default);
			}
			En.register(Cn, {
				error: [
					{ kind: "error" },
					[Dt],
					(t$1, [e$1]) => {
						throw new Ve(e$1.evaluate(t$1));
					}
				],
				typeof: [
					Dt,
					[Ut],
					(t$1, [e$1]) => Kt(Ue(e$1.evaluate(t$1)))
				],
				"to-rgba": [
					Ht(Ft, 4),
					[Lt],
					(t$1, [e$1]) => {
						const [r$1, n$1, i$1, s$1] = e$1.evaluate(t$1).rgb;
						return [
							255 * r$1,
							255 * n$1,
							255 * i$1,
							s$1
						];
					}
				],
				rgb: [
					Lt,
					[
						Ft,
						Ft,
						Ft
					],
					Tn
				],
				rgba: [
					Lt,
					[
						Ft,
						Ft,
						Ft,
						Ft
					],
					Tn
				],
				has: {
					type: $t,
					overloads: [[[Dt], (t$1, [e$1]) => Bn(e$1.evaluate(t$1), t$1.properties())], [[Dt, Rt], (t$1, [e$1, r$1]) => Bn(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				get: {
					type: Ut,
					overloads: [[[Dt], (t$1, [e$1]) => Vn(e$1.evaluate(t$1), t$1.properties())], [[Dt, Rt], (t$1, [e$1, r$1]) => Vn(e$1.evaluate(t$1), r$1.evaluate(t$1))]]
				},
				"feature-state": [
					Ut,
					[Dt],
					(t$1, [e$1]) => Vn(e$1.evaluate(t$1), t$1.featureState || {})
				],
				properties: [
					Rt,
					[],
					(t$1) => t$1.properties()
				],
				"geometry-type": [
					Dt,
					[],
					(t$1) => t$1.geometryType()
				],
				id: [
					Ut,
					[],
					(t$1) => t$1.id()
				],
				zoom: [
					Ft,
					[],
					(t$1) => t$1.globals.zoom
				],
				"heatmap-density": [
					Ft,
					[],
					(t$1) => t$1.globals.heatmapDensity || 0
				],
				elevation: [
					Ft,
					[],
					(t$1) => t$1.globals.elevation || 0
				],
				"line-progress": [
					Ft,
					[],
					(t$1) => t$1.globals.lineProgress || 0
				],
				accumulated: [
					Ut,
					[],
					(t$1) => void 0 === t$1.globals.accumulated ? null : t$1.globals.accumulated
				],
				"+": [
					Ft,
					Fn(Ft),
					(t$1, e$1) => {
						let r$1 = 0;
						for (const n$1 of e$1) r$1 += n$1.evaluate(t$1);
						return r$1;
					}
				],
				"*": [
					Ft,
					Fn(Ft),
					(t$1, e$1) => {
						let r$1 = 1;
						for (const n$1 of e$1) r$1 *= n$1.evaluate(t$1);
						return r$1;
					}
				],
				"-": {
					type: Ft,
					overloads: [[[Ft, Ft], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) - r$1.evaluate(t$1)], [[Ft], (t$1, [e$1]) => -e$1.evaluate(t$1)]]
				},
				"/": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) / r$1.evaluate(t$1)
				],
				"%": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => e$1.evaluate(t$1) % r$1.evaluate(t$1)
				],
				ln2: [
					Ft,
					[],
					() => Math.LN2
				],
				pi: [
					Ft,
					[],
					() => Math.PI
				],
				e: [
					Ft,
					[],
					() => Math.E
				],
				"^": [
					Ft,
					[Ft, Ft],
					(t$1, [e$1, r$1]) => Math.pow(e$1.evaluate(t$1), r$1.evaluate(t$1))
				],
				sqrt: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.sqrt(e$1.evaluate(t$1))
				],
				log10: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN10
				],
				ln: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1))
				],
				log2: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.log(e$1.evaluate(t$1)) / Math.LN2
				],
				sin: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.sin(e$1.evaluate(t$1))
				],
				cos: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.cos(e$1.evaluate(t$1))
				],
				tan: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.tan(e$1.evaluate(t$1))
				],
				asin: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.asin(e$1.evaluate(t$1))
				],
				acos: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.acos(e$1.evaluate(t$1))
				],
				atan: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.atan(e$1.evaluate(t$1))
				],
				min: [
					Ft,
					Fn(Ft),
					(t$1, e$1) => Math.min(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				max: [
					Ft,
					Fn(Ft),
					(t$1, e$1) => Math.max(...e$1.map(((e$2) => e$2.evaluate(t$1))))
				],
				abs: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.abs(e$1.evaluate(t$1))
				],
				round: [
					Ft,
					[Ft],
					(t$1, [e$1]) => {
						const r$1 = e$1.evaluate(t$1);
						return r$1 < 0 ? -Math.round(-r$1) : Math.round(r$1);
					}
				],
				floor: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.floor(e$1.evaluate(t$1))
				],
				ceil: [
					Ft,
					[Ft],
					(t$1, [e$1]) => Math.ceil(e$1.evaluate(t$1))
				],
				"filter-==": [
					$t,
					[Dt, Ut],
					(t$1, [e$1, r$1]) => t$1.properties()[e$1.value] === r$1.value
				],
				"filter-id-==": [
					$t,
					[Ut],
					(t$1, [e$1]) => t$1.id() === e$1.value
				],
				"filter-type-==": [
					$t,
					[Dt],
					(t$1, [e$1]) => t$1.geometryType() === e$1.value
				],
				"filter-<": [
					$t,
					[Dt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 < i$1;
					}
				],
				"filter-id-<": [
					$t,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 < n$1;
					}
				],
				"filter->": [
					$t,
					[Dt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 > i$1;
					}
				],
				"filter-id->": [
					$t,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 > n$1;
					}
				],
				"filter-<=": [
					$t,
					[Dt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 <= i$1;
					}
				],
				"filter-id-<=": [
					$t,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 <= n$1;
					}
				],
				"filter->=": [
					$t,
					[Dt, Ut],
					(t$1, [e$1, r$1]) => {
						const n$1 = t$1.properties()[e$1.value], i$1 = r$1.value;
						return typeof n$1 == typeof i$1 && n$1 >= i$1;
					}
				],
				"filter-id->=": [
					$t,
					[Ut],
					(t$1, [e$1]) => {
						const r$1 = t$1.id(), n$1 = e$1.value;
						return typeof r$1 == typeof n$1 && r$1 >= n$1;
					}
				],
				"filter-has": [
					$t,
					[Ut],
					(t$1, [e$1]) => e$1.value in t$1.properties()
				],
				"filter-has-id": [
					$t,
					[],
					(t$1) => null !== t$1.id() && void 0 !== t$1.id()
				],
				"filter-type-in": [
					$t,
					[Ht(Dt)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.geometryType()) >= 0
				],
				"filter-id-in": [
					$t,
					[Ht(Ut)],
					(t$1, [e$1]) => e$1.value.indexOf(t$1.id()) >= 0
				],
				"filter-in-small": [
					$t,
					[Dt, Ht(Ut)],
					(t$1, [e$1, r$1]) => r$1.value.indexOf(t$1.properties()[e$1.value]) >= 0
				],
				"filter-in-large": [
					$t,
					[Dt, Ht(Ut)],
					(t$1, [e$1, r$1]) => function(t$2, e$2, r$2, n$1) {
						for (; r$2 <= n$1;) {
							const i$1 = r$2 + n$1 >> 1;
							if (e$2[i$1] === t$2) return !0;
							e$2[i$1] > t$2 ? n$1 = i$1 - 1 : r$2 = i$1 + 1;
						}
						return !1;
					}(t$1.properties()[e$1.value], r$1.value, 0, r$1.value.length - 1)
				],
				all: {
					type: $t,
					overloads: [[[$t, $t], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) && r$1.evaluate(t$1)], [Fn($t), (t$1, e$1) => {
						for (const r$1 of e$1) if (!r$1.evaluate(t$1)) return !1;
						return !0;
					}]]
				},
				any: {
					type: $t,
					overloads: [[[$t, $t], (t$1, [e$1, r$1]) => e$1.evaluate(t$1) || r$1.evaluate(t$1)], [Fn($t), (t$1, e$1) => {
						for (const r$1 of e$1) if (r$1.evaluate(t$1)) return !0;
						return !1;
					}]]
				},
				"!": [
					$t,
					[$t],
					(t$1, [e$1]) => !e$1.evaluate(t$1)
				],
				"is-supported-script": [
					$t,
					[Dt],
					(t$1, [e$1]) => {
						const r$1 = t$1.globals && t$1.globals.isSupportedScript;
						return !r$1 || r$1(e$1.evaluate(t$1));
					}
				],
				upcase: [
					Dt,
					[Dt],
					(t$1, [e$1]) => e$1.evaluate(t$1).toUpperCase()
				],
				downcase: [
					Dt,
					[Dt],
					(t$1, [e$1]) => e$1.evaluate(t$1).toLowerCase()
				],
				concat: [
					Dt,
					Fn(Ut),
					(t$1, e$1) => e$1.map(((e$2) => je(e$2.evaluate(t$1)))).join("")
				],
				"resolved-locale": [
					Dt,
					[jt],
					(t$1, [e$1]) => e$1.evaluate(t$1).resolvedLocale()
				]
			});
			class ti {
				constructor(t$1, e$1, r$1) {
					this.expression = t$1, this._warningHistory = {}, this._evaluator = new He(), this._defaultValue = e$1 ? function(t$2) {
						if ("color" === t$2.type && Xn(t$2.default)) return new Me(0, 0, 0, 0);
						switch (t$2.type) {
							case "color": return Me.parse(t$2.default) || null;
							case "padding": return Ee.parse(t$2.default) || null;
							case "numberArray": return Te.parse(t$2.default) || null;
							case "colorArray": return Be.parse(t$2.default) || null;
							case "variableAnchorOffsetCollection": return De.parse(t$2.default) || null;
							case "projectionDefinition": return Le.parse(t$2.default) || null;
							default: return void 0 === t$2.default ? null : t$2.default;
						}
					}(e$1) : null, this._enumValues = e$1 && "enum" === e$1.type ? e$1.values : null, this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ui(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1, this._evaluator.featureState = r$1, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1, this.expression.evaluate(this._evaluator);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					this._globalState && (t$1 = ui(t$1, this._globalState)), this._evaluator.globals = t$1, this._evaluator.feature = e$1 || null, this._evaluator.featureState = r$1 || null, this._evaluator.canonical = n$1, this._evaluator.availableImages = i$1 || null, this._evaluator.formattedSection = s$1 || null;
					try {
						const t$2 = this.expression.evaluate(this._evaluator);
						if (null == t$2 || "number" == typeof t$2 && t$2 != t$2) return this._defaultValue;
						if (this._enumValues && !(t$2 in this._enumValues)) throw new Ve(`Expected value to be one of ${Object.keys(this._enumValues).map(((t$3) => JSON.stringify(t$3))).join(", ")}, but found ${JSON.stringify(t$2)} instead.`);
						return t$2;
					} catch (t$2) {
						return this._warningHistory[t$2.message] || (this._warningHistory[t$2.message] = !0, "undefined" != typeof console && console.warn(t$2.message)), this._defaultValue;
					}
				}
			}
			function ei(t$1) {
				return Array.isArray(t$1) && t$1.length > 0 && "string" == typeof t$1[0] && t$1[0] in Cn;
			}
			function ri(t$1, e$1, r$1) {
				const n$1 = new Ke(Cn, Dn, [], e$1 ? function(t$2) {
					const e$2 = {
						color: Lt,
						string: Dt,
						number: Ft,
						enum: Dt,
						boolean: $t,
						formatted: Nt,
						padding: qt,
						numberArray: Xt,
						colorArray: Gt,
						projectionDefinition: Ot,
						resolvedImage: Zt,
						variableAnchorOffsetCollection: Yt
					};
					return "array" === t$2.type ? Ht(e$2[t$2.value] || Ut, t$2.length) : e$2[t$2.type];
				}(e$1) : void 0), i$1 = n$1.parse(t$1, void 0, void 0, void 0, e$1 && "string" === e$1.type ? { typeAnnotation: "coerce" } : void 0);
				return i$1 ? Rn(new ti(i$1, e$1, r$1)) : Un(n$1.errors);
			}
			class ni {
				constructor(t$1, e$1, r$1) {
					this.kind = t$1, this._styleExpression = e$1, this.isStateDependent = "constant" !== t$1 && !Ln(e$1.expression), this.globalStateRefs = li(e$1.expression), this._globalState = r$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ui(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ui(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
			}
			class ii {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.kind = t$1, this.zoomStops = r$1, this._styleExpression = e$1, this.isStateDependent = "camera" !== t$1 && !Ln(e$1.expression), this.globalStateRefs = li(e$1.expression), this.interpolationType = n$1, this._globalState = i$1;
				}
				evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ui(t$1, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return this._globalState && (t$1 = ui(t$1, this._globalState)), this._styleExpression.evaluate(t$1, e$1, r$1, n$1, i$1, s$1);
				}
				interpolationFactor(t$1, e$1, r$1) {
					return this.interpolationType ? pr.interpolationFactor(this.interpolationType, t$1, e$1, r$1) : 0;
				}
			}
			function si(t$1, e$1, r$1) {
				const n$1 = ri(t$1, e$1, r$1);
				if ("error" === n$1.result) return n$1;
				const i$1 = n$1.value.expression, s$1 = $n(i$1);
				if (!s$1 && !jn(e$1)) return Un([new Tt("", "data expressions not supported")]);
				const a$1 = On(i$1, ["zoom"]);
				if (!a$1 && !Nn(e$1)) return Un([new Tt("", "zoom expressions not supported")]);
				const o$1 = oi(i$1);
				return o$1 || a$1 ? o$1 instanceof Tt ? Un([o$1]) : o$1 instanceof pr && !qn(e$1) ? Un([new Tt("", "\"interpolate\" expressions cannot be used with this property")]) : Rn(o$1 ? new ii(s$1 ? "camera" : "composite", n$1.value, o$1.labels, o$1 instanceof pr ? o$1.interpolation : void 0, r$1) : new ni(s$1 ? "constant" : "source", n$1.value, r$1)) : Un([new Tt("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
			}
			class ai {
				constructor(t$1, e$1) {
					this._parameters = t$1, this._specification = e$1, Et(this, Yn(this._parameters, this._specification));
				}
				static deserialize(t$1) {
					return new ai(t$1._parameters, t$1._specification);
				}
				static serialize(t$1) {
					return {
						_parameters: t$1._parameters,
						_specification: t$1._specification
					};
				}
			}
			function oi(t$1) {
				let e$1 = null;
				if (t$1 instanceof Je) e$1 = oi(t$1.result);
				else if (t$1 instanceof yr) {
					for (const r$1 of t$1.args) if (e$1 = oi(r$1), e$1) break;
				} else (t$1 instanceof ar || t$1 instanceof pr) && t$1.input instanceof En && "zoom" === t$1.input.name && (e$1 = t$1);
				return e$1 instanceof Tt || t$1.eachChild(((t$2) => {
					const r$1 = oi(t$2);
					r$1 instanceof Tt ? e$1 = r$1 : !e$1 && r$1 ? e$1 = new Tt("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : e$1 && r$1 && e$1 !== r$1 && (e$1 = new Tt("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), e$1;
			}
			function li(t$1, e$1 = /* @__PURE__ */ new Set()) {
				return t$1 instanceof Pn && e$1.add(t$1.key), t$1.eachChild(((t$2) => {
					li(t$2, e$1);
				})), e$1;
			}
			function ui(t$1, e$1) {
				const { zoom: r$1, heatmapDensity: n$1, elevation: i$1, lineProgress: s$1, isSupportedScript: a$1, accumulated: o$1 } = null != t$1 ? t$1 : {};
				return {
					zoom: r$1,
					heatmapDensity: n$1,
					elevation: i$1,
					lineProgress: s$1,
					isSupportedScript: a$1,
					accumulated: o$1,
					globalState: e$1
				};
			}
			function ci(t$1) {
				if (!0 === t$1 || !1 === t$1) return !0;
				if (!Array.isArray(t$1) || 0 === t$1.length) return !1;
				switch (t$1[0]) {
					case "has": return t$1.length >= 2 && "$id" !== t$1[1] && "$type" !== t$1[1];
					case "in": return t$1.length >= 3 && ("string" != typeof t$1[1] || Array.isArray(t$1[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return 3 !== t$1.length || Array.isArray(t$1[1]) || Array.isArray(t$1[2]);
					case "any":
					case "all":
						for (const e$1 of t$1.slice(1)) if (!ci(e$1) && "boolean" != typeof e$1) return !1;
						return !0;
					default: return !0;
				}
			}
			const hi = {
				type: "boolean",
				default: !1,
				transition: !1,
				"property-type": "data-driven",
				expression: {
					interpolated: !1,
					parameters: ["zoom", "feature"]
				}
			};
			function pi(t$1, e$1) {
				if (null == t$1) return {
					filter: () => !0,
					needGeometry: !1,
					getGlobalStateRefs: () => /* @__PURE__ */ new Set()
				};
				ci(t$1) || (t$1 = yi(t$1));
				const r$1 = ri(t$1, hi, e$1);
				if ("error" === r$1.result) throw new Error(r$1.value.map(((t$2) => `${t$2.key}: ${t$2.message}`)).join(", "));
				return {
					filter: (t$2, e$2, n$1) => r$1.value.evaluate(t$2, e$2, {}, n$1),
					needGeometry: di(t$1),
					getGlobalStateRefs: () => li(r$1.value.expression)
				};
			}
			function fi(t$1, e$1) {
				return t$1 < e$1 ? -1 : t$1 > e$1 ? 1 : 0;
			}
			function di(t$1) {
				if (!Array.isArray(t$1)) return !1;
				if ("within" === t$1[0] || "distance" === t$1[0]) return !0;
				for (let e$1 = 1; e$1 < t$1.length; e$1++) if (di(t$1[e$1])) return !0;
				return !1;
			}
			function yi(t$1) {
				if (!t$1) return !0;
				const e$1 = t$1[0];
				return t$1.length <= 1 ? "any" !== e$1 : "==" === e$1 ? mi(t$1[1], t$1[2], "==") : "!=" === e$1 ? vi(mi(t$1[1], t$1[2], "==")) : "<" === e$1 || ">" === e$1 || "<=" === e$1 || ">=" === e$1 ? mi(t$1[1], t$1[2], e$1) : "any" === e$1 ? (r$1 = t$1.slice(1), ["any"].concat(r$1.map(yi))) : "all" === e$1 ? ["all"].concat(t$1.slice(1).map(yi)) : "none" === e$1 ? ["all"].concat(t$1.slice(1).map(yi).map(vi)) : "in" === e$1 ? gi(t$1[1], t$1.slice(2)) : "!in" === e$1 ? vi(gi(t$1[1], t$1.slice(2))) : "has" === e$1 ? xi(t$1[1]) : "!has" !== e$1 || vi(xi(t$1[1]));
				var r$1;
			}
			function mi(t$1, e$1, r$1) {
				switch (t$1) {
					case "$type": return [`filter-type-${r$1}`, e$1];
					case "$id": return [`filter-id-${r$1}`, e$1];
					default: return [
						`filter-${r$1}`,
						t$1,
						e$1
					];
				}
			}
			function gi(t$1, e$1) {
				if (0 === e$1.length) return !1;
				switch (t$1) {
					case "$type": return ["filter-type-in", ["literal", e$1]];
					case "$id": return ["filter-id-in", ["literal", e$1]];
					default: return e$1.length > 200 && !e$1.some(((t$2) => typeof t$2 != typeof e$1[0])) ? [
						"filter-in-large",
						t$1,
						["literal", e$1.sort(fi)]
					] : [
						"filter-in-small",
						t$1,
						["literal", e$1]
					];
				}
			}
			function xi(t$1) {
				switch (t$1) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", t$1];
				}
			}
			function vi(t$1) {
				return ["!", t$1];
			}
			function bi(t$1) {
				const e$1 = typeof t$1;
				if ("number" === e$1 || "boolean" === e$1 || "string" === e$1 || null == t$1) return JSON.stringify(t$1);
				if (Array.isArray(t$1)) {
					let e$2 = "[";
					for (const r$2 of t$1) e$2 += `${bi(r$2)},`;
					return `${e$2}]`;
				}
				const r$1 = Object.keys(t$1).sort();
				let n$1 = "{";
				for (let e$2 = 0; e$2 < r$1.length; e$2++) n$1 += `${JSON.stringify(r$1[e$2])}:${bi(t$1[r$1[e$2]])},`;
				return `${n$1}}`;
			}
			function wi(t$1) {
				let e$1 = "";
				for (const r$1 of vt) e$1 += `/${bi(t$1[r$1])}`;
				return e$1;
			}
			function _i(t$1) {
				const e$1 = t$1.value;
				return e$1 ? [new Ct(t$1.key, e$1, "constants have been deprecated as of v8")] : [];
			}
			function Si(t$1) {
				return t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean ? t$1.valueOf() : t$1;
			}
			function Ai(t$1) {
				if (Array.isArray(t$1)) return t$1.map(Ai);
				if (t$1 instanceof Object && !(t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Boolean)) {
					const e$1 = {};
					for (const r$1 in t$1) e$1[r$1] = Ai(t$1[r$1]);
					return e$1;
				}
				return Si(t$1);
			}
			function ki(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec || {}, i$1 = t$1.objectElementValidators || {}, s$1 = t$1.style, a$1 = t$1.styleSpec, o$1 = t$1.validateSpec;
				let l$1 = [];
				const u$1 = Gn(r$1);
				if ("object" !== u$1) return [new Ct(e$1, r$1, `object expected, ${u$1} found`)];
				for (const t$2 in r$1) {
					const u$2 = t$2.split(".")[0], c$1 = xe(n$1, u$2) || n$1["*"];
					let h$1;
					if (xe(i$1, u$2)) h$1 = i$1[u$2];
					else if (xe(n$1, u$2)) h$1 = o$1;
					else if (i$1["*"]) h$1 = i$1["*"];
					else {
						if (!n$1["*"]) {
							l$1.push(new Ct(e$1, r$1[t$2], `unknown property "${t$2}"`));
							continue;
						}
						h$1 = o$1;
					}
					l$1 = l$1.concat(h$1({
						key: (e$1 ? `${e$1}.` : e$1) + t$2,
						value: r$1[t$2],
						valueSpec: c$1,
						style: s$1,
						styleSpec: a$1,
						object: r$1,
						objectKey: t$2,
						validateSpec: o$1
					}, r$1));
				}
				for (const t$2 in n$1) i$1[t$2] || n$1[t$2].required && void 0 === n$1[t$2].default && void 0 === r$1[t$2] && l$1.push(new Ct(e$1, r$1, `missing required property "${t$2}"`));
				return l$1;
			}
			function Mi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.style, i$1 = t$1.styleSpec, s$1 = t$1.key, a$1 = t$1.arrayElementValidator || t$1.validateSpec;
				if ("array" !== Gn(e$1)) return [new Ct(s$1, e$1, `array expected, ${Gn(e$1)} found`)];
				if (r$1.length && e$1.length !== r$1.length) return [new Ct(s$1, e$1, `array length ${r$1.length} expected, length ${e$1.length} found`)];
				if (r$1["min-length"] && e$1.length < r$1["min-length"]) return [new Ct(s$1, e$1, `array length at least ${r$1["min-length"]} expected, length ${e$1.length} found`)];
				let o$1 = {
					type: r$1.value,
					values: r$1.values
				};
				i$1.$version < 7 && (o$1.function = r$1.function), "object" === Gn(r$1.value) && (o$1 = r$1.value);
				let l$1 = [];
				for (let r$2 = 0; r$2 < e$1.length; r$2++) l$1 = l$1.concat(a$1({
					array: e$1,
					arrayIndex: r$2,
					value: e$1[r$2],
					valueSpec: o$1,
					validateSpec: t$1.validateSpec,
					style: n$1,
					styleSpec: i$1,
					key: `${s$1}[${r$2}]`
				}));
				return l$1;
			}
			function Ii(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec;
				let i$1 = Gn(r$1);
				return "number" === i$1 && r$1 != r$1 && (i$1 = "NaN"), "number" !== i$1 ? [new Ct(e$1, r$1, `number expected, ${i$1} found`)] : "minimum" in n$1 && r$1 < n$1.minimum ? [new Ct(e$1, r$1, `${r$1} is less than the minimum value ${n$1.minimum}`)] : "maximum" in n$1 && r$1 > n$1.maximum ? [new Ct(e$1, r$1, `${r$1} is greater than the maximum value ${n$1.maximum}`)] : [];
			}
			function zi(t$1) {
				const e$1 = t$1.valueSpec, r$1 = Si(t$1.value.type);
				let n$1, i$1, s$1, a$1 = {};
				const o$1 = "categorical" !== r$1 && void 0 === t$1.value.property, l$1 = !o$1, u$1 = "array" === Gn(t$1.value.stops) && "array" === Gn(t$1.value.stops[0]) && "object" === Gn(t$1.value.stops[0][0]), c$1 = ki({
					key: t$1.key,
					value: t$1.value,
					valueSpec: t$1.styleSpec.function,
					validateSpec: t$1.validateSpec,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					objectElementValidators: {
						stops: function(t$2) {
							if ("identity" === r$1) return [new Ct(t$2.key, t$2.value, "identity function may not have a \"stops\" property")];
							let e$2 = [];
							const n$2 = t$2.value;
							return e$2 = e$2.concat(Mi({
								key: t$2.key,
								value: n$2,
								valueSpec: t$2.valueSpec,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec,
								arrayElementValidator: h$1
							})), "array" === Gn(n$2) && 0 === n$2.length && e$2.push(new Ct(t$2.key, n$2, "array must have at least one stop")), e$2;
						},
						default: function(t$2) {
							return t$2.validateSpec({
								key: t$2.key,
								value: t$2.value,
								valueSpec: e$1,
								validateSpec: t$2.validateSpec,
								style: t$2.style,
								styleSpec: t$2.styleSpec
							});
						}
					}
				});
				return "identity" === r$1 && o$1 && c$1.push(new Ct(t$1.key, t$1.value, "missing required property \"property\"")), "identity" === r$1 || t$1.value.stops || c$1.push(new Ct(t$1.key, t$1.value, "missing required property \"stops\"")), "exponential" === r$1 && t$1.valueSpec.expression && !qn(t$1.valueSpec) && c$1.push(new Ct(t$1.key, t$1.value, "exponential functions not supported")), t$1.styleSpec.$version >= 8 && (l$1 && !jn(t$1.valueSpec) ? c$1.push(new Ct(t$1.key, t$1.value, "property functions not supported")) : o$1 && !Nn(t$1.valueSpec) && c$1.push(new Ct(t$1.key, t$1.value, "zoom functions not supported"))), "categorical" !== r$1 && !u$1 || void 0 !== t$1.value.property || c$1.push(new Ct(t$1.key, t$1.value, "\"property\" property is required")), c$1;
				function h$1(t$2) {
					let r$2 = [];
					const n$2 = t$2.value, o$2 = t$2.key;
					if ("array" !== Gn(n$2)) return [new Ct(o$2, n$2, `array expected, ${Gn(n$2)} found`)];
					if (2 !== n$2.length) return [new Ct(o$2, n$2, `array length 2 expected, length ${n$2.length} found`)];
					if (u$1) {
						if ("object" !== Gn(n$2[0])) return [new Ct(o$2, n$2, `object expected, ${Gn(n$2[0])} found`)];
						if (void 0 === n$2[0].zoom) return [new Ct(o$2, n$2, "object stop key must have zoom")];
						if (void 0 === n$2[0].value) return [new Ct(o$2, n$2, "object stop key must have value")];
						if (s$1 && s$1 > Si(n$2[0].zoom)) return [new Ct(o$2, n$2[0].zoom, "stop zoom values must appear in ascending order")];
						Si(n$2[0].zoom) !== s$1 && (s$1 = Si(n$2[0].zoom), i$1 = void 0, a$1 = {}), r$2 = r$2.concat(ki({
							key: `${o$2}[0]`,
							value: n$2[0],
							valueSpec: { zoom: {} },
							validateSpec: t$2.validateSpec,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							objectElementValidators: {
								zoom: Ii,
								value: p$1
							}
						}));
					} else r$2 = r$2.concat(p$1({
						key: `${o$2}[0]`,
						value: n$2[0],
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}, n$2));
					return ei(Ai(n$2[1])) ? r$2.concat([new Ct(`${o$2}[1]`, n$2[1], "expressions are not allowed in function stops.")]) : r$2.concat(t$2.validateSpec({
						key: `${o$2}[1]`,
						value: n$2[1],
						valueSpec: e$1,
						validateSpec: t$2.validateSpec,
						style: t$2.style,
						styleSpec: t$2.styleSpec
					}));
				}
				function p$1(t$2, s$2) {
					const o$2 = Gn(t$2.value), l$2 = Si(t$2.value), u$2 = null !== t$2.value ? t$2.value : s$2;
					if (n$1) {
						if (o$2 !== n$1) return [new Ct(t$2.key, u$2, `${o$2} stop domain type must match previous stop domain type ${n$1}`)];
					} else n$1 = o$2;
					if ("number" !== o$2 && "string" !== o$2 && "boolean" !== o$2) return [new Ct(t$2.key, u$2, "stop domain value must be a number, string, or boolean")];
					if ("number" !== o$2 && "categorical" !== r$1) {
						let n$2 = `number expected, ${o$2} found`;
						return jn(e$1) && void 0 === r$1 && (n$2 += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new Ct(t$2.key, u$2, n$2)];
					}
					return "categorical" !== r$1 || "number" !== o$2 || isFinite(l$2) && Math.floor(l$2) === l$2 ? "categorical" !== r$1 && "number" === o$2 && void 0 !== i$1 && l$2 < i$1 ? [new Ct(t$2.key, u$2, "stop domain values must appear in ascending order")] : (i$1 = l$2, "categorical" === r$1 && l$2 in a$1 ? [new Ct(t$2.key, u$2, "stop domain values must be unique")] : (a$1[l$2] = !0, [])) : [new Ct(t$2.key, u$2, `integer expected, found ${l$2}`)];
				}
			}
			function Pi(t$1) {
				const e$1 = ("property" === t$1.expressionContext ? si : ri)(Ai(t$1.value), t$1.valueSpec);
				if ("error" === e$1.result) return e$1.value.map(((e$2) => new Ct(`${t$1.key}${e$2.key}`, t$1.value, e$2.message)));
				const r$1 = e$1.value.expression || e$1.value._styleExpression.expression;
				if ("property" === t$1.expressionContext && "text-font" === t$1.propertyKey && !r$1.outputDefined()) return [new Ct(t$1.key, t$1.value, `Invalid data expression for "${t$1.propertyKey}". Output values must be contained as literals within the expression.`)];
				if ("property" === t$1.expressionContext && "layout" === t$1.propertyType && !Ln(r$1)) return [new Ct(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if ("filter" === t$1.expressionContext && !Ln(r$1)) return [new Ct(t$1.key, t$1.value, "\"feature-state\" data expressions are not supported with filters.")];
				if (t$1.expressionContext && 0 === t$1.expressionContext.indexOf("cluster")) {
					if (!On(r$1, ["zoom", "feature-state"])) return [new Ct(t$1.key, t$1.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if ("cluster-initial" === t$1.expressionContext && !$n(r$1)) return [new Ct(t$1.key, t$1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function Ci(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = Gn(r$1);
				return "string" !== n$1 ? [new Ct(e$1, r$1, `color expected, ${n$1} found`)] : Me.parse(String(r$1)) ? [] : [new Ct(e$1, r$1, `color expected, "${r$1}" found`)];
			}
			function Ei(t$1) {
				const e$1 = t$1.key, r$1 = t$1.value, n$1 = t$1.valueSpec, i$1 = [];
				return Array.isArray(n$1.values) ? -1 === n$1.values.indexOf(Si(r$1)) && i$1.push(new Ct(e$1, r$1, `expected one of [${n$1.values.join(", ")}], ${JSON.stringify(r$1)} found`)) : -1 === Object.keys(n$1.values).indexOf(Si(r$1)) && i$1.push(new Ct(e$1, r$1, `expected one of [${Object.keys(n$1.values).join(", ")}], ${JSON.stringify(r$1)} found`)), i$1;
			}
			function Ti(t$1) {
				return ci(Ai(t$1.value)) ? Pi(Et({}, t$1, {
					expressionContext: "filter",
					valueSpec: { value: "boolean" }
				})) : Bi(t$1);
			}
			function Bi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key;
				if ("array" !== Gn(e$1)) return [new Ct(r$1, e$1, `array expected, ${Gn(e$1)} found`)];
				const n$1 = t$1.styleSpec;
				let i$1, s$1 = [];
				if (e$1.length < 1) return [new Ct(r$1, e$1, "filter array must have at least 1 element")];
				switch (s$1 = s$1.concat(Ei({
					key: `${r$1}[0]`,
					value: e$1[0],
					valueSpec: n$1.filter_operator,
					style: t$1.style,
					styleSpec: t$1.styleSpec
				})), Si(e$1[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=": e$1.length >= 2 && "$type" === Si(e$1[1]) && s$1.push(new Ct(r$1, e$1, `"$type" cannot be use with operator "${e$1[0]}"`));
					case "==":
					case "!=": 3 !== e$1.length && s$1.push(new Ct(r$1, e$1, `filter array for operator "${e$1[0]}" must have 3 elements`));
					case "in":
					case "!in":
						e$1.length >= 2 && (i$1 = Gn(e$1[1]), "string" !== i$1 && s$1.push(new Ct(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`)));
						for (let a$1 = 2; a$1 < e$1.length; a$1++) i$1 = Gn(e$1[a$1]), "$type" === Si(e$1[1]) ? s$1 = s$1.concat(Ei({
							key: `${r$1}[${a$1}]`,
							value: e$1[a$1],
							valueSpec: n$1.geometry_type,
							style: t$1.style,
							styleSpec: t$1.styleSpec
						})) : "string" !== i$1 && "number" !== i$1 && "boolean" !== i$1 && s$1.push(new Ct(`${r$1}[${a$1}]`, e$1[a$1], `string, number, or boolean expected, ${i$1} found`));
						break;
					case "any":
					case "all":
					case "none":
						for (let n$2 = 1; n$2 < e$1.length; n$2++) s$1 = s$1.concat(Bi({
							key: `${r$1}[${n$2}]`,
							value: e$1[n$2],
							style: t$1.style,
							styleSpec: t$1.styleSpec
						}));
						break;
					case "has":
					case "!has": i$1 = Gn(e$1[1]), 2 !== e$1.length ? s$1.push(new Ct(r$1, e$1, `filter array for "${e$1[0]}" operator must have 2 elements`)) : "string" !== i$1 && s$1.push(new Ct(`${r$1}[1]`, e$1[1], `string expected, ${i$1} found`));
				}
				return s$1;
			}
			function Vi(t$1, e$1) {
				const r$1 = t$1.key, n$1 = t$1.validateSpec, i$1 = t$1.style, s$1 = t$1.styleSpec, a$1 = t$1.value, o$1 = t$1.objectKey, l$1 = s$1[`${e$1}_${t$1.layerType}`];
				if (!l$1) return [];
				const u$1 = o$1.match(/^(.*)-transition$/);
				if ("paint" === e$1 && u$1 && l$1[u$1[1]] && l$1[u$1[1]].transition) return n$1({
					key: r$1,
					value: a$1,
					valueSpec: s$1.transition,
					style: i$1,
					styleSpec: s$1
				});
				const c$1 = t$1.valueSpec || l$1[o$1];
				if (!c$1) return [new Ct(r$1, a$1, `unknown property "${o$1}"`)];
				let h$1;
				if ("string" === Gn(a$1) && jn(c$1) && !c$1.tokens && (h$1 = /^{([^}]+)}$/.exec(a$1))) return [new Ct(r$1, a$1, `"${o$1}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h$1[1])} }\`.`)];
				const p$1 = [];
				return "symbol" === t$1.layerType && ("text-field" === o$1 && i$1 && !i$1.glyphs && p$1.push(new Ct(r$1, a$1, "use of \"text-field\" requires a style \"glyphs\" property")), "text-font" === o$1 && Xn(Ai(a$1)) && "identity" === Si(a$1.type) && p$1.push(new Ct(r$1, a$1, "\"text-font\" does not support identity functions"))), p$1.concat(n$1({
					key: t$1.key,
					value: a$1,
					valueSpec: c$1,
					style: i$1,
					styleSpec: s$1,
					expressionContext: "property",
					propertyType: e$1,
					propertyKey: o$1
				}));
			}
			function Fi(t$1) {
				return Vi(t$1, "paint");
			}
			function Di(t$1) {
				return Vi(t$1, "layout");
			}
			function $i(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key, i$1 = t$1.style, s$1 = t$1.styleSpec;
				if ("object" !== Gn(r$1)) return [new Ct(n$1, r$1, `object expected, ${Gn(r$1)} found`)];
				r$1.type || r$1.ref || e$1.push(new Ct(n$1, r$1, "either \"type\" or \"ref\" is required"));
				let a$1 = Si(r$1.type);
				const o$1 = Si(r$1.ref);
				if (r$1.id) {
					const s$2 = Si(r$1.id);
					for (let a$2 = 0; a$2 < t$1.arrayIndex; a$2++) {
						const t$2 = i$1.layers[a$2];
						Si(t$2.id) === s$2 && e$1.push(new Ct(n$1, r$1.id, `duplicate layer id "${r$1.id}", previously used at line ${t$2.id.__line__}`));
					}
				}
				if ("ref" in r$1) {
					let t$2;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((t$3) => {
						t$3 in r$1 && e$1.push(new Ct(n$1, r$1[t$3], `"${t$3}" is prohibited for ref layers`));
					})), i$1.layers.forEach(((e$2) => {
						Si(e$2.id) === o$1 && (t$2 = e$2);
					})), t$2 ? t$2.ref ? e$1.push(new Ct(n$1, r$1.ref, "ref cannot reference another ref layer")) : a$1 = Si(t$2.type) : e$1.push(new Ct(n$1, r$1.ref, `ref layer "${o$1}" not found`));
				} else if ("background" !== a$1) if (r$1.source) {
					const t$2 = i$1.sources && i$1.sources[r$1.source], s$2 = t$2 && Si(t$2.type);
					t$2 ? "vector" === s$2 && "raster" === a$1 ? e$1.push(new Ct(n$1, r$1.source, `layer "${r$1.id}" requires a raster source`)) : "raster-dem" !== s$2 && "hillshade" === a$1 || "raster-dem" !== s$2 && "color-relief" === a$1 ? e$1.push(new Ct(n$1, r$1.source, `layer "${r$1.id}" requires a raster-dem source`)) : "raster" === s$2 && "raster" !== a$1 ? e$1.push(new Ct(n$1, r$1.source, `layer "${r$1.id}" requires a vector source`)) : "vector" !== s$2 || r$1["source-layer"] ? "raster-dem" === s$2 && "hillshade" !== a$1 && "color-relief" !== a$1 ? e$1.push(new Ct(n$1, r$1.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== a$1 || !r$1.paint || !r$1.paint["line-gradient"] || "geojson" === s$2 && t$2.lineMetrics || e$1.push(new Ct(n$1, r$1, `layer "${r$1.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e$1.push(new Ct(n$1, r$1, `layer "${r$1.id}" must specify a "source-layer"`)) : e$1.push(new Ct(n$1, r$1.source, `source "${r$1.source}" not found`));
				} else e$1.push(new Ct(n$1, r$1, "missing required property \"source\""));
				return e$1 = e$1.concat(ki({
					key: n$1,
					value: r$1,
					valueSpec: s$1.layer,
					style: t$1.style,
					styleSpec: t$1.styleSpec,
					validateSpec: t$1.validateSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => t$1.validateSpec({
							key: `${n$1}.type`,
							value: r$1.type,
							valueSpec: s$1.layer.type,
							style: t$1.style,
							styleSpec: t$1.styleSpec,
							validateSpec: t$1.validateSpec,
							object: r$1,
							objectKey: "type"
						}),
						filter: Ti,
						layout: (t$2) => ki({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Di(Et({ layerType: a$1 }, t$3)) }
						}),
						paint: (t$2) => ki({
							layer: r$1,
							key: t$2.key,
							value: t$2.value,
							style: t$2.style,
							styleSpec: t$2.styleSpec,
							validateSpec: t$2.validateSpec,
							objectElementValidators: { "*": (t$3) => Fi(Et({ layerType: a$1 }, t$3)) }
						})
					}
				})), e$1;
			}
			function Li(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Gn(e$1);
				return "string" !== n$1 ? [new Ct(r$1, e$1, `string expected, ${n$1} found`)] : [];
			}
			const Oi = { promoteId: function({ key: t$1, value: e$1 }) {
				if ("string" === Gn(e$1)) return Li({
					key: t$1,
					value: e$1
				});
				{
					const r$1 = [];
					for (const n$1 in e$1) r$1.push(...Li({
						key: `${t$1}.${n$1}`,
						value: e$1[n$1]
					}));
					return r$1;
				}
			} };
			function Ri(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = t$1.styleSpec, i$1 = t$1.style, s$1 = t$1.validateSpec;
				if (!e$1.type) return [new Ct(r$1, e$1, "\"type\" is required")];
				const a$1 = Si(e$1.type);
				let o$1;
				switch (a$1) {
					case "vector":
					case "raster": return o$1 = ki({
						key: r$1,
						value: e$1,
						valueSpec: n$1[`source_${a$1.replace("-", "_")}`],
						style: t$1.style,
						styleSpec: n$1,
						objectElementValidators: Oi,
						validateSpec: s$1
					}), o$1;
					case "raster-dem": return o$1 = function(t$2) {
						var e$2;
						const r$2 = null !== (e$2 = t$2.sourceName) && void 0 !== e$2 ? e$2 : "", n$2 = t$2.value, i$2 = t$2.styleSpec, s$2 = i$2.source_raster_dem, a$2 = t$2.style;
						let o$2 = [];
						const l$1 = Gn(n$2);
						if (void 0 === n$2) return o$2;
						if ("object" !== l$1) return o$2.push(new Ct("source_raster_dem", n$2, `object expected, ${l$1} found`)), o$2;
						const u$1 = "custom" === Si(n$2.encoding), c$1 = [
							"redFactor",
							"greenFactor",
							"blueFactor",
							"baseShift"
						], h$1 = t$2.value.encoding ? `"${t$2.value.encoding}"` : "Default";
						for (const e$3 in n$2) !u$1 && c$1.includes(e$3) ? o$2.push(new Ct(e$3, n$2[e$3], `In "${r$2}": "${e$3}" is only valid when "encoding" is set to "custom". ${h$1} encoding found`)) : s$2[e$3] ? o$2 = o$2.concat(t$2.validateSpec({
							key: e$3,
							value: n$2[e$3],
							valueSpec: s$2[e$3],
							validateSpec: t$2.validateSpec,
							style: a$2,
							styleSpec: i$2
						})) : o$2.push(new Ct(e$3, n$2[e$3], `unknown property "${e$3}"`));
						return o$2;
					}({
						sourceName: r$1,
						value: e$1,
						style: t$1.style,
						styleSpec: n$1,
						validateSpec: s$1
					}), o$1;
					case "geojson":
						if (o$1 = ki({
							key: r$1,
							value: e$1,
							valueSpec: n$1.source_geojson,
							style: i$1,
							styleSpec: n$1,
							validateSpec: s$1,
							objectElementValidators: Oi
						}), e$1.cluster) for (const t$2 in e$1.clusterProperties) {
							const [n$2, i$2] = e$1.clusterProperties[t$2], s$2 = "string" == typeof n$2 ? [
								n$2,
								["accumulated"],
								["get", t$2]
							] : n$2;
							o$1.push(...Pi({
								key: `${r$1}.${t$2}.map`,
								value: i$2,
								expressionContext: "cluster-map"
							})), o$1.push(...Pi({
								key: `${r$1}.${t$2}.reduce`,
								value: s$2,
								expressionContext: "cluster-reduce"
							}));
						}
						return o$1;
					case "video": return ki({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_video,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "image": return ki({
						key: r$1,
						value: e$1,
						valueSpec: n$1.source_image,
						style: i$1,
						validateSpec: s$1,
						styleSpec: n$1
					});
					case "canvas": return [new Ct(r$1, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return Ei({
						key: `${r$1}.type`,
						value: e$1.type,
						valueSpec: { values: [
							"vector",
							"raster",
							"raster-dem",
							"geojson",
							"video",
							"image"
						] }
					});
				}
			}
			function Ui(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.light, i$1 = t$1.style;
				let s$1 = [];
				const a$1 = Gn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a$1) return s$1 = s$1.concat([new Ct("light", e$1, `object expected, ${a$1} found`)]), s$1;
				for (const a$2 in e$1) {
					const o$1 = a$2.match(/^(.*)-transition$/);
					s$1 = s$1.concat(o$1 && n$1[o$1[1]] && n$1[o$1[1]].transition ? t$1.validateSpec({
						key: a$2,
						value: e$1[a$2],
						valueSpec: r$1.transition,
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : n$1[a$2] ? t$1.validateSpec({
						key: a$2,
						value: e$1[a$2],
						valueSpec: n$1[a$2],
						validateSpec: t$1.validateSpec,
						style: i$1,
						styleSpec: r$1
					}) : [new Ct(a$2, e$1[a$2], `unknown property "${a$2}"`)]);
				}
				return s$1;
			}
			function ji(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.sky, i$1 = t$1.style, s$1 = Gn(e$1);
				if (void 0 === e$1) return [];
				if ("object" !== s$1) return [new Ct("sky", e$1, `object expected, ${s$1} found`)];
				let a$1 = [];
				for (const s$2 in e$1) a$1 = a$1.concat(n$1[s$2] ? t$1.validateSpec({
					key: s$2,
					value: e$1[s$2],
					valueSpec: n$1[s$2],
					style: i$1,
					styleSpec: r$1
				}) : [new Ct(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
				return a$1;
			}
			function Ni(t$1) {
				const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.terrain, i$1 = t$1.style;
				let s$1 = [];
				const a$1 = Gn(e$1);
				if (void 0 === e$1) return s$1;
				if ("object" !== a$1) return s$1 = s$1.concat([new Ct("terrain", e$1, `object expected, ${a$1} found`)]), s$1;
				for (const a$2 in e$1) s$1 = s$1.concat(n$1[a$2] ? t$1.validateSpec({
					key: a$2,
					value: e$1[a$2],
					valueSpec: n$1[a$2],
					validateSpec: t$1.validateSpec,
					style: i$1,
					styleSpec: r$1
				}) : [new Ct(a$2, e$1[a$2], `unknown property "${a$2}"`)]);
				return s$1;
			}
			function qi(t$1) {
				let e$1 = [];
				const r$1 = t$1.value, n$1 = t$1.key;
				if (Array.isArray(r$1)) {
					const i$1 = [], s$1 = [];
					for (const a$1 in r$1) r$1[a$1].id && i$1.includes(r$1[a$1].id) && e$1.push(new Ct(n$1, r$1, `all the sprites' ids must be unique, but ${r$1[a$1].id} is duplicated`)), i$1.push(r$1[a$1].id), r$1[a$1].url && s$1.includes(r$1[a$1].url) && e$1.push(new Ct(n$1, r$1, `all the sprites' URLs must be unique, but ${r$1[a$1].url} is duplicated`)), s$1.push(r$1[a$1].url), e$1 = e$1.concat(ki({
						key: `${n$1}[${a$1}]`,
						value: r$1[a$1],
						valueSpec: {
							id: {
								type: "string",
								required: !0
							},
							url: {
								type: "string",
								required: !0
							}
						},
						validateSpec: t$1.validateSpec
					}));
					return e$1;
				}
				return Li({
					key: n$1,
					value: r$1
				});
			}
			function Gi(t$1) {
				return e$1 = t$1.value, Boolean(e$1) && e$1.constructor === Object ? [] : [new Ct(t$1.key, t$1.value, `object expected, ${Gn(t$1.value)} found`)];
				var e$1;
			}
			const Xi = {
				"*": () => [],
				array: Mi,
				boolean: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.key, n$1 = Gn(e$1);
					return "boolean" !== n$1 ? [new Ct(r$1, e$1, `boolean expected, ${n$1} found`)] : [];
				},
				number: Ii,
				color: Ci,
				constants: _i,
				enum: Ei,
				filter: Ti,
				function: zi,
				layer: $i,
				object: ki,
				source: Ri,
				light: Ui,
				sky: ji,
				terrain: Ni,
				projection: function(t$1) {
					const e$1 = t$1.value, r$1 = t$1.styleSpec, n$1 = r$1.projection, i$1 = t$1.style, s$1 = Gn(e$1);
					if (void 0 === e$1) return [];
					if ("object" !== s$1) return [new Ct("projection", e$1, `object expected, ${s$1} found`)];
					let a$1 = [];
					for (const s$2 in e$1) a$1 = a$1.concat(n$1[s$2] ? t$1.validateSpec({
						key: s$2,
						value: e$1[s$2],
						valueSpec: n$1[s$2],
						style: i$1,
						styleSpec: r$1
					}) : [new Ct(s$2, e$1[s$2], `unknown property "${s$2}"`)]);
					return a$1;
				},
				projectionDefinition: function(t$1) {
					const e$1 = t$1.key;
					let r$1 = t$1.value;
					r$1 = r$1 instanceof String ? r$1.valueOf() : r$1;
					const n$1 = Gn(r$1);
					return "array" !== n$1 || function(t$2) {
						return Array.isArray(t$2) && 3 === t$2.length && "string" == typeof t$2[0] && "string" == typeof t$2[1] && "number" == typeof t$2[2];
					}(r$1) || function(t$2) {
						return !![
							"interpolate",
							"step",
							"literal"
						].includes(t$2[0]);
					}(r$1) ? ["array", "string"].includes(n$1) ? [] : [new Ct(e$1, r$1, `projection expected, invalid type "${n$1}" found`)] : [new Ct(e$1, r$1, `projection expected, invalid array ${JSON.stringify(r$1)} found`)];
				},
				string: Li,
				formatted: function(t$1) {
					return 0 === Li(t$1).length ? [] : Pi(t$1);
				},
				resolvedImage: function(t$1) {
					return 0 === Li(t$1).length ? [] : Pi(t$1);
				},
				padding: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						if (r$1.length < 1 || r$1.length > 4) return [new Ct(e$1, r$1, `padding requires 1 to 4 values; ${r$1.length} values found`)];
						const n$1 = { type: "number" };
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				numberArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						const n$1 = { type: "number" };
						if (r$1.length < 1) return [new Ct(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let i$1 = [];
						for (let s$1 = 0; s$1 < r$1.length; s$1++) i$1 = i$1.concat(t$1.validateSpec({
							key: `${e$1}[${s$1}]`,
							value: r$1[s$1],
							validateSpec: t$1.validateSpec,
							valueSpec: n$1
						}));
						return i$1;
					}
					return Ii({
						key: e$1,
						value: r$1,
						valueSpec: {}
					});
				},
				colorArray: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value;
					if ("array" === Gn(r$1)) {
						if (r$1.length < 1) return [new Ct(e$1, r$1, "array length at least 1 expected, length 0 found")];
						let t$2 = [];
						for (let n$1 = 0; n$1 < r$1.length; n$1++) t$2 = t$2.concat(Ci({
							key: `${e$1}[${n$1}]`,
							value: r$1[n$1]
						}));
						return t$2;
					}
					return Ci({
						key: e$1,
						value: r$1
					});
				},
				variableAnchorOffsetCollection: function(t$1) {
					const e$1 = t$1.key, r$1 = t$1.value, n$1 = Gn(r$1), i$1 = t$1.styleSpec;
					if ("array" !== n$1 || r$1.length < 1 || r$1.length % 2 != 0) return [new Ct(e$1, r$1, "variableAnchorOffsetCollection requires a non-empty array of even length")];
					let s$1 = [];
					for (let n$2 = 0; n$2 < r$1.length; n$2 += 2) s$1 = s$1.concat(Ei({
						key: `${e$1}[${n$2}]`,
						value: r$1[n$2],
						valueSpec: i$1.layout_symbol["text-anchor"]
					})), s$1 = s$1.concat(Mi({
						key: `${e$1}[${n$2 + 1}]`,
						value: r$1[n$2 + 1],
						valueSpec: {
							length: 2,
							value: "number"
						},
						validateSpec: t$1.validateSpec,
						style: t$1.style,
						styleSpec: i$1
					}));
					return s$1;
				},
				sprite: qi,
				state: Gi
			};
			function Zi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.valueSpec, n$1 = t$1.styleSpec;
				return t$1.validateSpec = Zi, r$1.expression && Xn(Si(e$1)) ? zi(t$1) : r$1.expression && ei(Ai(e$1)) ? Pi(t$1) : r$1.type && Xi[r$1.type] ? Xi[r$1.type](t$1) : ki(Et({}, t$1, { valueSpec: r$1.type ? n$1[r$1.type] : r$1 }));
			}
			function Yi(t$1) {
				const e$1 = t$1.value, r$1 = t$1.key, n$1 = Li(t$1);
				return n$1.length || (-1 === e$1.indexOf("{fontstack}") && n$1.push(new Ct(r$1, e$1, "\"glyphs\" url must include a \"{fontstack}\" token")), -1 === e$1.indexOf("{range}") && n$1.push(new Ct(r$1, e$1, "\"glyphs\" url must include a \"{range}\" token"))), n$1;
			}
			function Hi(t$1, e$1 = xt) {
				let r$1 = [];
				return r$1 = r$1.concat(Zi({
					key: "",
					value: t$1,
					valueSpec: e$1.$root,
					styleSpec: e$1,
					style: t$1,
					validateSpec: Zi,
					objectElementValidators: {
						glyphs: Yi,
						"*": () => []
					}
				})), t$1.constants && (r$1 = r$1.concat(_i({
					key: "constants",
					value: t$1.constants
				}))), Ji(r$1);
			}
			function Ki(t$1) {
				return function(e$1) {
					return t$1(Object.assign({}, e$1, { validateSpec: Zi }));
				};
			}
			function Ji(t$1) {
				return [].concat(t$1).sort(((t$2, e$1) => t$2.line - e$1.line));
			}
			function Wi(t$1) {
				return function(...e$1) {
					return Ji(t$1.apply(this, e$1));
				};
			}
			Hi.source = Wi(Ki(Ri)), Hi.sprite = Wi(Ki(qi)), Hi.glyphs = Wi(Ki(Yi)), Hi.light = Wi(Ki(Ui)), Hi.sky = Wi(Ki(ji)), Hi.terrain = Wi(Ki(Ni)), Hi.state = Wi(Ki(Gi)), Hi.layer = Wi(Ki($i)), Hi.filter = Wi(Ki(Ti)), Hi.paintProperty = Wi(Ki(Fi)), Hi.layoutProperty = Wi(Ki(Di));
			const Qi = Hi, ts = Qi.light, es = Qi.sky, rs = Qi.paintProperty, ns = Qi.layoutProperty;
			function is(t$1, e$1) {
				let r$1 = !1;
				if (e$1 && e$1.length) for (const n$1 of e$1) t$1.fire(new mt(new Error(n$1.message))), r$1 = !0;
				return r$1;
			}
			class ss {
				constructor(t$1, e$1, r$1) {
					const n$1 = this.cells = [];
					if (t$1 instanceof ArrayBuffer) {
						this.arrayBuffer = t$1;
						const i$2 = new Int32Array(this.arrayBuffer);
						t$1 = i$2[0], this.d = (e$1 = i$2[1]) + 2 * (r$1 = i$2[2]);
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) {
							const e$2 = i$2[3 + t$2], r$2 = i$2[3 + t$2 + 1];
							n$1.push(e$2 === r$2 ? null : i$2.subarray(e$2, r$2));
						}
						const s$1 = i$2[3 + n$1.length + 1];
						this.keys = i$2.subarray(i$2[3 + n$1.length], s$1), this.bboxes = i$2.subarray(s$1), this.insert = this._insertReadonly;
					} else {
						this.d = e$1 + 2 * r$1;
						for (let t$2 = 0; t$2 < this.d * this.d; t$2++) n$1.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = e$1, this.extent = t$1, this.padding = r$1, this.scale = e$1 / t$1, this.uid = 0;
					const i$1 = r$1 / e$1 * t$1;
					this.min = -i$1, this.max = t$1 + i$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1) {
					this._forEachCell(e$1, r$1, n$1, i$1, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t$1), this.bboxes.push(e$1), this.bboxes.push(r$1), this.bboxes.push(n$1), this.bboxes.push(i$1);
				}
				_insertReadonly() {
					throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
				}
				_insertCell(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.cells[i$1].push(s$1);
				}
				query(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.min, a$1 = this.max;
					if (t$1 <= s$1 && e$1 <= s$1 && a$1 <= r$1 && a$1 <= n$1 && !i$1) return Array.prototype.slice.call(this.keys);
					{
						const s$2 = [];
						return this._forEachCell(t$1, e$1, r$1, n$1, this._queryCell, s$2, {}, i$1), s$2;
					}
				}
				_queryCell(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = this.cells[i$1];
					if (null !== l$1) {
						const i$2 = this.keys, u$1 = this.bboxes;
						for (let c$1 = 0; c$1 < l$1.length; c$1++) {
							const h$1 = l$1[c$1];
							if (void 0 === a$1[h$1]) {
								const l$2 = 4 * h$1;
								(o$1 ? o$1(u$1[l$2 + 0], u$1[l$2 + 1], u$1[l$2 + 2], u$1[l$2 + 3]) : t$1 <= u$1[l$2 + 2] && e$1 <= u$1[l$2 + 3] && r$1 >= u$1[l$2 + 0] && n$1 >= u$1[l$2 + 1]) ? (a$1[h$1] = !0, s$1.push(i$2[h$1])) : a$1[h$1] = !1;
							}
						}
					}
				}
				_forEachCell(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = this._convertToCellCoord(t$1), u$1 = this._convertToCellCoord(e$1), c$1 = this._convertToCellCoord(r$1), h$1 = this._convertToCellCoord(n$1);
					for (let p$1 = l$1; p$1 <= c$1; p$1++) for (let l$2 = u$1; l$2 <= h$1; l$2++) {
						const u$2 = this.d * l$2 + p$1;
						if ((!o$1 || o$1(this._convertFromCellCoord(p$1), this._convertFromCellCoord(l$2), this._convertFromCellCoord(p$1 + 1), this._convertFromCellCoord(l$2 + 1))) && i$1.call(this, t$1, e$1, r$1, n$1, u$2, s$1, a$1, o$1)) return;
					}
				}
				_convertFromCellCoord(t$1) {
					return (t$1 - this.padding) / this.scale;
				}
				_convertToCellCoord(t$1) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(t$1 * this.scale) + this.padding));
				}
				toArrayBuffer() {
					if (this.arrayBuffer) return this.arrayBuffer;
					const t$1 = this.cells, e$1 = 3 + this.cells.length + 1 + 1;
					let r$1 = 0;
					for (let t$2 = 0; t$2 < this.cells.length; t$2++) r$1 += this.cells[t$2].length;
					const n$1 = new Int32Array(e$1 + r$1 + this.keys.length + this.bboxes.length);
					n$1[0] = this.extent, n$1[1] = this.n, n$1[2] = this.padding;
					let i$1 = e$1;
					for (let e$2 = 0; e$2 < t$1.length; e$2++) {
						const r$2 = t$1[e$2];
						n$1[3 + e$2] = i$1, n$1.set(r$2, i$1), i$1 += r$2.length;
					}
					return n$1[3 + t$1.length] = i$1, n$1.set(this.keys, i$1), i$1 += this.keys.length, n$1[3 + t$1.length + 1] = i$1, n$1.set(this.bboxes, i$1), i$1 += this.bboxes.length, n$1.buffer;
				}
				static serialize(t$1, e$1) {
					const r$1 = t$1.toArrayBuffer();
					return e$1 && e$1.push(r$1), { buffer: r$1 };
				}
				static deserialize(t$1) {
					return new ss(t$1.buffer);
				}
			}
			const as = {};
			function os(t$1, e$1, r$1 = {}) {
				if (as[t$1]) throw new Error(`${t$1} is already registered.`);
				Object.defineProperty(e$1, "_classRegistryKey", {
					value: t$1,
					writeable: !1
				}), as[t$1] = {
					klass: e$1,
					omit: r$1.omit || [],
					shallow: r$1.shallow || []
				};
			}
			os("Object", Object), os("Set", Set), os("TransferableGridIndex", ss), os("Color", Me), os("Error", Error), os("AJAXError", ut), os("ResolvedImage", $e), os("StylePropertyFunction", ai), os("StyleExpression", ti, { omit: ["_evaluator"] }), os("ZoomDependentExpression", ii), os("ZoomConstantExpression", ni), os("CompoundExpression", En, { omit: ["_evaluate"] });
			for (const t$1 in Cn) Cn[t$1]._classRegistryKey || os(`Expression_${t$1}`, Cn[t$1]);
			function ls(t$1) {
				return t$1 && "undefined" != typeof ArrayBuffer && (t$1 instanceof ArrayBuffer || t$1.constructor && "ArrayBuffer" === t$1.constructor.name);
			}
			function us(t$1) {
				return t$1.$name || t$1.constructor._classRegistryKey;
			}
			function cs(t$1) {
				return !function(t$2) {
					if (null === t$2 || "object" != typeof t$2) return !1;
					const e$1 = us(t$2);
					return !(!e$1 || "Object" === e$1);
				}(t$1) && (null == t$1 || "boolean" == typeof t$1 || "number" == typeof t$1 || "string" == typeof t$1 || t$1 instanceof Boolean || t$1 instanceof Number || t$1 instanceof String || t$1 instanceof Date || t$1 instanceof RegExp || t$1 instanceof Blob || t$1 instanceof Error || ls(t$1) || Y(t$1) || ArrayBuffer.isView(t$1) || t$1 instanceof ImageData);
			}
			function hs(t$1, e$1) {
				if (cs(t$1)) return (ls(t$1) || Y(t$1)) && e$1 && e$1.push(t$1), ArrayBuffer.isView(t$1) && e$1 && e$1.push(t$1.buffer), t$1 instanceof ImageData && e$1 && e$1.push(t$1.data.buffer), t$1;
				if (Array.isArray(t$1)) {
					const r$2 = [];
					for (const n$2 of t$1) r$2.push(hs(n$2, e$1));
					return r$2;
				}
				if ("object" != typeof t$1) throw new Error("can't serialize object of type " + typeof t$1);
				const r$1 = us(t$1);
				if (!r$1) throw new Error(`can't serialize object of unregistered class ${t$1.constructor.name}`);
				if (!as[r$1]) throw new Error(`${r$1} is not registered.`);
				const { klass: n$1 } = as[r$1], i$1 = n$1.serialize ? n$1.serialize(t$1, e$1) : {};
				if (n$1.serialize) {
					if (e$1 && i$1 === e$1[e$1.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
				} else {
					for (const n$2 in t$1) {
						if (!t$1.hasOwnProperty(n$2)) continue;
						if (as[r$1].omit.indexOf(n$2) >= 0) continue;
						const s$1 = t$1[n$2];
						i$1[n$2] = as[r$1].shallow.indexOf(n$2) >= 0 ? s$1 : hs(s$1, e$1);
					}
					t$1 instanceof Error && (i$1.message = t$1.message);
				}
				if (i$1.$name) throw new Error("$name property is reserved for worker serialization logic.");
				return "Object" !== r$1 && (i$1.$name = r$1), i$1;
			}
			function ps(t$1) {
				if (cs(t$1)) return t$1;
				if (Array.isArray(t$1)) return t$1.map(ps);
				if ("object" != typeof t$1) throw new Error("can't deserialize object of type " + typeof t$1);
				const e$1 = us(t$1) || "Object";
				if (!as[e$1]) throw new Error(`can't deserialize unregistered class ${e$1}`);
				const { klass: r$1 } = as[e$1];
				if (!r$1) throw new Error(`can't deserialize unregistered class ${e$1}`);
				if (r$1.deserialize) return r$1.deserialize(t$1);
				const n$1 = Object.create(r$1.prototype);
				for (const r$2 of Object.keys(t$1)) {
					if ("$name" === r$2) continue;
					const i$1 = t$1[r$2];
					n$1[r$2] = as[e$1].shallow.indexOf(r$2) >= 0 ? i$1 : ps(i$1);
				}
				return n$1;
			}
			class fs {
				constructor() {
					this.first = !0;
				}
				update(t$1, e$1) {
					const r$1 = Math.floor(t$1);
					return this.first ? (this.first = !1, this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = 0, this.lastZoom = t$1, this.lastFloorZoom = r$1, !0) : (this.lastFloorZoom > r$1 ? (this.lastIntegerZoom = r$1 + 1, this.lastIntegerZoomTime = e$1) : this.lastFloorZoom < r$1 && (this.lastIntegerZoom = r$1, this.lastIntegerZoomTime = e$1), t$1 !== this.lastZoom && (this.lastZoom = t$1, this.lastFloorZoom = r$1, !0));
				}
			}
			const ds = {
				"Latin-1 Supplement": (t$1) => t$1 >= 128 && t$1 <= 255,
				"Hangul Jamo": (t$1) => t$1 >= 4352 && t$1 <= 4607,
				Khmer: (t$1) => t$1 >= 6016 && t$1 <= 6143,
				"General Punctuation": (t$1) => t$1 >= 8192 && t$1 <= 8303,
				"Letterlike Symbols": (t$1) => t$1 >= 8448 && t$1 <= 8527,
				"Number Forms": (t$1) => t$1 >= 8528 && t$1 <= 8591,
				"Miscellaneous Technical": (t$1) => t$1 >= 8960 && t$1 <= 9215,
				"Control Pictures": (t$1) => t$1 >= 9216 && t$1 <= 9279,
				"Optical Character Recognition": (t$1) => t$1 >= 9280 && t$1 <= 9311,
				"Enclosed Alphanumerics": (t$1) => t$1 >= 9312 && t$1 <= 9471,
				"Geometric Shapes": (t$1) => t$1 >= 9632 && t$1 <= 9727,
				"Miscellaneous Symbols": (t$1) => t$1 >= 9728 && t$1 <= 9983,
				"Miscellaneous Symbols and Arrows": (t$1) => t$1 >= 11008 && t$1 <= 11263,
				"Ideographic Description Characters": (t$1) => t$1 >= 12272 && t$1 <= 12287,
				"CJK Symbols and Punctuation": (t$1) => t$1 >= 12288 && t$1 <= 12351,
				Hiragana: (t$1) => t$1 >= 12352 && t$1 <= 12447,
				Katakana: (t$1) => t$1 >= 12448 && t$1 <= 12543,
				Kanbun: (t$1) => t$1 >= 12688 && t$1 <= 12703,
				"CJK Strokes": (t$1) => t$1 >= 12736 && t$1 <= 12783,
				"Enclosed CJK Letters and Months": (t$1) => t$1 >= 12800 && t$1 <= 13055,
				"CJK Compatibility": (t$1) => t$1 >= 13056 && t$1 <= 13311,
				"Yijing Hexagram Symbols": (t$1) => t$1 >= 19904 && t$1 <= 19967,
				"CJK Unified Ideographs": (t$1) => t$1 >= 19968 && t$1 <= 40959,
				"Hangul Syllables": (t$1) => t$1 >= 44032 && t$1 <= 55215,
				"Private Use Area": (t$1) => t$1 >= 57344 && t$1 <= 63743,
				"Vertical Forms": (t$1) => t$1 >= 65040 && t$1 <= 65055,
				"CJK Compatibility Forms": (t$1) => t$1 >= 65072 && t$1 <= 65103,
				"Small Form Variants": (t$1) => t$1 >= 65104 && t$1 <= 65135,
				"Halfwidth and Fullwidth Forms": (t$1) => t$1 >= 65280 && t$1 <= 65519
			};
			function ys(t$1) {
				for (const e$1 of t$1) if (ws(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			function ms(t$1) {
				for (const e$1 of t$1) if (!vs(e$1.charCodeAt(0))) return !1;
				return !0;
			}
			function gs(t$1) {
				const e$1 = t$1.map(((t$2) => {
					try {
						return new RegExp(`\\p{sc=${t$2}}`, "u").source;
					} catch (t$3) {
						return null;
					}
				})).filter(((t$2) => t$2));
				return new RegExp(e$1.join("|"), "u");
			}
			const xs = gs([
				"Arab",
				"Dupl",
				"Mong",
				"Ougr",
				"Syrc"
			]);
			function vs(t$1) {
				return !xs.test(String.fromCodePoint(t$1));
			}
			const bs = gs([
				"Bopo",
				"Hani",
				"Hira",
				"Kana",
				"Kits",
				"Nshu",
				"Tang",
				"Yiii"
			]);
			function ws(t$1) {
				return !(746 !== t$1 && 747 !== t$1 && (t$1 < 4352 || !(ds["CJK Compatibility Forms"](t$1) && !(t$1 >= 65097 && t$1 <= 65103) || ds["CJK Compatibility"](t$1) || ds["CJK Strokes"](t$1) || !(!ds["CJK Symbols and Punctuation"](t$1) || t$1 >= 12296 && t$1 <= 12305 || t$1 >= 12308 && t$1 <= 12319 || 12336 === t$1) || ds["Enclosed CJK Letters and Months"](t$1) || ds["Ideographic Description Characters"](t$1) || ds.Kanbun(t$1) || ds.Katakana(t$1) && 12540 !== t$1 || !(!ds["Halfwidth and Fullwidth Forms"](t$1) || 65288 === t$1 || 65289 === t$1 || 65293 === t$1 || t$1 >= 65306 && t$1 <= 65310 || 65339 === t$1 || 65341 === t$1 || 65343 === t$1 || t$1 >= 65371 && t$1 <= 65503 || 65507 === t$1 || t$1 >= 65512 && t$1 <= 65519) || !(!ds["Small Form Variants"](t$1) || t$1 >= 65112 && t$1 <= 65118 || t$1 >= 65123 && t$1 <= 65126) || ds["Vertical Forms"](t$1) || ds["Yijing Hexagram Symbols"](t$1) || /\p{sc=Cans}/u.test(String.fromCodePoint(t$1)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t$1)) || bs.test(String.fromCodePoint(t$1)))));
			}
			function _s(t$1) {
				return !(ws(t$1) || function(t$2) {
					return !!(ds["Latin-1 Supplement"](t$2) && (167 === t$2 || 169 === t$2 || 174 === t$2 || 177 === t$2 || 188 === t$2 || 189 === t$2 || 190 === t$2 || 215 === t$2 || 247 === t$2) || ds["General Punctuation"](t$2) && (8214 === t$2 || 8224 === t$2 || 8225 === t$2 || 8240 === t$2 || 8241 === t$2 || 8251 === t$2 || 8252 === t$2 || 8258 === t$2 || 8263 === t$2 || 8264 === t$2 || 8265 === t$2 || 8273 === t$2) || ds["Letterlike Symbols"](t$2) || ds["Number Forms"](t$2) || ds["Miscellaneous Technical"](t$2) && (t$2 >= 8960 && t$2 <= 8967 || t$2 >= 8972 && t$2 <= 8991 || t$2 >= 8996 && t$2 <= 9e3 || 9003 === t$2 || t$2 >= 9085 && t$2 <= 9114 || t$2 >= 9150 && t$2 <= 9165 || 9167 === t$2 || t$2 >= 9169 && t$2 <= 9179 || t$2 >= 9186 && t$2 <= 9215) || ds["Control Pictures"](t$2) && 9251 !== t$2 || ds["Optical Character Recognition"](t$2) || ds["Enclosed Alphanumerics"](t$2) || ds["Geometric Shapes"](t$2) || ds["Miscellaneous Symbols"](t$2) && !(t$2 >= 9754 && t$2 <= 9759) || ds["Miscellaneous Symbols and Arrows"](t$2) && (t$2 >= 11026 && t$2 <= 11055 || t$2 >= 11088 && t$2 <= 11097 || t$2 >= 11192 && t$2 <= 11243) || ds["CJK Symbols and Punctuation"](t$2) || ds.Katakana(t$2) || ds["Private Use Area"](t$2) || ds["CJK Compatibility Forms"](t$2) || ds["Small Form Variants"](t$2) || ds["Halfwidth and Fullwidth Forms"](t$2) || 8734 === t$2 || 8756 === t$2 || 8757 === t$2 || t$2 >= 9984 && t$2 <= 10087 || t$2 >= 10102 && t$2 <= 10131 || 65532 === t$2 || 65533 === t$2);
				}(t$1));
			}
			const Ss = gs([
				"Adlm",
				"Arab",
				"Armi",
				"Avst",
				"Chrs",
				"Cprt",
				"Egyp",
				"Elym",
				"Gara",
				"Hatr",
				"Hebr",
				"Hung",
				"Khar",
				"Lydi",
				"Mand",
				"Mani",
				"Mend",
				"Merc",
				"Mero",
				"Narb",
				"Nbat",
				"Nkoo",
				"Orkh",
				"Palm",
				"Phli",
				"Phlp",
				"Phnx",
				"Prti",
				"Rohg",
				"Samr",
				"Sarb",
				"Sogo",
				"Syrc",
				"Thaa",
				"Todr",
				"Yezi"
			]);
			function As(t$1) {
				return Ss.test(String.fromCodePoint(t$1));
			}
			function ks(t$1, e$1) {
				return !(!e$1 && As(t$1) || t$1 >= 2304 && t$1 <= 3583 || t$1 >= 3840 && t$1 <= 4255 || ds.Khmer(t$1));
			}
			function Ms(t$1) {
				for (const e$1 of t$1) if (As(e$1.charCodeAt(0))) return !0;
				return !1;
			}
			const Is = new class {
				constructor() {
					this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {};
				}
				setState(t$1) {
					this.pluginStatus = t$1.pluginStatus, this.pluginURL = t$1.pluginURL;
				}
				getState() {
					return {
						pluginStatus: this.pluginStatus,
						pluginURL: this.pluginURL
					};
				}
				setMethods(t$1) {
					if (Is.isParsed()) throw new Error("RTL text plugin already registered.");
					this.applyArabicShaping = t$1.applyArabicShaping, this.processBidirectionalText = t$1.processBidirectionalText, this.processStyledBidirectionalText = t$1.processStyledBidirectionalText, this.loadScriptResolve();
				}
				isParsed() {
					return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
				}
				getRTLTextPluginStatus() {
					return this.pluginStatus;
				}
				syncState(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if (this.isParsed()) return this.getState();
						if ("loading" !== t$1.pluginStatus) return this.setState(t$1), t$1;
						const e$1 = t$1.pluginURL, n$1 = new Promise(((t$2) => {
							this.loadScriptResolve = t$2;
						}));
						r$1(e$1);
						const i$1 = new Promise(((t$2) => setTimeout((() => t$2()), this.TIMEOUT)));
						if (yield Promise.race([n$1, i$1]), this.isParsed()) {
							const t$2 = {
								pluginStatus: "loaded",
								pluginURL: e$1
							};
							return this.setState(t$2), t$2;
						}
						throw this.setState({
							pluginStatus: "error",
							pluginURL: ""
						}), /* @__PURE__ */ new Error(`RTL Text Plugin failed to import scripts from ${e$1}`);
					}));
				}
			}();
			class zs {
				constructor(t$1, e$1) {
					this.isSupportedScript = Ps, this.zoom = t$1, e$1 ? (this.now = e$1.now || 0, this.fadeDuration = e$1.fadeDuration || 0, this.zoomHistory = e$1.zoomHistory || new fs(), this.transition = e$1.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new fs(), this.transition = {});
				}
				crossFadingFactor() {
					return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
				}
				getCrossfadeParameters() {
					const t$1 = this.zoom, e$1 = t$1 - Math.floor(t$1), r$1 = this.crossFadingFactor();
					return t$1 > this.zoomHistory.lastIntegerZoom ? {
						fromScale: 2,
						toScale: 1,
						t: e$1 + (1 - e$1) * r$1
					} : {
						fromScale: .5,
						toScale: 1,
						t: 1 - (1 - r$1) * e$1
					};
				}
			}
			function Ps(t$1) {
				return function(t$2, e$1) {
					for (const r$1 of t$2) if (!ks(r$1.charCodeAt(0), e$1)) return !1;
					return !0;
				}(t$1, "loaded" === Is.getRTLTextPluginStatus());
			}
			class Cs {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.expression = function(t$2, e$2, r$2) {
						if (Xn(t$2)) return new ai(t$2, e$2);
						if (ei(t$2)) {
							const n$1 = si(t$2, e$2, r$2);
							if ("error" === n$1.result) throw new Error(n$1.value.map(((t$3) => `${t$3.key}: ${t$3.message}`)).join(", "));
							return n$1.value;
						}
						{
							let r$3 = t$2;
							return "color" === e$2.type && "string" == typeof t$2 ? r$3 = Me.parse(t$2) : "padding" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "numberArray" !== e$2.type || "number" != typeof t$2 && !Array.isArray(t$2) ? "colorArray" !== e$2.type || "string" != typeof t$2 && !Array.isArray(t$2) ? "variableAnchorOffsetCollection" === e$2.type && Array.isArray(t$2) ? r$3 = De.parse(t$2) : "projectionDefinition" === e$2.type && "string" == typeof t$2 && (r$3 = Le.parse(t$2)) : r$3 = Be.parse(t$2) : r$3 = Te.parse(t$2) : r$3 = Ee.parse(t$2), {
								globalStateRefs: /* @__PURE__ */ new Set(),
								_globalState: null,
								kind: "constant",
								evaluate: () => r$3
							};
						}
					}(void 0 === e$1 ? t$1.specification.default : e$1, t$1.specification, r$1);
				}
				isDataDriven() {
					return "source" === this.expression.kind || "composite" === this.expression.kind;
				}
				getGlobalStateRefs() {
					return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					return this.property.possiblyEvaluate(this, t$1, e$1, r$1);
				}
			}
			class Es {
				constructor(t$1, e$1) {
					this.property = t$1, this.value = new Cs(t$1, void 0, e$1);
				}
				transitioned(t$1, e$1) {
					return new Bs(this.property, this.value, e$1, L({}, t$1.transition, this.transition), t$1.now);
				}
				untransitioned() {
					return new Bs(this.property, this.value, null, {}, 0);
				}
			}
			class Ts {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitionablePropertyValues), this._globalState = e$1;
				}
				getValue(t$1) {
					return j(this._values[t$1].value.value);
				}
				setValue(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Es(this._values[t$1].property, this._globalState)), this._values[t$1].value = new Cs(this._values[t$1].property, null === e$1 ? void 0 : j(e$1), this._globalState);
				}
				getTransition(t$1) {
					return j(this._values[t$1].transition);
				}
				setTransition(t$1, e$1) {
					Object.prototype.hasOwnProperty.call(this._values, t$1) || (this._values[t$1] = new Es(this._values[t$1].property, this._globalState)), this._values[t$1].transition = j(e$1) || void 0;
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
						const n$1 = this.getTransition(e$1);
						void 0 !== n$1 && (t$1[`${e$1}-transition`] = n$1);
					}
					return t$1;
				}
				transitioned(t$1, e$1) {
					const r$1 = new Vs(this._properties);
					for (const n$1 of Object.keys(this._values)) r$1._values[n$1] = this._values[n$1].transitioned(t$1, e$1._values[n$1]);
					return r$1;
				}
				untransitioned() {
					const t$1 = new Vs(this._properties);
					for (const e$1 of Object.keys(this._values)) t$1._values[e$1] = this._values[e$1].untransitioned();
					return t$1;
				}
			}
			class Bs {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.property = t$1, this.value = e$1, this.begin = i$1 + n$1.delay || 0, this.end = this.begin + n$1.duration || 0, t$1.specification.transition && (n$1.delay || n$1.duration) && (this.prior = r$1);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = t$1.now || 0, i$1 = this.value.possiblyEvaluate(t$1, e$1, r$1), s$1 = this.prior;
					if (s$1) {
						if (n$1 > this.end) return this.prior = null, i$1;
						if (this.value.isDataDriven()) return this.prior = null, i$1;
						if (n$1 < this.begin) return s$1.possiblyEvaluate(t$1, e$1, r$1);
						{
							const a$1 = (n$1 - this.begin) / (this.end - this.begin);
							return this.property.interpolate(s$1.possiblyEvaluate(t$1, e$1, r$1), i$1, B(a$1));
						}
					}
					return i$1;
				}
			}
			class Vs {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new $s(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
				hasTransition() {
					for (const t$1 of Object.keys(this._values)) if (this._values[t$1].prior) return !0;
					return !1;
				}
			}
			class Fs {
				constructor(t$1, e$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPropertyValues), this._globalState = e$1;
				}
				hasValue(t$1) {
					return void 0 !== this._values[t$1].value;
				}
				getValue(t$1) {
					return j(this._values[t$1].value);
				}
				setValue(t$1, e$1) {
					this._values[t$1] = new Cs(this._values[t$1].property, null === e$1 ? void 0 : j(e$1), this._globalState);
				}
				serialize() {
					const t$1 = {};
					for (const e$1 of Object.keys(this._values)) {
						const r$1 = this.getValue(e$1);
						void 0 !== r$1 && (t$1[e$1] = r$1);
					}
					return t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1) {
					const n$1 = new $s(this._properties);
					for (const i$1 of Object.keys(this._values)) n$1._values[i$1] = this._values[i$1].possiblyEvaluate(t$1, e$1, r$1);
					return n$1;
				}
			}
			class Ds {
				constructor(t$1, e$1, r$1) {
					this.property = t$1, this.value = e$1, this.parameters = r$1;
				}
				isConstant() {
					return "constant" === this.value.kind;
				}
				constantOr(t$1) {
					return "constant" === this.value.kind ? this.value.value : t$1;
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return this.property.evaluate(this.value, this.parameters, t$1, e$1, r$1, n$1);
				}
			}
			class $s {
				constructor(t$1) {
					this._properties = t$1, this._values = Object.create(t$1.defaultPossiblyEvaluatedValues);
				}
				get(t$1) {
					return this._values[t$1];
				}
			}
			class Ls {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1) {
					if (t$1.isDataDriven()) throw new Error("Value should not be data driven");
					return t$1.expression.evaluate(e$1);
				}
				interpolate(t$1, e$1, r$1) {
					const n$1 = dr[this.specification.type];
					return n$1 ? n$1(t$1, e$1, r$1) : t$1;
				}
			}
			class Os {
				constructor(t$1, e$1) {
					this.specification = t$1, this.overrides = e$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return new Ds(this, "constant" === t$1.expression.kind || "camera" === t$1.expression.kind ? {
						kind: "constant",
						value: t$1.expression.evaluate(e$1, null, {}, r$1, n$1)
					} : t$1.expression, e$1);
				}
				interpolate(t$1, e$1, r$1) {
					if ("constant" !== t$1.value.kind || "constant" !== e$1.value.kind) return t$1;
					if (void 0 === t$1.value.value || void 0 === e$1.value.value) return new Ds(this, {
						kind: "constant",
						value: void 0
					}, t$1.parameters);
					const n$1 = dr[this.specification.type];
					if (n$1) {
						const i$1 = n$1(t$1.value.value, e$1.value.value, r$1);
						return new Ds(this, {
							kind: "constant",
							value: i$1
						}, t$1.parameters);
					}
					return t$1;
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					return "constant" === t$1.kind ? t$1.value : t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
				}
			}
			class Rs extends Os {
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 === t$1.value) return new Ds(this, {
						kind: "constant",
						value: void 0
					}, e$1);
					if ("constant" === t$1.expression.kind) {
						const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1), s$1 = "resolvedImage" === t$1.property.specification.type && "string" != typeof i$1 ? i$1.name : i$1, a$1 = this._calculate(s$1, s$1, s$1, e$1);
						return new Ds(this, {
							kind: "constant",
							value: a$1
						}, e$1);
					}
					if ("camera" === t$1.expression.kind) {
						const r$2 = this._calculate(t$1.expression.evaluate({ zoom: e$1.zoom - 1 }), t$1.expression.evaluate({ zoom: e$1.zoom }), t$1.expression.evaluate({ zoom: e$1.zoom + 1 }), e$1);
						return new Ds(this, {
							kind: "constant",
							value: r$2
						}, e$1);
					}
					return new Ds(this, t$1.expression, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1, i$1, s$1) {
					if ("source" === t$1.kind) {
						const a$1 = t$1.evaluate(e$1, r$1, n$1, i$1, s$1);
						return this._calculate(a$1, a$1, a$1, e$1);
					}
					return "composite" === t$1.kind ? this._calculate(t$1.evaluate({ zoom: Math.floor(e$1.zoom) - 1 }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) }, r$1, n$1), t$1.evaluate({ zoom: Math.floor(e$1.zoom) + 1 }, r$1, n$1), e$1) : t$1.value;
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class Us {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					if (void 0 !== t$1.value) {
						if ("constant" === t$1.expression.kind) {
							const i$1 = t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
							return this._calculate(i$1, i$1, i$1, e$1);
						}
						return this._calculate(t$1.expression.evaluate(new zs(Math.floor(e$1.zoom - 1), e$1)), t$1.expression.evaluate(new zs(Math.floor(e$1.zoom), e$1)), t$1.expression.evaluate(new zs(Math.floor(e$1.zoom + 1), e$1)), e$1);
					}
				}
				_calculate(t$1, e$1, r$1, n$1) {
					return n$1.zoom > n$1.zoomHistory.lastIntegerZoom ? {
						from: t$1,
						to: e$1
					} : {
						from: r$1,
						to: e$1
					};
				}
				interpolate(t$1) {
					return t$1;
				}
			}
			class js {
				constructor(t$1) {
					this.specification = t$1;
				}
				possiblyEvaluate(t$1, e$1, r$1, n$1) {
					return !!t$1.expression.evaluate(e$1, null, {}, r$1, n$1);
				}
				interpolate() {
					return !1;
				}
			}
			class Ns {
				constructor(t$1) {
					this.properties = t$1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
					for (const e$1 in t$1) {
						const r$1 = t$1[e$1];
						r$1.specification.overridable && this.overridableProperties.push(e$1);
						const n$1 = this.defaultPropertyValues[e$1] = new Cs(r$1, void 0, void 0), i$1 = this.defaultTransitionablePropertyValues[e$1] = new Es(r$1, void 0);
						this.defaultTransitioningPropertyValues[e$1] = i$1.untransitioned(), this.defaultPossiblyEvaluatedValues[e$1] = n$1.possiblyEvaluate({});
					}
				}
			}
			os("DataDrivenProperty", Os), os("DataConstantProperty", Ls), os("CrossFadedDataDrivenProperty", Rs), os("CrossFadedProperty", Us), os("ColorRampProperty", js);
			const qs = "-transition";
			class Gs extends gt {
				constructor(t$1, e$1, r$1) {
					if (super(), this.id = t$1.id, this.type = t$1.type, this._globalState = r$1, this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						getGlobalStateRefs: () => /* @__PURE__ */ new Set()
					}, "custom" !== t$1.type && (this.metadata = t$1.metadata, this.minzoom = t$1.minzoom, this.maxzoom = t$1.maxzoom, "background" !== t$1.type && (this.source = t$1.source, this.sourceLayer = t$1["source-layer"], this.filter = t$1.filter, this._featureFilter = pi(t$1.filter, r$1)), e$1.layout && (this._unevaluatedLayout = new Fs(e$1.layout, r$1)), e$1.paint)) {
						this._transitionablePaint = new Ts(e$1.paint, r$1);
						for (const e$2 in t$1.paint) this.setPaintProperty(e$2, t$1.paint[e$2], { validate: !1 });
						for (const e$2 in t$1.layout) this.setLayoutProperty(e$2, t$1.layout[e$2], { validate: !1 });
						this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new $s(e$1.paint);
					}
				}
				setFilter(t$1) {
					this.filter = t$1, this._featureFilter = pi(t$1, this._globalState);
				}
				getCrossfadeParameters() {
					return this._crossfadeParameters;
				}
				getLayoutProperty(t$1) {
					return "visibility" === t$1 ? this.visibility : this._unevaluatedLayout.getValue(t$1);
				}
				getLayoutAffectingGlobalStateRefs() {
					const t$1 = /* @__PURE__ */ new Set();
					if (this._unevaluatedLayout) for (const e$1 in this._unevaluatedLayout._values) {
						const r$1 = this._unevaluatedLayout._values[e$1];
						for (const e$2 of r$1.getGlobalStateRefs()) t$1.add(e$2);
					}
					for (const e$1 of this._featureFilter.getGlobalStateRefs()) t$1.add(e$1);
					return t$1;
				}
				getPaintAffectingGlobalStateRefs() {
					var t$1;
					const e$1 = new globalThis.Map();
					if (this._transitionablePaint) for (const r$1 in this._transitionablePaint._values) {
						const n$1 = this._transitionablePaint._values[r$1].value;
						for (const i$1 of n$1.getGlobalStateRefs()) {
							const s$1 = null !== (t$1 = e$1.get(i$1)) && void 0 !== t$1 ? t$1 : [];
							s$1.push({
								name: r$1,
								value: n$1.value
							}), e$1.set(i$1, s$1);
						}
					}
					return e$1;
				}
				setLayoutProperty(t$1, e$1, r$1 = {}) {
					null != e$1 && this._validate(ns, `layers.${this.id}.layout.${t$1}`, t$1, e$1, r$1) || ("visibility" !== t$1 ? this._unevaluatedLayout.setValue(t$1, e$1) : this.visibility = e$1);
				}
				getPaintProperty(t$1) {
					return t$1.endsWith(qs) ? this._transitionablePaint.getTransition(t$1.slice(0, -11)) : this._transitionablePaint.getValue(t$1);
				}
				setPaintProperty(t$1, e$1, r$1 = {}) {
					if (null != e$1 && this._validate(rs, `layers.${this.id}.paint.${t$1}`, t$1, e$1, r$1)) return !1;
					if (t$1.endsWith(qs)) return this._transitionablePaint.setTransition(t$1.slice(0, -11), e$1 || void 0), !1;
					{
						const r$2 = this._transitionablePaint._values[t$1], n$1 = "cross-faded-data-driven" === r$2.property.specification["property-type"], i$1 = r$2.value.isDataDriven(), s$1 = r$2.value;
						this._transitionablePaint.setValue(t$1, e$1), this._handleSpecialPaintPropertyUpdate(t$1);
						const a$1 = this._transitionablePaint._values[t$1].value;
						return a$1.isDataDriven() || i$1 || n$1 || this._handleOverridablePaintPropertyUpdate(t$1, s$1, a$1);
					}
				}
				_handleSpecialPaintPropertyUpdate(t$1) {}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !1;
				}
				isHidden(t$1) {
					return !!(this.minzoom && t$1 < this.minzoom) || !!(this.maxzoom && t$1 >= this.maxzoom) || "none" === this.visibility;
				}
				updateTransitions(t$1) {
					this._transitioningPaint = this._transitionablePaint.transitioned(t$1, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculate(t$1, e$1) {
					t$1.getCrossfadeParameters && (this._crossfadeParameters = t$1.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t$1, void 0, e$1)), this.paint = this._transitioningPaint.possiblyEvaluate(t$1, void 0, e$1);
				}
				serialize() {
					const t$1 = {
						id: this.id,
						type: this.type,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return this.visibility && (t$1.layout = t$1.layout || {}, t$1.layout.visibility = this.visibility), U(t$1, ((t$2, e$1) => !(void 0 === t$2 || "layout" === e$1 && !Object.keys(t$2).length || "paint" === e$1 && !Object.keys(t$2).length)));
				}
				_validate(t$1, e$1, r$1, n$1, i$1 = {}) {
					return (!i$1 || !1 !== i$1.validate) && is(this, t$1.call(Qi, {
						key: e$1,
						layerType: this.type,
						objectKey: r$1,
						value: n$1,
						styleSpec: xt,
						style: {
							glyphs: !0,
							sprite: !0
						}
					}));
				}
				is3D() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				resize() {}
				isStateDependent() {
					for (const t$1 in this.paint._values) {
						const e$1 = this.paint.get(t$1);
						if (e$1 instanceof Ds && jn(e$1.property.specification) && ("source" === e$1.value.kind || "composite" === e$1.value.kind) && e$1.value.isStateDependent) return !0;
					}
					return !1;
				}
			}
			const Xs = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class Zs {
				constructor(t$1, e$1) {
					this._structArray = t$1, this._pos1 = e$1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			class Ys {
				constructor() {
					this.isTransferred = !1, this.capacity = -1, this.resize(0);
				}
				static serialize(t$1, e$1) {
					return t$1._trim(), e$1 && (t$1.isTransferred = !0, e$1.push(t$1.arrayBuffer)), {
						length: t$1.length,
						arrayBuffer: t$1.arrayBuffer
					};
				}
				static deserialize(t$1) {
					const e$1 = Object.create(this.prototype);
					return e$1.arrayBuffer = t$1.arrayBuffer, e$1.length = t$1.length, e$1.capacity = t$1.arrayBuffer.byteLength / e$1.bytesPerElement, e$1._refreshViews(), e$1;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(t$1) {
					this.reserve(t$1), this.length = t$1;
				}
				reserve(t$1) {
					if (t$1 > this.capacity) {
						this.capacity = Math.max(t$1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						const e$1 = this.uint8;
						this._refreshViews(), e$1 && this.uint8.set(e$1);
					}
				}
				_refreshViews() {
					throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
				}
			}
			function Hs(t$1, e$1 = 1) {
				let r$1 = 0, n$1 = 0;
				return {
					members: t$1.map(((t$2) => {
						const i$1 = Xs[t$2.type].BYTES_PER_ELEMENT, s$1 = r$1 = Ks(r$1, Math.max(e$1, i$1)), a$1 = t$2.components || 1;
						return n$1 = Math.max(n$1, i$1), r$1 += i$1 * a$1, {
							name: t$2.name,
							type: t$2.type,
							components: a$1,
							offset: s$1
						};
					})),
					size: Ks(r$1, Math.max(n$1, e$1)),
					alignment: e$1
				};
			}
			function Ks(t$1, e$1) {
				return Math.ceil(t$1 / e$1) * e$1;
			}
			class Js extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.int16[n$1 + 0] = e$1, this.int16[n$1 + 1] = r$1, t$1;
				}
			}
			Js.prototype.bytesPerElement = 4, os("StructArrayLayout2i4", Js);
			class Ws extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.int16[i$1 + 0] = e$1, this.int16[i$1 + 1] = r$1, this.int16[i$1 + 2] = n$1, t$1;
				}
			}
			Ws.prototype.bytesPerElement = 6, os("StructArrayLayout3i6", Ws);
			class Qs extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.int16[s$1 + 0] = e$1, this.int16[s$1 + 1] = r$1, this.int16[s$1 + 2] = n$1, this.int16[s$1 + 3] = i$1, t$1;
				}
			}
			Qs.prototype.bytesPerElement = 8, os("StructArrayLayout4i8", Qs);
			class ta extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a$1, t$1;
				}
			}
			ta.prototype.bytesPerElement = 12, os("StructArrayLayout2i4i12", ta);
			class ea extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = 4 * t$1, l$1 = 8 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.uint8[l$1 + 4] = n$1, this.uint8[l$1 + 5] = i$1, this.uint8[l$1 + 6] = s$1, this.uint8[l$1 + 7] = a$1, t$1;
				}
			}
			ea.prototype.bytesPerElement = 8, os("StructArrayLayout2i4ub8", ea);
			class ra extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.float32[n$1 + 0] = e$1, this.float32[n$1 + 1] = r$1, t$1;
				}
			}
			ra.prototype.bytesPerElement = 8, os("StructArrayLayout2f8", ra);
			class na extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1) {
					const c$1 = this.length;
					return this.resize(c$1 + 1), this.emplace(c$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1) {
					const h$1 = 10 * t$1;
					return this.uint16[h$1 + 0] = e$1, this.uint16[h$1 + 1] = r$1, this.uint16[h$1 + 2] = n$1, this.uint16[h$1 + 3] = i$1, this.uint16[h$1 + 4] = s$1, this.uint16[h$1 + 5] = a$1, this.uint16[h$1 + 6] = o$1, this.uint16[h$1 + 7] = l$1, this.uint16[h$1 + 8] = u$1, this.uint16[h$1 + 9] = c$1, t$1;
				}
			}
			na.prototype.bytesPerElement = 20, os("StructArrayLayout10ui20", na);
			class ia extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = this.length;
					return this.resize(l$1 + 1), this.emplace(l$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
					const u$1 = 8 * t$1;
					return this.uint16[u$1 + 0] = e$1, this.uint16[u$1 + 1] = r$1, this.uint16[u$1 + 2] = n$1, this.uint16[u$1 + 3] = i$1, this.uint16[u$1 + 4] = s$1, this.uint16[u$1 + 5] = a$1, this.uint16[u$1 + 6] = o$1, this.uint16[u$1 + 7] = l$1, t$1;
				}
			}
			ia.prototype.bytesPerElement = 16, os("StructArrayLayout8ui16", ia);
			class sa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1) {
					const p$1 = this.length;
					return this.resize(p$1 + 1), this.emplace(p$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = 12 * t$1;
					return this.int16[f$1 + 0] = e$1, this.int16[f$1 + 1] = r$1, this.int16[f$1 + 2] = n$1, this.int16[f$1 + 3] = i$1, this.uint16[f$1 + 4] = s$1, this.uint16[f$1 + 5] = a$1, this.uint16[f$1 + 6] = o$1, this.uint16[f$1 + 7] = l$1, this.int16[f$1 + 8] = u$1, this.int16[f$1 + 9] = c$1, this.int16[f$1 + 10] = h$1, this.int16[f$1 + 11] = p$1, t$1;
				}
			}
			sa.prototype.bytesPerElement = 24, os("StructArrayLayout4i4ui4i24", sa);
			class aa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.float32[i$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			aa.prototype.bytesPerElement = 12, os("StructArrayLayout3f12", aa);
			class oa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			oa.prototype.bytesPerElement = 4, os("StructArrayLayout1ul4", oa);
			class la extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
					const u$1 = this.length;
					return this.resize(u$1 + 1), this.emplace(u$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1) {
					const c$1 = 10 * t$1, h$1 = 5 * t$1;
					return this.int16[c$1 + 0] = e$1, this.int16[c$1 + 1] = r$1, this.int16[c$1 + 2] = n$1, this.int16[c$1 + 3] = i$1, this.int16[c$1 + 4] = s$1, this.int16[c$1 + 5] = a$1, this.uint32[h$1 + 3] = o$1, this.uint16[c$1 + 8] = l$1, this.uint16[c$1 + 9] = u$1, t$1;
				}
			}
			la.prototype.bytesPerElement = 20, os("StructArrayLayout6i1ul2ui20", la);
			class ua extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = 6 * t$1;
					return this.int16[o$1 + 0] = e$1, this.int16[o$1 + 1] = r$1, this.int16[o$1 + 2] = n$1, this.int16[o$1 + 3] = i$1, this.int16[o$1 + 4] = s$1, this.int16[o$1 + 5] = a$1, t$1;
				}
			}
			ua.prototype.bytesPerElement = 12, os("StructArrayLayout2i2i2i12", ua);
			class ca extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.length;
					return this.resize(s$1 + 1), this.emplace(s$1, t$1, e$1, r$1, n$1, i$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = 4 * t$1, o$1 = 8 * t$1;
					return this.float32[a$1 + 0] = e$1, this.float32[a$1 + 1] = r$1, this.float32[a$1 + 2] = n$1, this.int16[o$1 + 6] = i$1, this.int16[o$1 + 7] = s$1, t$1;
				}
			}
			ca.prototype.bytesPerElement = 16, os("StructArrayLayout2f1f2i16", ca);
			class ha extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = this.length;
					return this.resize(a$1 + 1), this.emplace(a$1, t$1, e$1, r$1, n$1, i$1, s$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = 16 * t$1, l$1 = 4 * t$1, u$1 = 8 * t$1;
					return this.uint8[o$1 + 0] = e$1, this.uint8[o$1 + 1] = r$1, this.float32[l$1 + 1] = n$1, this.float32[l$1 + 2] = i$1, this.int16[u$1 + 6] = s$1, this.int16[u$1 + 7] = a$1, t$1;
				}
			}
			ha.prototype.bytesPerElement = 16, os("StructArrayLayout2ub2f2i16", ha);
			class pa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[i$1 + 0] = e$1, this.uint16[i$1 + 1] = r$1, this.uint16[i$1 + 2] = n$1, t$1;
				}
			}
			pa.prototype.bytesPerElement = 6, os("StructArrayLayout3ui6", pa);
			class fa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1) {
					const g$1 = this.length;
					return this.resize(g$1 + 1), this.emplace(g$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1) {
					const x$1 = 24 * t$1, v$1 = 12 * t$1, b$1 = 48 * t$1;
					return this.int16[x$1 + 0] = e$1, this.int16[x$1 + 1] = r$1, this.uint16[x$1 + 2] = n$1, this.uint16[x$1 + 3] = i$1, this.uint32[v$1 + 2] = s$1, this.uint32[v$1 + 3] = a$1, this.uint32[v$1 + 4] = o$1, this.uint16[x$1 + 10] = l$1, this.uint16[x$1 + 11] = u$1, this.uint16[x$1 + 12] = c$1, this.float32[v$1 + 7] = h$1, this.float32[v$1 + 8] = p$1, this.uint8[b$1 + 36] = f$1, this.uint8[b$1 + 37] = d$1, this.uint8[b$1 + 38] = y$1, this.uint32[v$1 + 10] = m$1, this.int16[x$1 + 22] = g$1, t$1;
				}
			}
			fa.prototype.bytesPerElement = 48, os("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", fa);
			class da extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, M$1, I$1) {
					const z$1 = this.length;
					return this.resize(z$1 + 1), this.emplace(z$1, t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, M$1, I$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1, m$1, g$1, x$1, v$1, b$1, w$1, _$1, S$1, A$1, k$1, M$1, I$1, z$1) {
					const P$1 = 32 * t$1, C$1 = 16 * t$1;
					return this.int16[P$1 + 0] = e$1, this.int16[P$1 + 1] = r$1, this.int16[P$1 + 2] = n$1, this.int16[P$1 + 3] = i$1, this.int16[P$1 + 4] = s$1, this.int16[P$1 + 5] = a$1, this.int16[P$1 + 6] = o$1, this.int16[P$1 + 7] = l$1, this.uint16[P$1 + 8] = u$1, this.uint16[P$1 + 9] = c$1, this.uint16[P$1 + 10] = h$1, this.uint16[P$1 + 11] = p$1, this.uint16[P$1 + 12] = f$1, this.uint16[P$1 + 13] = d$1, this.uint16[P$1 + 14] = y$1, this.uint16[P$1 + 15] = m$1, this.uint16[P$1 + 16] = g$1, this.uint16[P$1 + 17] = x$1, this.uint16[P$1 + 18] = v$1, this.uint16[P$1 + 19] = b$1, this.uint16[P$1 + 20] = w$1, this.uint16[P$1 + 21] = _$1, this.uint16[P$1 + 22] = S$1, this.uint32[C$1 + 12] = A$1, this.float32[C$1 + 13] = k$1, this.float32[C$1 + 14] = M$1, this.uint16[P$1 + 30] = I$1, this.uint16[P$1 + 31] = z$1, t$1;
				}
			}
			da.prototype.bytesPerElement = 64, os("StructArrayLayout8i15ui1ul2f2ui64", da);
			class ya extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.float32[1 * t$1 + 0] = e$1, t$1;
				}
			}
			ya.prototype.bytesPerElement = 4, os("StructArrayLayout1f4", ya);
			class ma extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 3 * t$1;
					return this.uint16[6 * t$1 + 0] = e$1, this.float32[i$1 + 1] = r$1, this.float32[i$1 + 2] = n$1, t$1;
				}
			}
			ma.prototype.bytesPerElement = 12, os("StructArrayLayout1ui2f12", ma);
			class ga extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1) {
					const n$1 = this.length;
					return this.resize(n$1 + 1), this.emplace(n$1, t$1, e$1, r$1);
				}
				emplace(t$1, e$1, r$1, n$1) {
					const i$1 = 4 * t$1;
					return this.uint32[2 * t$1 + 0] = e$1, this.uint16[i$1 + 2] = r$1, this.uint16[i$1 + 3] = n$1, t$1;
				}
			}
			ga.prototype.bytesPerElement = 8, os("StructArrayLayout1ul2ui8", ga);
			class xa extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1) {
					const r$1 = this.length;
					return this.resize(r$1 + 1), this.emplace(r$1, t$1, e$1);
				}
				emplace(t$1, e$1, r$1) {
					const n$1 = 2 * t$1;
					return this.uint16[n$1 + 0] = e$1, this.uint16[n$1 + 1] = r$1, t$1;
				}
			}
			xa.prototype.bytesPerElement = 4, os("StructArrayLayout2ui4", xa);
			class va extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(t$1) {
					const e$1 = this.length;
					return this.resize(e$1 + 1), this.emplace(e$1, t$1);
				}
				emplace(t$1, e$1) {
					return this.uint16[1 * t$1 + 0] = e$1, t$1;
				}
			}
			va.prototype.bytesPerElement = 2, os("StructArrayLayout1ui2", va);
			class ba extends Ys {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(t$1, e$1, r$1, n$1) {
					const i$1 = this.length;
					return this.resize(i$1 + 1), this.emplace(i$1, t$1, e$1, r$1, n$1);
				}
				emplace(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = 4 * t$1;
					return this.float32[s$1 + 0] = e$1, this.float32[s$1 + 1] = r$1, this.float32[s$1 + 2] = n$1, this.float32[s$1 + 3] = i$1, t$1;
				}
			}
			ba.prototype.bytesPerElement = 16, os("StructArrayLayout4f16", ba);
			class wa extends Zs {
				get anchorPointX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorPointY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get x1() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get y1() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get x2() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get y2() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get anchorPoint() {
					return new r(this.anchorPointX, this.anchorPointY);
				}
			}
			wa.prototype.size = 20;
			class _a extends la {
				get(t$1) {
					return new wa(this, t$1);
				}
			}
			os("CollisionBoxArray", _a);
			class Sa extends Zs {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 2];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 4];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 7];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 8];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 36];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 37];
				}
				set placedOrientation(t$1) {
					this._structArray.uint8[this._pos1 + 37] = t$1;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 38];
				}
				set hidden(t$1) {
					this._structArray.uint8[this._pos1 + 38] = t$1;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 10];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 10] = t$1;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 22];
				}
			}
			Sa.prototype.size = 48;
			class Aa extends fa {
				get(t$1) {
					return new Sa(this, t$1);
				}
			}
			os("PlacedSymbolArray", Aa);
			class ka extends Zs {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 12];
				}
				set crossTileID(t$1) {
					this._structArray.uint32[this._pos4 + 12] = t$1;
				}
				get textBoxScale() {
					return this._structArray.float32[this._pos4 + 13];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 14];
				}
				get textAnchorOffsetStartIndex() {
					return this._structArray.uint16[this._pos2 + 30];
				}
				get textAnchorOffsetEndIndex() {
					return this._structArray.uint16[this._pos2 + 31];
				}
			}
			ka.prototype.size = 64;
			class Ma extends da {
				get(t$1) {
					return new ka(this, t$1);
				}
			}
			os("SymbolInstanceArray", Ma);
			class Ia extends ya {
				getoffsetX(t$1) {
					return this.float32[1 * t$1 + 0];
				}
			}
			os("GlyphOffsetArray", Ia);
			class za extends Ws {
				getx(t$1) {
					return this.int16[3 * t$1 + 0];
				}
				gety(t$1) {
					return this.int16[3 * t$1 + 1];
				}
				gettileUnitDistanceFromAnchor(t$1) {
					return this.int16[3 * t$1 + 2];
				}
			}
			os("SymbolLineVertexArray", za);
			class Pa extends Zs {
				get textAnchor() {
					return this._structArray.uint16[this._pos2 + 0];
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 2];
				}
			}
			Pa.prototype.size = 12;
			class Ca extends ma {
				get(t$1) {
					return new Pa(this, t$1);
				}
			}
			os("TextAnchorOffsetArray", Ca);
			class Ea extends Zs {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
			}
			Ea.prototype.size = 8;
			class Ta extends ga {
				get(t$1) {
					return new Ea(this, t$1);
				}
			}
			os("FeatureIndexArray", Ta);
			class Ba extends Js {}
			class Va extends Js {}
			class Fa extends Js {}
			class Da extends ta {}
			class $a extends ea {}
			class La extends ra {}
			class Oa extends na {}
			class Ra extends ia {}
			class Ua extends sa {}
			class ja extends aa {}
			class Na extends oa {}
			class qa extends ua {}
			class Ga extends ha {}
			class Xa extends pa {}
			class Za extends xa {}
			const { members: Ha } = Hs([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			class Ka {
				constructor(t$1 = []) {
					this._forceNewSegmentOnNextPrepare = !1, this.segments = t$1;
				}
				prepareSegment(t$1, e$1, r$1, n$1) {
					const i$1 = this.segments[this.segments.length - 1];
					return t$1 > Ka.MAX_VERTEX_ARRAY_LENGTH && q(`Max vertices per segment is ${Ka.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t$1}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Ka.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i$1 || i$1.vertexLength + t$1 > Ka.MAX_VERTEX_ARRAY_LENGTH || i$1.sortKey !== n$1 ? this.createNewSegment(e$1, r$1, n$1) : i$1;
				}
				createNewSegment(t$1, e$1, r$1) {
					const n$1 = {
						vertexOffset: t$1.length,
						primitiveOffset: e$1.length,
						vertexLength: 0,
						primitiveLength: 0,
						vaos: {}
					};
					return void 0 !== r$1 && (n$1.sortKey = r$1), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(n$1), n$1;
				}
				getOrCreateLatestSegment(t$1, e$1, r$1) {
					return this.prepareSegment(0, t$1, e$1, r$1);
				}
				forceNewSegmentOnNextPrepare() {
					this._forceNewSegmentOnNextPrepare = !0;
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (const t$1 of this.segments) for (const e$1 in t$1.vaos) t$1.vaos[e$1].destroy();
				}
				static simpleSegment(t$1, e$1, r$1, n$1) {
					return new Ka([{
						vertexOffset: t$1,
						primitiveOffset: e$1,
						vertexLength: r$1,
						primitiveLength: n$1,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function Ja(t$1, e$1) {
				return 256 * (t$1 = D(Math.floor(t$1), 0, 255)) + D(Math.floor(e$1), 0, 255);
			}
			Ka.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, os("SegmentVector", Ka);
			const Wa = Hs([
				{
					name: "a_pattern_from",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pattern_to",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_from",
					components: 1,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_to",
					components: 1,
					type: "Uint16"
				}
			]), Qa = Hs([{
				name: "a_dasharray_from",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_dasharray_to",
				components: 4,
				type: "Uint16"
			}]);
			var to, eo, ro, no = { exports: {} }, io = { exports: {} }, so = { exports: {} }, ao = function() {
				if (ro) return no.exports;
				ro = 1;
				var t$1 = (to || (to = 1, io.exports = function(t$2, e$2) {
					var r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1;
					for (n$1 = t$2.length - (r$1 = 3 & t$2.length), i$1 = e$2, a$1 = 3432918353, o$1 = 461845907, u$1 = 0; u$1 < n$1;) l$1 = 255 & t$2.charCodeAt(u$1) | (255 & t$2.charCodeAt(++u$1)) << 8 | (255 & t$2.charCodeAt(++u$1)) << 16 | (255 & t$2.charCodeAt(++u$1)) << 24, ++u$1, i$1 = 27492 + (65535 & (s$1 = 5 * (65535 & (i$1 = (i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & l$1) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295) << 13 | i$1 >>> 19)) + ((5 * (i$1 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s$1 >>> 16) & 65535) << 16);
					switch (l$1 = 0, r$1) {
						case 3: l$1 ^= (255 & t$2.charCodeAt(u$1 + 2)) << 16;
						case 2: l$1 ^= (255 & t$2.charCodeAt(u$1 + 1)) << 8;
						case 1: i$1 ^= l$1 = (65535 & (l$1 = (l$1 = (65535 & (l$1 ^= 255 & t$2.charCodeAt(u$1))) * a$1 + (((l$1 >>> 16) * a$1 & 65535) << 16) & 4294967295) << 15 | l$1 >>> 17)) * o$1 + (((l$1 >>> 16) * o$1 & 65535) << 16) & 4294967295;
					}
					return i$1 ^= t$2.length, i$1 = 2246822507 * (65535 & (i$1 ^= i$1 >>> 16)) + ((2246822507 * (i$1 >>> 16) & 65535) << 16) & 4294967295, i$1 = 3266489909 * (65535 & (i$1 ^= i$1 >>> 13)) + ((3266489909 * (i$1 >>> 16) & 65535) << 16) & 4294967295, (i$1 ^= i$1 >>> 16) >>> 0;
				}), io.exports), e$1 = (eo || (eo = 1, so.exports = function(t$2, e$2) {
					for (var r$1, n$1 = t$2.length, i$1 = e$2 ^ n$1, s$1 = 0; n$1 >= 4;) r$1 = 1540483477 * (65535 & (r$1 = 255 & t$2.charCodeAt(s$1) | (255 & t$2.charCodeAt(++s$1)) << 8 | (255 & t$2.charCodeAt(++s$1)) << 16 | (255 & t$2.charCodeAt(++s$1)) << 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16), i$1 = 1540483477 * (65535 & i$1) + ((1540483477 * (i$1 >>> 16) & 65535) << 16) ^ (r$1 = 1540483477 * (65535 & (r$1 ^= r$1 >>> 24)) + ((1540483477 * (r$1 >>> 16) & 65535) << 16)), n$1 -= 4, ++s$1;
					switch (n$1) {
						case 3: i$1 ^= (255 & t$2.charCodeAt(s$1 + 2)) << 16;
						case 2: i$1 ^= (255 & t$2.charCodeAt(s$1 + 1)) << 8;
						case 1: i$1 = 1540483477 * (65535 & (i$1 ^= 255 & t$2.charCodeAt(s$1))) + ((1540483477 * (i$1 >>> 16) & 65535) << 16);
					}
					return i$1 = 1540483477 * (65535 & (i$1 ^= i$1 >>> 13)) + ((1540483477 * (i$1 >>> 16) & 65535) << 16), (i$1 ^= i$1 >>> 15) >>> 0;
				}), so.exports);
				return no.exports = t$1, no.exports.murmur3 = t$1, no.exports.murmur2 = e$1, no.exports;
			}(), oo = n(ao);
			class lo {
				constructor() {
					this.ids = [], this.positions = [], this.indexed = !1;
				}
				add(t$1, e$1, r$1, n$1) {
					this.ids.push(uo(t$1)), this.positions.push(e$1, r$1, n$1);
				}
				getPositions(t$1) {
					if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
					const e$1 = uo(t$1);
					let r$1 = 0, n$1 = this.ids.length - 1;
					for (; r$1 < n$1;) {
						const t$2 = r$1 + n$1 >> 1;
						this.ids[t$2] >= e$1 ? n$1 = t$2 : r$1 = t$2 + 1;
					}
					const i$1 = [];
					for (; this.ids[r$1] === e$1;) i$1.push({
						index: this.positions[3 * r$1],
						start: this.positions[3 * r$1 + 1],
						end: this.positions[3 * r$1 + 2]
					}), r$1++;
					return i$1;
				}
				static serialize(t$1, e$1) {
					const r$1 = new Float64Array(t$1.ids), n$1 = new Uint32Array(t$1.positions);
					return co(r$1, n$1, 0, r$1.length - 1), e$1 && e$1.push(r$1.buffer, n$1.buffer), {
						ids: r$1,
						positions: n$1
					};
				}
				static deserialize(t$1) {
					const e$1 = new lo();
					return e$1.ids = t$1.ids, e$1.positions = t$1.positions, e$1.indexed = !0, e$1;
				}
			}
			function uo(t$1) {
				const e$1 = +t$1;
				return !isNaN(e$1) && e$1 <= Number.MAX_SAFE_INTEGER ? e$1 : oo(String(t$1));
			}
			function co(t$1, e$1, r$1, n$1) {
				for (; r$1 < n$1;) {
					const i$1 = t$1[r$1 + n$1 >> 1];
					let s$1 = r$1 - 1, a$1 = n$1 + 1;
					for (;;) {
						do
							s$1++;
						while (t$1[s$1] < i$1);
						do
							a$1--;
						while (t$1[a$1] > i$1);
						if (s$1 >= a$1) break;
						ho(t$1, s$1, a$1), ho(e$1, 3 * s$1, 3 * a$1), ho(e$1, 3 * s$1 + 1, 3 * a$1 + 1), ho(e$1, 3 * s$1 + 2, 3 * a$1 + 2);
					}
					a$1 - r$1 < n$1 - a$1 ? (co(t$1, e$1, r$1, a$1), r$1 = a$1 + 1) : (co(t$1, e$1, a$1 + 1, n$1), n$1 = a$1);
				}
			}
			function ho(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			os("FeaturePositionMap", lo);
			class po {
				constructor(t$1, e$1) {
					this.gl = t$1.gl, this.location = e$1;
				}
			}
			class fo extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1f(this.location, t$1));
				}
			}
			class yo extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] && t$1[3] === this.current[3] || (this.current = t$1, this.gl.uniform4f(this.location, t$1[0], t$1[1], t$1[2], t$1[3]));
				}
			}
			class mo extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = Me.transparent;
				}
				set(t$1) {
					t$1.r === this.current.r && t$1.g === this.current.g && t$1.b === this.current.b && t$1.a === this.current.a || (this.current = t$1, this.gl.uniform4f(this.location, t$1.r, t$1.g, t$1.b, t$1.a));
				}
			}
			const go = new Float32Array(16);
			function xo(t$1) {
				return [Ja(255 * t$1.r, 255 * t$1.g), Ja(255 * t$1.b, 255 * t$1.a)];
			}
			class vo {
				constructor(t$1, e$1, r$1) {
					this.value = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.type = r$1;
				}
				setUniform(t$1, e$1, r$1) {
					t$1.set(r$1.constantOr(this.value));
				}
				getBinding(t$1, e$1, r$1) {
					return "color" === this.type ? new mo(t$1, e$1) : new fo(t$1, e$1);
				}
			}
			class bo {
				constructor(t$1, e$1) {
					this.uniformNames = e$1.map(((t$2) => `u_${t$2}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
				}
				setConstantPatternPositions(t$1, e$1) {
					this.pixelRatioFrom = e$1.pixelRatio, this.pixelRatioTo = t$1.pixelRatio, this.patternFrom = e$1.tlbr, this.patternTo = t$1.tlbr;
				}
				setConstantDashPositions(t$1, e$1) {
					this.dashTo = [
						0,
						t$1.y,
						t$1.height,
						t$1.width
					], this.dashFrom = [
						0,
						e$1.y,
						e$1.height,
						e$1.width
					];
				}
				setUniform(t$1, e$1, r$1, n$1) {
					let i$1 = null;
					"u_pattern_to" === n$1 ? i$1 = this.patternTo : "u_pattern_from" === n$1 ? i$1 = this.patternFrom : "u_dasharray_to" === n$1 ? i$1 = this.dashTo : "u_dasharray_from" === n$1 ? i$1 = this.dashFrom : "u_pixel_ratio_to" === n$1 ? i$1 = this.pixelRatioTo : "u_pixel_ratio_from" === n$1 && (i$1 = this.pixelRatioFrom), null !== i$1 && t$1.set(i$1);
				}
				getBinding(t$1, e$1, r$1) {
					return "u_pattern" === r$1.substr(0, 9) || "u_dasharray_" === r$1.substr(0, 12) ? new yo(t$1, e$1) : new fo(t$1, e$1);
				}
			}
			class wo {
				constructor(t$1, e$1, r$1, n$1) {
					this.expression = t$1, this.type = r$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new n$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.paintVertexArray.length, i$1 = this.expression.evaluate(new zs(0, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection);
					this.paintVertexArray.resize(t$1), this._setPaintValue(n$1, t$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new zs(0, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1);
				}
				_setPaintValue(t$1, e$1, r$1) {
					if ("color" === this.type) {
						const n$1 = xo(r$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, n$1[0], n$1[1]);
					} else {
						for (let n$1 = t$1; n$1 < e$1; n$1++) this.paintVertexArray.emplace(n$1, r$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class _o {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.uniformNames = e$1.map(((t$2) => `u_${t$2}_t`)), this.type = r$1, this.useIntegerZoom = n$1, this.zoom = i$1, this.maxValue = 0, this.paintVertexAttributes = e$1.map(((t$2) => ({
						name: `a_${t$2}`,
						type: "Float32",
						components: "color" === r$1 ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new s$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.expression.evaluate(new zs(this.zoom, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), i$1 = this.expression.evaluate(new zs(this.zoom + 1, r$1), e$1, {}, r$1.canonical, [], r$1.formattedSection), s$1 = this.paintVertexArray.length;
					this.paintVertexArray.resize(t$1), this._setPaintValue(s$1, t$1, n$1, i$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					const s$1 = this.expression.evaluate(new zs(this.zoom, i$1), r$1, n$1), a$1 = this.expression.evaluate(new zs(this.zoom + 1, i$1), r$1, n$1);
					this._setPaintValue(t$1, e$1, s$1, a$1);
				}
				_setPaintValue(t$1, e$1, r$1, n$1) {
					if ("color" === this.type) {
						const i$1 = xo(r$1), s$1 = xo(n$1);
						for (let r$2 = t$1; r$2 < e$1; r$2++) this.paintVertexArray.emplace(r$2, i$1[0], i$1[1], s$1[0], s$1[1]);
					} else {
						for (let i$1 = t$1; i$1 < e$1; i$1++) this.paintVertexArray.emplace(i$1, r$1, n$1);
						this.maxValue = Math.max(this.maxValue, Math.abs(r$1), Math.abs(n$1));
					}
				}
				upload(t$1) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t$1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(t$1, e$1) {
					const r$1 = this.useIntegerZoom ? Math.floor(e$1.zoom) : e$1.zoom, n$1 = D(this.expression.interpolationFactor(r$1, this.zoom, this.zoom + 1), 0, 1);
					t$1.set(n$1);
				}
				getBinding(t$1, e$1, r$1) {
					return new fo(t$1, e$1);
				}
			}
			class So {
				constructor(t$1, e$1, r$1, n$1, i$1, s$1) {
					this.expression = t$1, this.type = e$1, this.useIntegerZoom = r$1, this.zoom = n$1, this.layerId = s$1, this.zoomInPaintVertexArray = new i$1(), this.zoomOutPaintVertexArray = new i$1();
				}
				populatePaintArray(t$1, e$1, r$1) {
					const n$1 = this.zoomInPaintVertexArray.length;
					this.zoomInPaintVertexArray.resize(t$1), this.zoomOutPaintVertexArray.resize(t$1), this._setPaintValues(n$1, t$1, this.getPositionIds(e$1), r$1);
				}
				updatePaintArray(t$1, e$1, r$1, n$1, i$1) {
					this._setPaintValues(t$1, e$1, this.getPositionIds(r$1), i$1);
				}
				_setPaintValues(t$1, e$1, r$1, n$1) {
					const i$1 = this.getPositions(n$1);
					if (!i$1 || !r$1) return;
					const s$1 = i$1[r$1.min], a$1 = i$1[r$1.mid], o$1 = i$1[r$1.max];
					if (s$1 && a$1 && o$1) for (let r$2 = t$1; r$2 < e$1; r$2++) this.emplace(this.zoomInPaintVertexArray, r$2, a$1, s$1), this.emplace(this.zoomOutPaintVertexArray, r$2, a$1, o$1);
				}
				upload(t$1) {
					if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
						const e$1 = this.getVertexAttributes();
						this.zoomInPaintVertexBuffer = t$1.createVertexBuffer(this.zoomInPaintVertexArray, e$1, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t$1.createVertexBuffer(this.zoomOutPaintVertexArray, e$1, this.expression.isStateDependent);
					}
				}
				destroy() {
					this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
				}
			}
			class Ao extends So {
				getPositions(t$1) {
					return t$1.imagePositions;
				}
				getPositionIds(t$1) {
					return t$1.patterns && t$1.patterns[this.layerId];
				}
				getVertexAttributes() {
					return Wa.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, r$1.tlbr[0], r$1.tlbr[1], r$1.tlbr[2], r$1.tlbr[3], n$1.tlbr[0], n$1.tlbr[1], n$1.tlbr[2], n$1.tlbr[3], r$1.pixelRatio, n$1.pixelRatio);
				}
			}
			class ko extends So {
				getPositions(t$1) {
					return t$1.dashPositions;
				}
				getPositionIds(t$1) {
					return t$1.dashes && t$1.dashes[this.layerId];
				}
				getVertexAttributes() {
					return Qa.members;
				}
				emplace(t$1, e$1, r$1, n$1) {
					t$1.emplace(e$1, 0, r$1.y, r$1.height, r$1.width, 0, n$1.y, n$1.height, n$1.width);
				}
			}
			class Mo {
				constructor(t$1, e$1, r$1) {
					this.binders = {}, this._buffers = [];
					const n$1 = [];
					for (const i$1 in t$1.paint._values) {
						if (!r$1(i$1)) continue;
						const s$1 = t$1.paint.get(i$1);
						if (!(s$1 instanceof Ds && jn(s$1.property.specification))) continue;
						const a$1 = zo(i$1, t$1.type), o$1 = s$1.value, l$1 = s$1.property.specification.type, u$1 = s$1.property.useIntegerZoom, c$1 = s$1.property.specification["property-type"], h$1 = "cross-faded" === c$1 || "cross-faded-data-driven" === c$1;
						if ("constant" === o$1.kind) this.binders[i$1] = h$1 ? new bo(o$1.value, a$1) : new vo(o$1.value, a$1, l$1), n$1.push(`/u_${i$1}`);
						else if ("source" === o$1.kind || h$1) {
							const r$2 = Po(i$1, l$1, "source");
							this.binders[i$1] = h$1 ? "line-dasharray" === i$1 ? new ko(o$1, l$1, u$1, e$1, r$2, t$1.id) : new Ao(o$1, l$1, u$1, e$1, r$2, t$1.id) : new wo(o$1, a$1, l$1, r$2), n$1.push(`/a_${i$1}`);
						} else {
							const t$2 = Po(i$1, l$1, "composite");
							this.binders[i$1] = new _o(o$1, a$1, l$1, u$1, e$1, t$2), n$1.push(`/z_${i$1}`);
						}
					}
					this.cacheKey = n$1.sort().join("");
				}
				getMaxValue(t$1) {
					const e$1 = this.binders[t$1];
					return e$1 instanceof wo || e$1 instanceof _o ? e$1.maxValue : 0;
				}
				populatePaintArrays(t$1, e$1, r$1) {
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						(i$1 instanceof wo || i$1 instanceof _o || i$1 instanceof So) && i$1.populatePaintArray(t$1, e$1, r$1);
					}
				}
				setConstantPatternPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof bo && n$1.setConstantPatternPositions(t$1, e$1);
					}
				}
				setConstantDashPositions(t$1, e$1) {
					for (const r$1 in this.binders) {
						const n$1 = this.binders[r$1];
						n$1 instanceof bo && n$1.setConstantDashPositions(t$1, e$1);
					}
				}
				updatePaintArrays(t$1, e$1, r$1, n$1, i$1) {
					let s$1 = !1;
					for (const a$1 in t$1) {
						const o$1 = e$1.getPositions(a$1);
						for (const e$2 of o$1) {
							const o$2 = r$1.feature(e$2.index);
							for (const r$2 in this.binders) {
								const l$1 = this.binders[r$2];
								if ((l$1 instanceof wo || l$1 instanceof _o || l$1 instanceof So) && !0 === l$1.expression.isStateDependent) l$1.expression = n$1.paint.get(r$2).value, l$1.updatePaintArray(e$2.start, e$2.end, o$2, t$1[a$1], i$1), s$1 = !0;
							}
						}
					}
					return s$1;
				}
				defines() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof vo || r$1 instanceof bo) && t$1.push(...r$1.uniformNames.map(((t$2) => `#define HAS_UNIFORM_${t$2}`)));
					}
					return t$1;
				}
				getBinderAttributes() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof wo || r$1 instanceof _o) for (let e$2 = 0; e$2 < r$1.paintVertexAttributes.length; e$2++) t$1.push(r$1.paintVertexAttributes[e$2].name);
						else if (r$1 instanceof So) {
							const e$2 = r$1.getVertexAttributes();
							for (const r$2 of e$2) t$1.push(r$2.name);
						}
					}
					return t$1;
				}
				getBinderUniforms() {
					const t$1 = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (r$1 instanceof vo || r$1 instanceof bo || r$1 instanceof _o) for (const e$2 of r$1.uniformNames) t$1.push(e$2);
					}
					return t$1;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(t$1, e$1) {
					const r$1 = [];
					for (const n$1 in this.binders) {
						const i$1 = this.binders[n$1];
						if (i$1 instanceof vo || i$1 instanceof bo || i$1 instanceof _o) {
							for (const s$1 of i$1.uniformNames) if (e$1[s$1]) {
								const a$1 = i$1.getBinding(t$1, e$1[s$1], s$1);
								r$1.push({
									name: s$1,
									property: n$1,
									binding: a$1
								});
							}
						}
					}
					return r$1;
				}
				setUniforms(t$1, e$1, r$1, n$1) {
					for (const { name: t$2, property: i$1, binding: s$1 } of e$1) this.binders[i$1].setUniform(s$1, n$1, r$1.get(i$1), t$2);
				}
				updatePaintBuffers(t$1) {
					this._buffers = [];
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						if (t$1 && r$1 instanceof So) {
							const e$2 = 2 === t$1.fromScale ? r$1.zoomInPaintVertexBuffer : r$1.zoomOutPaintVertexBuffer;
							e$2 && this._buffers.push(e$2);
						} else (r$1 instanceof wo || r$1 instanceof _o) && r$1.paintVertexBuffer && this._buffers.push(r$1.paintVertexBuffer);
					}
				}
				upload(t$1) {
					for (const e$1 in this.binders) {
						const r$1 = this.binders[e$1];
						(r$1 instanceof wo || r$1 instanceof _o || r$1 instanceof So) && r$1.upload(t$1);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (const t$1 in this.binders) {
						const e$1 = this.binders[t$1];
						(e$1 instanceof wo || e$1 instanceof _o || e$1 instanceof So) && e$1.destroy();
					}
				}
			}
			class Io {
				constructor(t$1, e$1, r$1 = () => !0) {
					this.programConfigurations = {};
					for (const n$1 of t$1) this.programConfigurations[n$1.id] = new Mo(n$1, e$1, r$1);
					this.needsUpload = !1, this._featureMap = new lo(), this._bufferOffset = 0;
				}
				populatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const r$2 in this.programConfigurations) this.programConfigurations[r$2].populatePaintArrays(t$1, e$1, n$1);
					void 0 !== e$1.id && this._featureMap.add(e$1.id, r$1, this._bufferOffset, t$1), this._bufferOffset = t$1, this.needsUpload = !0;
				}
				updatePaintArrays(t$1, e$1, r$1, n$1) {
					for (const i$1 of r$1) this.needsUpload = this.programConfigurations[i$1.id].updatePaintArrays(t$1, this._featureMap, e$1, i$1, n$1) || this.needsUpload;
				}
				get(t$1) {
					return this.programConfigurations[t$1];
				}
				upload(t$1) {
					if (this.needsUpload) {
						for (const e$1 in this.programConfigurations) this.programConfigurations[e$1].upload(t$1);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (const t$1 in this.programConfigurations) this.programConfigurations[t$1].destroy();
				}
			}
			function zo(t$1, e$1) {
				return {
					"text-opacity": ["opacity"],
					"icon-opacity": ["opacity"],
					"text-color": ["fill_color"],
					"icon-color": ["fill_color"],
					"text-halo-color": ["halo_color"],
					"icon-halo-color": ["halo_color"],
					"text-halo-blur": ["halo_blur"],
					"icon-halo-blur": ["halo_blur"],
					"text-halo-width": ["halo_width"],
					"icon-halo-width": ["halo_width"],
					"line-gap-width": ["gapwidth"],
					"line-dasharray": ["dasharray_to", "dasharray_from"],
					"line-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-extrusion-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					]
				}[t$1] || [t$1.replace(`${e$1}-`, "").replace(/-/g, "_")];
			}
			function Po(t$1, e$1, r$1) {
				const n$1 = {
					color: {
						source: ra,
						composite: ba
					},
					number: {
						source: ya,
						composite: ra
					}
				}, i$1 = function(t$2) {
					return {
						"line-pattern": {
							source: Oa,
							composite: Oa
						},
						"fill-pattern": {
							source: Oa,
							composite: Oa
						},
						"fill-extrusion-pattern": {
							source: Oa,
							composite: Oa
						},
						"line-dasharray": {
							source: Ra,
							composite: Ra
						}
					}[t$2];
				}(t$1);
				return i$1 && i$1[r$1] || n$1[e$1][r$1];
			}
			os("ConstantBinder", vo), os("CrossFadedConstantBinder", bo), os("SourceExpressionBinder", wo), os("CrossFadedPatternBinder", Ao), os("CrossFadedDasharrayBinder", ko), os("CompositeExpressionBinder", _o), os("ProgramConfiguration", Mo, { omit: ["_buffers"] }), os("ProgramConfigurationSet", Io);
			const Co = Math.pow(2, 14) - 1, Eo = -Co - 1;
			function To(t$1) {
				const e$1 = P / t$1.extent, r$1 = t$1.loadGeometry();
				for (let t$2 = 0; t$2 < r$1.length; t$2++) {
					const n$1 = r$1[t$2];
					for (let t$3 = 0; t$3 < n$1.length; t$3++) {
						const r$2 = n$1[t$3], i$1 = Math.round(r$2.x * e$1), s$1 = Math.round(r$2.y * e$1);
						r$2.x = D(i$1, Eo, Co), r$2.y = D(s$1, Eo, Co), (i$1 < r$2.x || i$1 > r$2.x + 1 || s$1 < r$2.y || s$1 > r$2.y + 1) && q("Geometry exceeds allowed extent, reduce your vector tile buffer size");
					}
				}
				return r$1;
			}
			function Bo(t$1, e$1) {
				return {
					type: t$1.type,
					id: t$1.id,
					properties: t$1.properties,
					geometry: e$1 ? To(t$1) : []
				};
			}
			const Vo = -32768;
			function Fo(t$1, e$1, r$1, n$1, i$1) {
				t$1.emplaceBack(Vo + 8 * e$1 + n$1, Vo + 8 * r$1 + i$1);
			}
			class Do {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new Va(), this.indexArray = new Xa(), this.segments = new Ka(), this.programConfigurations = new Io(t$1.layers, t$1.zoom), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					const n$1 = this.layers[0], i$1 = [];
					let s$1 = null, a$1 = !1, o$1 = "heatmap" === n$1.type;
					if ("circle" === n$1.type) {
						const t$2 = n$1;
						s$1 = t$2.layout.get("circle-sort-key"), a$1 = !s$1.isConstant(), o$1 = o$1 || "map" === t$2.paint.get("circle-pitch-alignment");
					}
					const l$1 = o$1 ? e$1.subdivisionGranularity.circle : 1;
					for (const { feature: e$2, id: n$2, index: o$2, sourceLayerIndex: l$2 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Bo(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new zs(this.zoom), u$1, r$1)) continue;
						const c$1 = a$1 ? s$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: n$2,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$2,
							index: o$2,
							geometry: t$2 ? u$1.geometry : To(e$2),
							patterns: {},
							sortKey: c$1
						};
						i$1.push(h$1);
					}
					a$1 && i$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of i$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a$2 } = n$2, o$2 = t$1[s$2].feature;
						this.addFeature(n$2, i$2, s$2, r$1, l$1), e$1.featureIndex.insert(o$2, i$2, s$2, a$2, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Ha), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1 = 1) {
					let s$1;
					switch (i$1) {
						case 1:
							s$1 = [0, 7];
							break;
						case 3:
							s$1 = [
								0,
								2,
								5,
								7
							];
							break;
						case 5:
							s$1 = [
								0,
								1,
								3,
								4,
								6,
								7
							];
							break;
						case 7:
							s$1 = [
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7
							];
							break;
						default: throw new Error(`Invalid circle bucket granularity: ${i$1}; valid values are 1, 3, 5, 7.`);
					}
					const a$1 = s$1.length;
					for (const r$2 of e$1) for (const e$2 of r$2) {
						const r$3 = e$2.x, n$2 = e$2.y;
						if (r$3 < 0 || r$3 >= P || n$2 < 0 || n$2 >= P) continue;
						const i$2 = this.segments.prepareSegment(a$1 * a$1, this.layoutVertexArray, this.indexArray, t$1.sortKey), o$1 = i$2.vertexLength;
						for (let t$2 = 0; t$2 < a$1; t$2++) for (let e$3 = 0; e$3 < a$1; e$3++) Fo(this.layoutVertexArray, r$3, n$2, s$1[e$3], s$1[t$2]);
						for (let t$2 = 0; t$2 < a$1 - 1; t$2++) for (let e$3 = 0; e$3 < a$1 - 1; e$3++) {
							const r$4 = o$1 + t$2 * a$1 + e$3, n$3 = o$1 + (t$2 + 1) * a$1 + e$3;
							this.indexArray.emplaceBack(r$4, n$3 + 1, r$4 + 1), this.indexArray.emplaceBack(r$4, n$3, n$3 + 1);
						}
						i$2.vertexLength += a$1 * a$1, i$2.primitiveLength += (a$1 - 1) * (a$1 - 1) * 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: {},
						canonical: n$1
					});
				}
			}
			function $o(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Xo(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Xo(t$1, e$1[r$1])) return !0;
				return !!Uo(t$1, e$1);
			}
			function Lo(t$1, e$1, r$1) {
				return !!Xo(t$1, e$1) || !!No(e$1, t$1, r$1);
			}
			function Oo(t$1, e$1) {
				if (1 === t$1.length) return Go(e$1, t$1[0]);
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					for (let e$2 = 0; e$2 < n$1.length; e$2++) if (Xo(t$1, n$1[e$2])) return !0;
				}
				for (let r$1 = 0; r$1 < t$1.length; r$1++) if (Go(e$1, t$1[r$1])) return !0;
				for (let r$1 = 0; r$1 < e$1.length; r$1++) if (Uo(t$1, e$1[r$1])) return !0;
				return !1;
			}
			function Ro(t$1, e$1, r$1) {
				if (t$1.length > 1) {
					if (Uo(t$1, e$1)) return !0;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (No(e$1[n$1], t$1, r$1)) return !0;
				}
				for (let n$1 = 0; n$1 < t$1.length; n$1++) if (No(t$1[n$1], e$1, r$1)) return !0;
				return !1;
			}
			function Uo(t$1, e$1) {
				if (0 === t$1.length || 0 === e$1.length) return !1;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) {
					const n$1 = t$1[r$1], i$1 = t$1[r$1 + 1];
					for (let t$2 = 0; t$2 < e$1.length - 1; t$2++) if (jo(n$1, i$1, e$1[t$2], e$1[t$2 + 1])) return !0;
				}
				return !1;
			}
			function jo(t$1, e$1, r$1, n$1) {
				return G(t$1, r$1, n$1) !== G(e$1, r$1, n$1) && G(t$1, e$1, r$1) !== G(t$1, e$1, n$1);
			}
			function No(t$1, e$1, r$1) {
				const n$1 = r$1 * r$1;
				if (1 === e$1.length) return t$1.distSqr(e$1[0]) < n$1;
				for (let r$2 = 1; r$2 < e$1.length; r$2++) if (qo(t$1, e$1[r$2 - 1], e$1[r$2]) < n$1) return !0;
				return !1;
			}
			function qo(t$1, e$1, r$1) {
				const n$1 = e$1.distSqr(r$1);
				if (0 === n$1) return t$1.distSqr(e$1);
				const i$1 = ((t$1.x - e$1.x) * (r$1.x - e$1.x) + (t$1.y - e$1.y) * (r$1.y - e$1.y)) / n$1;
				return t$1.distSqr(i$1 < 0 ? e$1 : i$1 > 1 ? r$1 : r$1.sub(e$1)._mult(i$1)._add(e$1));
			}
			function Go(t$1, e$1) {
				let r$1, n$1, i$1, s$1 = !1;
				for (let a$1 = 0; a$1 < t$1.length; a$1++) {
					r$1 = t$1[a$1];
					for (let t$2 = 0, a$2 = r$1.length - 1; t$2 < r$1.length; a$2 = t$2++) n$1 = r$1[t$2], i$1 = r$1[a$2], n$1.y > e$1.y != i$1.y > e$1.y && e$1.x < (i$1.x - n$1.x) * (e$1.y - n$1.y) / (i$1.y - n$1.y) + n$1.x && (s$1 = !s$1);
				}
				return s$1;
			}
			function Xo(t$1, e$1) {
				let r$1 = !1;
				for (let n$1 = 0, i$1 = t$1.length - 1; n$1 < t$1.length; i$1 = n$1++) {
					const s$1 = t$1[n$1], a$1 = t$1[i$1];
					s$1.y > e$1.y != a$1.y > e$1.y && e$1.x < (a$1.x - s$1.x) * (e$1.y - s$1.y) / (a$1.y - s$1.y) + s$1.x && (r$1 = !r$1);
				}
				return r$1;
			}
			function Zo(t$1, e$1, r$1) {
				const n$1 = r$1[0], i$1 = r$1[2];
				if (t$1.x < n$1.x && e$1.x < n$1.x || t$1.x > i$1.x && e$1.x > i$1.x || t$1.y < n$1.y && e$1.y < n$1.y || t$1.y > i$1.y && e$1.y > i$1.y) return !1;
				const s$1 = G(t$1, e$1, r$1[0]);
				return s$1 !== G(t$1, e$1, r$1[1]) || s$1 !== G(t$1, e$1, r$1[2]) || s$1 !== G(t$1, e$1, r$1[3]);
			}
			function Yo(t$1, e$1, r$1) {
				const n$1 = e$1.paint.get(t$1).value;
				return "constant" === n$1.kind ? n$1.value : r$1.programConfigurations.get(e$1.id).getMaxValue(t$1);
			}
			function Ho(t$1) {
				return Math.sqrt(t$1[0] * t$1[0] + t$1[1] * t$1[1]);
			}
			function Ko(t$1, e$1, n$1, i$1, s$1) {
				if (!e$1[0] && !e$1[1]) return t$1;
				const a$1 = r.convert(e$1)._mult(s$1);
				"viewport" === n$1 && a$1._rotate(-i$1);
				const o$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2++) o$1.push(t$1[e$2].sub(a$1));
				return o$1;
			}
			function Jo({ queryGeometry: t$1, size: e$1 }, r$1) {
				return Lo(t$1, r$1, e$1);
			}
			function Wo({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return Lo(t$1, s$1, e$1 * (r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera / r$1.cameraToCenterDistance));
			}
			function Qo({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				const a$1 = r$1.projectTileCoordinates(s$1.x, s$1.y, n$1, i$1).signedDistanceFromCamera, o$1 = e$1 * (r$1.cameraToCenterDistance / a$1);
				return Lo(t$1, rl(s$1, r$1, n$1, i$1), o$1);
			}
			function tl({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1 }, s$1) {
				return Lo(t$1, rl(s$1, r$1, n$1, i$1), e$1);
			}
			function el({ queryGeometry: t$1, size: e$1, transform: r$1, unwrappedTileID: n$1, getElevation: i$1, pitchAlignment: s$1 = "map", pitchScale: a$1 = "map" }, o$1) {
				const l$1 = "map" === s$1 ? "map" === a$1 ? Jo : Wo : "map" === a$1 ? Qo : tl, u$1 = {
					queryGeometry: t$1,
					size: e$1,
					transform: r$1,
					unwrappedTileID: n$1,
					getElevation: i$1
				};
				for (const t$2 of o$1) for (const e$2 of t$2) if (l$1(u$1, e$2)) return !0;
				return !1;
			}
			function rl(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.projectTileCoordinates(t$1.x, t$1.y, n$1, i$1).point;
				return new r((.5 * s$1.x + .5) * e$1.width, (.5 * -s$1.y + .5) * e$1.height);
			}
			let nl, il;
			os("CircleBucket", Do, { omit: ["layers"] });
			var sl = {
				get paint() {
					return il = il || new Ns({
						"circle-radius": new Os(xt.paint_circle["circle-radius"]),
						"circle-color": new Os(xt.paint_circle["circle-color"]),
						"circle-blur": new Os(xt.paint_circle["circle-blur"]),
						"circle-opacity": new Os(xt.paint_circle["circle-opacity"]),
						"circle-translate": new Ls(xt.paint_circle["circle-translate"]),
						"circle-translate-anchor": new Ls(xt.paint_circle["circle-translate-anchor"]),
						"circle-pitch-scale": new Ls(xt.paint_circle["circle-pitch-scale"]),
						"circle-pitch-alignment": new Ls(xt.paint_circle["circle-pitch-alignment"]),
						"circle-stroke-width": new Os(xt.paint_circle["circle-stroke-width"]),
						"circle-stroke-color": new Os(xt.paint_circle["circle-stroke-color"]),
						"circle-stroke-opacity": new Os(xt.paint_circle["circle-stroke-opacity"])
					});
				},
				get layout() {
					return nl = nl || new Ns({ "circle-sort-key": new Os(xt.layout_circle["circle-sort-key"]) });
				}
			};
			class al extends Gs {
				constructor(t$1, e$1) {
					super(t$1, sl, e$1);
				}
				createBucket(t$1) {
					return new Do(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1;
					return Yo("circle-radius", this, e$1) + Yo("circle-stroke-width", this, e$1) + Ho(this.paint.get("circle-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: a$1, getElevation: o$1 }) {
					const l$1 = Ko(t$1, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i$1.bearingInRadians, s$1), u$1 = this.paint.get("circle-radius").evaluate(e$1, r$1) + this.paint.get("circle-stroke-width").evaluate(e$1, r$1), c$1 = this.paint.get("circle-pitch-scale"), h$1 = this.paint.get("circle-pitch-alignment");
					let p$1, f$1;
					return "map" === h$1 ? (p$1 = l$1, f$1 = u$1 * s$1) : (p$1 = function(t$2, e$2, r$2, n$2) {
						return t$2.map(((t$3) => rl(t$3, e$2, r$2, n$2)));
					}(l$1, i$1, a$1, o$1), f$1 = u$1), el({
						queryGeometry: p$1,
						size: f$1,
						transform: i$1,
						unwrappedTileID: a$1,
						getElevation: o$1,
						pitchAlignment: h$1,
						pitchScale: c$1
					}, n$1);
				}
			}
			class ol extends Do {}
			let ll;
			os("HeatmapBucket", ol, { omit: ["layers"] });
			var ul = { get paint() {
				return ll = ll || new Ns({
					"heatmap-radius": new Os(xt.paint_heatmap["heatmap-radius"]),
					"heatmap-weight": new Os(xt.paint_heatmap["heatmap-weight"]),
					"heatmap-intensity": new Ls(xt.paint_heatmap["heatmap-intensity"]),
					"heatmap-color": new js(xt.paint_heatmap["heatmap-color"]),
					"heatmap-opacity": new Ls(xt.paint_heatmap["heatmap-opacity"])
				});
			} };
			function cl(t$1, { width: e$1, height: r$1 }, n$1, i$1) {
				if (i$1) {
					if (i$1 instanceof Uint8ClampedArray) i$1 = new Uint8Array(i$1.buffer);
					else if (i$1.length !== e$1 * r$1 * n$1) throw new RangeError(`mismatched image size. expected: ${i$1.length} but got: ${e$1 * r$1 * n$1}`);
				} else i$1 = new Uint8Array(e$1 * r$1 * n$1);
				return t$1.width = e$1, t$1.height = r$1, t$1.data = i$1, t$1;
			}
			function hl(t$1, { width: e$1, height: r$1 }, n$1) {
				if (e$1 === t$1.width && r$1 === t$1.height) return;
				const i$1 = cl({}, {
					width: e$1,
					height: r$1
				}, n$1);
				pl(t$1, i$1, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(t$1.width, e$1),
					height: Math.min(t$1.height, r$1)
				}, n$1), t$1.width = e$1, t$1.height = r$1, t$1.data = i$1.data;
			}
			function pl(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (0 === i$1.width || 0 === i$1.height) return e$1;
				if (i$1.width > t$1.width || i$1.height > t$1.height || r$1.x > t$1.width - i$1.width || r$1.y > t$1.height - i$1.height) throw new RangeError("out of range source coordinates for image copy");
				if (i$1.width > e$1.width || i$1.height > e$1.height || n$1.x > e$1.width - i$1.width || n$1.y > e$1.height - i$1.height) throw new RangeError("out of range destination coordinates for image copy");
				const a$1 = t$1.data, o$1 = e$1.data;
				if (a$1 === o$1) throw new Error("srcData equals dstData, so image is already copied");
				for (let l$1 = 0; l$1 < i$1.height; l$1++) {
					const u$1 = ((r$1.y + l$1) * t$1.width + r$1.x) * s$1, c$1 = ((n$1.y + l$1) * e$1.width + n$1.x) * s$1;
					for (let t$2 = 0; t$2 < i$1.width * s$1; t$2++) o$1[c$1 + t$2] = a$1[u$1 + t$2];
				}
				return e$1;
			}
			class fl {
				constructor(t$1, e$1) {
					cl(this, t$1, 1, e$1);
				}
				resize(t$1) {
					hl(this, t$1, 1);
				}
				clone() {
					return new fl({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					pl(t$1, e$1, r$1, n$1, i$1, 1);
				}
			}
			class dl {
				constructor(t$1, e$1) {
					cl(this, t$1, 4, e$1);
				}
				resize(t$1) {
					hl(this, t$1, 4);
				}
				replace(t$1, e$1) {
					e$1 ? this.data.set(t$1) : this.data = t$1 instanceof Uint8ClampedArray ? new Uint8Array(t$1.buffer) : t$1;
				}
				clone() {
					return new dl({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(t$1, e$1, r$1, n$1, i$1) {
					pl(t$1, e$1, r$1, n$1, i$1, 4);
				}
				setPixel(t$1, e$1, r$1) {
					const n$1 = 4 * (t$1 * this.width + e$1);
					this.data[n$1 + 0] = Math.round(255 * r$1.r / r$1.a), this.data[n$1 + 1] = Math.round(255 * r$1.g / r$1.a), this.data[n$1 + 2] = Math.round(255 * r$1.b / r$1.a), this.data[n$1 + 3] = Math.round(255 * r$1.a);
				}
			}
			function yl(t$1) {
				const e$1 = {}, r$1 = t$1.resolution || 256, n$1 = t$1.clips ? t$1.clips.length : 1, i$1 = t$1.image || new dl({
					width: r$1,
					height: n$1
				});
				if (Math.log(r$1) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r$1}`);
				const s$1 = (n$2, s$2, a$1) => {
					e$1[t$1.evaluationKey] = a$1;
					const o$1 = t$1.expression.evaluate(e$1);
					i$1.setPixel(n$2 / 4 / r$1, s$2 / 4, o$1);
				};
				if (t$1.clips) for (let e$2 = 0, i$2 = 0; e$2 < n$1; ++e$2, i$2 += 4 * r$1) for (let n$2 = 0, a$1 = 0; n$2 < r$1; n$2++, a$1 += 4) {
					const o$1 = n$2 / (r$1 - 1), { start: l$1, end: u$1 } = t$1.clips[e$2];
					s$1(i$2, a$1, l$1 * (1 - o$1) + u$1 * o$1);
				}
				else for (let t$2 = 0, e$2 = 0; t$2 < r$1; t$2++, e$2 += 4) s$1(0, e$2, t$2 / (r$1 - 1));
				return i$1;
			}
			os("AlphaImage", fl), os("RGBAImage", dl);
			const ml = "big-fb";
			class gl extends Gs {
				createBucket(t$1) {
					return new ol(t$1);
				}
				constructor(t$1, e$1) {
					super(t$1, ul, e$1), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					"heatmap-color" === t$1 && this._updateColorRamp();
				}
				_updateColorRamp() {
					this.colorRamp = yl({
						expression: this._transitionablePaint._values["heatmap-color"].value.expression,
						evaluationKey: "heatmapDensity",
						image: this.colorRamp
					}), this.colorRampTexture = null;
				}
				resize() {
					this.heatmapFbos.has(ml) && this.heatmapFbos.delete(ml);
				}
				queryRadius(t$1) {
					return Yo("heatmap-radius", this, t$1);
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: r$1, geometry: n$1, transform: i$1, pixelsToTileUnits: s$1, unwrappedTileID: a$1, getElevation: o$1 }) {
					return el({
						queryGeometry: t$1,
						size: this.paint.get("heatmap-radius").evaluate(e$1, r$1) * s$1,
						transform: i$1,
						unwrappedTileID: a$1,
						getElevation: o$1
					}, n$1);
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
				}
			}
			let xl;
			var vl = { get paint() {
				return xl = xl || new Ns({
					"hillshade-illumination-direction": new Ls(xt.paint_hillshade["hillshade-illumination-direction"]),
					"hillshade-illumination-altitude": new Ls(xt.paint_hillshade["hillshade-illumination-altitude"]),
					"hillshade-illumination-anchor": new Ls(xt.paint_hillshade["hillshade-illumination-anchor"]),
					"hillshade-exaggeration": new Ls(xt.paint_hillshade["hillshade-exaggeration"]),
					"hillshade-shadow-color": new Ls(xt.paint_hillshade["hillshade-shadow-color"]),
					"hillshade-highlight-color": new Ls(xt.paint_hillshade["hillshade-highlight-color"]),
					"hillshade-accent-color": new Ls(xt.paint_hillshade["hillshade-accent-color"]),
					"hillshade-method": new Ls(xt.paint_hillshade["hillshade-method"])
				});
			} };
			class bl extends Gs {
				constructor(t$1, e$1) {
					super(t$1, vl, e$1), this.recalculate({
						zoom: 0,
						zoomHistory: {}
					}, void 0);
				}
				getIlluminationProperties() {
					let t$1 = this.paint.get("hillshade-illumination-direction").values, e$1 = this.paint.get("hillshade-illumination-altitude").values, r$1 = this.paint.get("hillshade-highlight-color").values, n$1 = this.paint.get("hillshade-shadow-color").values;
					const i$1 = Math.max(t$1.length, e$1.length, r$1.length, n$1.length);
					t$1 = t$1.concat(Array(i$1 - t$1.length).fill(t$1.at(-1))), e$1 = e$1.concat(Array(i$1 - e$1.length).fill(e$1.at(-1))), r$1 = r$1.concat(Array(i$1 - r$1.length).fill(r$1.at(-1))), n$1 = n$1.concat(Array(i$1 - n$1.length).fill(n$1.at(-1)));
					const s$1 = e$1.map(tt);
					return {
						directionRadians: t$1.map(tt),
						altitudeRadians: s$1,
						shadowColor: n$1,
						highlightColor: r$1
					};
				}
				hasOffscreenPass() {
					return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
				}
			}
			let wl;
			var _l = { get paint() {
				return wl = wl || new Ns({
					"color-relief-opacity": new Ls(xt["paint_color-relief"]["color-relief-opacity"]),
					"color-relief-color": new js(xt["paint_color-relief"]["color-relief-color"])
				});
			} };
			class Sl {
				constructor(t$1, e$1, r$1, n$1) {
					this.context = t$1, this.format = r$1, this.texture = t$1.gl.createTexture(), this.update(e$1, n$1);
				}
				update(t$1, e$1, r$1) {
					const { width: n$1, height: i$1 } = t$1, s$1 = !(this.size && this.size[0] === n$1 && this.size[1] === i$1 || r$1), { context: a$1 } = this, { gl: o$1 } = a$1;
					if (this.useMipmap = Boolean(e$1 && e$1.useMipmap), o$1.bindTexture(o$1.TEXTURE_2D, this.texture), a$1.pixelStoreUnpackFlipY.set(!1), a$1.pixelStoreUnpack.set(1), a$1.pixelStoreUnpackPremultiplyAlpha.set(this.format === o$1.RGBA && (!e$1 || !1 !== e$1.premultiply)), s$1) this.size = [n$1, i$1], t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Y(t$1) ? o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, this.format, o$1.UNSIGNED_BYTE, t$1) : o$1.texImage2D(o$1.TEXTURE_2D, 0, this.format, n$1, i$1, 0, this.format, o$1.UNSIGNED_BYTE, t$1.data);
					else {
						const { x: e$2, y: s$2 } = r$1 || {
							x: 0,
							y: 0
						};
						t$1 instanceof HTMLImageElement || t$1 instanceof HTMLCanvasElement || t$1 instanceof HTMLVideoElement || t$1 instanceof ImageData || Y(t$1) ? o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1) : o$1.texSubImage2D(o$1.TEXTURE_2D, 0, e$2, s$2, n$1, i$1, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1.data);
					}
					this.useMipmap && this.isSizePowerOfTwo() && o$1.generateMipmap(o$1.TEXTURE_2D), a$1.pixelStoreUnpackFlipY.setDefault(), a$1.pixelStoreUnpack.setDefault(), a$1.pixelStoreUnpackPremultiplyAlpha.setDefault();
				}
				bind(t$1, e$1, r$1) {
					const { context: n$1 } = this, { gl: i$1 } = n$1;
					i$1.bindTexture(i$1.TEXTURE_2D, this.texture), r$1 !== i$1.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r$1 = i$1.LINEAR), t$1 !== this.filter && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MAG_FILTER, t$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_MIN_FILTER, r$1 || t$1), this.filter = t$1), e$1 !== this.wrap && (i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_S, e$1), i$1.texParameteri(i$1.TEXTURE_2D, i$1.TEXTURE_WRAP_T, e$1), this.wrap = e$1);
				}
				isSizePowerOfTwo() {
					return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
				}
				destroy() {
					const { gl: t$1 } = this.context;
					t$1.deleteTexture(this.texture), this.texture = null;
				}
			}
			class Al {
				constructor(t$1, e$1, r$1, n$1 = 1, i$1 = 1, s$1 = 1, a$1 = 0) {
					if (this.uid = t$1, e$1.height !== e$1.width) throw new RangeError("DEM tiles must be square");
					if (r$1 && ![
						"mapbox",
						"terrarium",
						"custom"
					].includes(r$1)) return void q(`"${r$1}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
					this.stride = e$1.height;
					const o$1 = this.dim = e$1.height - 2;
					switch (this.data = new Uint32Array(e$1.data.buffer), r$1) {
						case "terrarium":
							this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
							break;
						case "custom":
							this.redFactor = n$1, this.greenFactor = i$1, this.blueFactor = s$1, this.baseShift = a$1;
							break;
						default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
					}
					for (let t$2 = 0; t$2 < o$1; t$2++) this.data[this._idx(-1, t$2)] = this.data[this._idx(0, t$2)], this.data[this._idx(o$1, t$2)] = this.data[this._idx(o$1 - 1, t$2)], this.data[this._idx(t$2, -1)] = this.data[this._idx(t$2, 0)], this.data[this._idx(t$2, o$1)] = this.data[this._idx(t$2, o$1 - 1)];
					this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o$1, -1)] = this.data[this._idx(o$1 - 1, 0)], this.data[this._idx(-1, o$1)] = this.data[this._idx(0, o$1 - 1)], this.data[this._idx(o$1, o$1)] = this.data[this._idx(o$1 - 1, o$1 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
					for (let t$2 = 0; t$2 < o$1; t$2++) for (let e$2 = 0; e$2 < o$1; e$2++) {
						const r$2 = this.get(t$2, e$2);
						r$2 > this.max && (this.max = r$2), r$2 < this.min && (this.min = r$2);
					}
				}
				get(t$1, e$1) {
					const r$1 = new Uint8Array(this.data.buffer), n$1 = 4 * this._idx(t$1, e$1);
					return this.unpack(r$1[n$1], r$1[n$1 + 1], r$1[n$1 + 2]);
				}
				getUnpackVector() {
					return [
						this.redFactor,
						this.greenFactor,
						this.blueFactor,
						this.baseShift
					];
				}
				_idx(t$1, e$1) {
					if (t$1 < -1 || t$1 >= this.dim + 1 || e$1 < -1 || e$1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
					return (e$1 + 1) * this.stride + (t$1 + 1);
				}
				unpack(t$1, e$1, r$1) {
					return t$1 * this.redFactor + e$1 * this.greenFactor + r$1 * this.blueFactor - this.baseShift;
				}
				pack(t$1) {
					return kl(t$1, this.getUnpackVector());
				}
				getPixels() {
					return new dl({
						width: this.stride,
						height: this.stride
					}, new Uint8Array(this.data.buffer));
				}
				backfillBorder(t$1, e$1, r$1) {
					if (this.dim !== t$1.dim) throw new Error("dem dimension mismatch");
					let n$1 = e$1 * this.dim, i$1 = e$1 * this.dim + this.dim, s$1 = r$1 * this.dim, a$1 = r$1 * this.dim + this.dim;
					switch (e$1) {
						case -1:
							n$1 = i$1 - 1;
							break;
						case 1: i$1 = n$1 + 1;
					}
					switch (r$1) {
						case -1:
							s$1 = a$1 - 1;
							break;
						case 1: a$1 = s$1 + 1;
					}
					const o$1 = -e$1 * this.dim, l$1 = -r$1 * this.dim;
					for (let e$2 = s$1; e$2 < a$1; e$2++) for (let r$2 = n$1; r$2 < i$1; r$2++) this.data[this._idx(r$2, e$2)] = t$1.data[this._idx(r$2 + o$1, e$2 + l$1)];
				}
			}
			function kl(t$1, e$1) {
				const r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a$1 = Math.min(r$1, n$1, i$1), o$1 = Math.round((t$1 + s$1) / a$1);
				return {
					r: Math.floor(o$1 * a$1 / r$1) % 256,
					g: Math.floor(o$1 * a$1 / n$1) % 256,
					b: Math.floor(o$1 * a$1 / i$1) % 256
				};
			}
			os("DEMData", Al);
			class Ml extends Gs {
				constructor(t$1, e$1) {
					super(t$1, _l, e$1);
				}
				_createColorRamp(t$1) {
					const e$1 = {
						elevationStops: [],
						colorStops: []
					}, r$1 = this._transitionablePaint._values["color-relief-color"].value.expression;
					if (r$1 instanceof ni && r$1._styleExpression.expression instanceof pr) {
						this.colorRampExpression = r$1;
						const t$2 = r$1._styleExpression.expression;
						e$1.elevationStops = t$2.labels, e$1.colorStops = [];
						for (const r$2 of e$1.elevationStops) e$1.colorStops.push(t$2.evaluate({ globals: { elevation: r$2 } }));
					}
					if (e$1.elevationStops.length < 1 && (e$1.elevationStops = [0], e$1.colorStops = [Me.transparent]), e$1.elevationStops.length < 2 && (e$1.elevationStops.push(e$1.elevationStops[0] + 1), e$1.colorStops.push(e$1.colorStops[0])), e$1.elevationStops.length <= t$1) return e$1;
					const n$1 = {
						elevationStops: [],
						colorStops: []
					}, i$1 = (e$1.elevationStops.length - 1) / (t$1 - 1);
					for (let t$2 = 0; t$2 < e$1.elevationStops.length - .5; t$2 += i$1) n$1.elevationStops.push(e$1.elevationStops[Math.round(t$2)]), n$1.colorStops.push(e$1.colorStops[Math.round(t$2)]);
					return q(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), n$1;
				}
				_colorRampChanged() {
					return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
				}
				getColorRampTextures(t$1, e$1, r$1) {
					if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
					const n$1 = this._createColorRamp(e$1), i$1 = new dl({
						width: n$1.colorStops.length,
						height: 1
					}), s$1 = new dl({
						width: n$1.colorStops.length,
						height: 1
					});
					for (let t$2 = 0; t$2 < n$1.elevationStops.length; t$2++) {
						const e$2 = kl(n$1.elevationStops[t$2], r$1);
						s$1.setPixel(0, t$2, new Me(e$2.r / 255, e$2.g / 255, e$2.b / 255, 1)), i$1.setPixel(0, t$2, n$1.colorStops[t$2]);
					}
					return this.colorRampTextures = {
						elevationTexture: new Sl(t$1, s$1, t$1.gl.RGBA),
						colorTexture: new Sl(t$1, i$1, t$1.gl.RGBA)
					}, this.colorRampTextures;
				}
				hasOffscreenPass() {
					return "none" !== this.visibility && !!this.colorRampTextures;
				}
			}
			const { members: zl } = Hs([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			function Pl(t$1, e$1, r$1) {
				const n$1 = r$1.patternDependencies;
				let i$1 = !1;
				for (const r$2 of e$1) {
					const e$2 = r$2.paint.get(`${t$1}-pattern`);
					e$2.isConstant() || (i$1 = !0);
					const s$1 = e$2.constantOr(null);
					s$1 && (i$1 = !0, n$1[s$1.to] = !0, n$1[s$1.from] = !0);
				}
				return i$1;
			}
			function Cl(t$1, e$1, r$1, n$1, i$1) {
				const { zoom: s$1 } = n$1, a$1 = i$1.patternDependencies;
				for (const n$2 of e$1) {
					const e$2 = n$2.paint.get(`${t$1}-pattern`).value;
					if ("constant" !== e$2.kind) {
						let t$2 = e$2.evaluate({ zoom: s$1 - 1 }, r$1, {}, i$1.availableImages), o$1 = e$2.evaluate({ zoom: s$1 }, r$1, {}, i$1.availableImages), l$1 = e$2.evaluate({ zoom: s$1 + 1 }, r$1, {}, i$1.availableImages);
						t$2 = t$2 && t$2.name ? t$2.name : t$2, o$1 = o$1 && o$1.name ? o$1.name : o$1, l$1 = l$1 && l$1.name ? l$1.name : l$1, a$1[t$2] = !0, a$1[o$1] = !0, a$1[l$1] = !0, r$1.patterns[n$2.id] = {
							min: t$2,
							mid: o$1,
							max: l$1
						};
					}
				}
				return r$1;
			}
			function El(t$1, e$1, r$1, n$1, i$1) {
				let s$1;
				if (i$1 === function(t$2, e$2, r$2, n$2) {
					let i$2 = 0;
					for (let s$2 = e$2, a$1 = r$2 - n$2; s$2 < r$2; s$2 += n$2) i$2 += (t$2[a$1] - t$2[s$2]) * (t$2[s$2 + 1] + t$2[a$1 + 1]), a$1 = s$2;
					return i$2;
				}(t$1, e$1, r$1, n$1) > 0) for (let i$2 = e$1; i$2 < r$1; i$2 += n$1) s$1 = Ql(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				else for (let i$2 = r$1 - n$1; i$2 >= e$1; i$2 -= n$1) s$1 = Ql(i$2 / n$1 | 0, t$1[i$2], t$1[i$2 + 1], s$1);
				return s$1 && Zl(s$1, s$1.next) && (tu(s$1), s$1 = s$1.next), s$1;
			}
			function Tl(t$1, e$1) {
				if (!t$1) return t$1;
				e$1 || (e$1 = t$1);
				let r$1, n$1 = t$1;
				do
					if (r$1 = !1, n$1.steiner || !Zl(n$1, n$1.next) && 0 !== Xl(n$1.prev, n$1, n$1.next)) n$1 = n$1.next;
					else {
						if (tu(n$1), n$1 = e$1 = n$1.prev, n$1 === n$1.next) break;
						r$1 = !0;
					}
				while (r$1 || n$1 !== e$1);
				return e$1;
			}
			function Bl(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
				if (!t$1) return;
				!a$1 && s$1 && function(t$2, e$2, r$2, n$2) {
					let i$2 = t$2;
					do
						0 === i$2.z && (i$2.z = Ul(i$2.x, i$2.y, e$2, r$2, n$2)), i$2.prevZ = i$2.prev, i$2.nextZ = i$2.next, i$2 = i$2.next;
					while (i$2 !== t$2);
					i$2.prevZ.nextZ = null, i$2.prevZ = null, function(t$3) {
						let e$3, r$3 = 1;
						do {
							let n$3, i$3 = t$3;
							t$3 = null;
							let s$2 = null;
							for (e$3 = 0; i$3;) {
								e$3++;
								let a$2 = i$3, o$2 = 0;
								for (let t$4 = 0; t$4 < r$3 && (o$2++, a$2 = a$2.nextZ, a$2); t$4++);
								let l$1 = r$3;
								for (; o$2 > 0 || l$1 > 0 && a$2;) 0 !== o$2 && (0 === l$1 || !a$2 || i$3.z <= a$2.z) ? (n$3 = i$3, i$3 = i$3.nextZ, o$2--) : (n$3 = a$2, a$2 = a$2.nextZ, l$1--), s$2 ? s$2.nextZ = n$3 : t$3 = n$3, n$3.prevZ = s$2, s$2 = n$3;
								i$3 = a$2;
							}
							s$2.nextZ = null, r$3 *= 2;
						} while (e$3 > 1);
					}(i$2);
				}(t$1, n$1, i$1, s$1);
				let o$1 = t$1;
				for (; t$1.prev !== t$1.next;) {
					const l$1 = t$1.prev, u$1 = t$1.next;
					if (s$1 ? Fl(t$1, n$1, i$1, s$1) : Vl(t$1)) e$1.push(l$1.i, t$1.i, u$1.i), tu(t$1), t$1 = u$1.next, o$1 = u$1.next;
					else if ((t$1 = u$1) === o$1) {
						a$1 ? 1 === a$1 ? Bl(t$1 = Dl(Tl(t$1), e$1), e$1, r$1, n$1, i$1, s$1, 2) : 2 === a$1 && $l(t$1, e$1, r$1, n$1, i$1, s$1) : Bl(Tl(t$1), e$1, r$1, n$1, i$1, s$1, 1);
						break;
					}
				}
			}
			function Vl(t$1) {
				const e$1 = t$1.prev, r$1 = t$1, n$1 = t$1.next;
				if (Xl(e$1, r$1, n$1) >= 0) return !1;
				const i$1 = e$1.x, s$1 = r$1.x, a$1 = n$1.x, o$1 = e$1.y, l$1 = r$1.y, u$1 = n$1.y, c$1 = Math.min(i$1, s$1, a$1), h$1 = Math.min(o$1, l$1, u$1), p$1 = Math.max(i$1, s$1, a$1), f$1 = Math.max(o$1, l$1, u$1);
				let d$1 = n$1.next;
				for (; d$1 !== e$1;) {
					if (d$1.x >= c$1 && d$1.x <= p$1 && d$1.y >= h$1 && d$1.y <= f$1 && ql(i$1, o$1, s$1, l$1, a$1, u$1, d$1.x, d$1.y) && Xl(d$1.prev, d$1, d$1.next) >= 0) return !1;
					d$1 = d$1.next;
				}
				return !0;
			}
			function Fl(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.prev, s$1 = t$1, a$1 = t$1.next;
				if (Xl(i$1, s$1, a$1) >= 0) return !1;
				const o$1 = i$1.x, l$1 = s$1.x, u$1 = a$1.x, c$1 = i$1.y, h$1 = s$1.y, p$1 = a$1.y, f$1 = Math.min(o$1, l$1, u$1), d$1 = Math.min(c$1, h$1, p$1), y$1 = Math.max(o$1, l$1, u$1), m$1 = Math.max(c$1, h$1, p$1), g$1 = Ul(f$1, d$1, e$1, r$1, n$1), x$1 = Ul(y$1, m$1, e$1, r$1, n$1);
				let v$1 = t$1.prevZ, b$1 = t$1.nextZ;
				for (; v$1 && v$1.z >= g$1 && b$1 && b$1.z <= x$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a$1 && ql(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Xl(v$1.prev, v$1, v$1.next) >= 0) return !1;
					if (v$1 = v$1.prevZ, b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== a$1 && ql(o$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Xl(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				for (; v$1 && v$1.z >= g$1;) {
					if (v$1.x >= f$1 && v$1.x <= y$1 && v$1.y >= d$1 && v$1.y <= m$1 && v$1 !== i$1 && v$1 !== a$1 && ql(o$1, c$1, l$1, h$1, u$1, p$1, v$1.x, v$1.y) && Xl(v$1.prev, v$1, v$1.next) >= 0) return !1;
					v$1 = v$1.prevZ;
				}
				for (; b$1 && b$1.z <= x$1;) {
					if (b$1.x >= f$1 && b$1.x <= y$1 && b$1.y >= d$1 && b$1.y <= m$1 && b$1 !== i$1 && b$1 !== a$1 && ql(o$1, c$1, l$1, h$1, u$1, p$1, b$1.x, b$1.y) && Xl(b$1.prev, b$1, b$1.next) >= 0) return !1;
					b$1 = b$1.nextZ;
				}
				return !0;
			}
			function Dl(t$1, e$1) {
				let r$1 = t$1;
				do {
					const n$1 = r$1.prev, i$1 = r$1.next.next;
					!Zl(n$1, i$1) && Yl(n$1, r$1, r$1.next, i$1) && Jl(n$1, i$1) && Jl(i$1, n$1) && (e$1.push(n$1.i, r$1.i, i$1.i), tu(r$1), tu(r$1.next), r$1 = t$1 = i$1), r$1 = r$1.next;
				} while (r$1 !== t$1);
				return Tl(r$1);
			}
			function $l(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a$1 = t$1;
				do {
					let t$2 = a$1.next.next;
					for (; t$2 !== a$1.prev;) {
						if (a$1.i !== t$2.i && Gl(a$1, t$2)) {
							let o$1 = Wl(a$1, t$2);
							a$1 = Tl(a$1, a$1.next), o$1 = Tl(o$1, o$1.next), Bl(a$1, e$1, r$1, n$1, i$1, s$1, 0), Bl(o$1, e$1, r$1, n$1, i$1, s$1, 0);
							return;
						}
						t$2 = t$2.next;
					}
					a$1 = a$1.next;
				} while (a$1 !== t$1);
			}
			function Ll(t$1, e$1) {
				let r$1 = t$1.x - e$1.x;
				return 0 === r$1 && (r$1 = t$1.y - e$1.y, 0 === r$1) && (r$1 = (t$1.next.y - t$1.y) / (t$1.next.x - t$1.x) - (e$1.next.y - e$1.y) / (e$1.next.x - e$1.x)), r$1;
			}
			function Ol(t$1, e$1) {
				const r$1 = function(t$2, e$2) {
					let r$2 = e$2;
					const n$2 = t$2.x, i$1 = t$2.y;
					let s$1, a$1 = -Infinity;
					if (Zl(t$2, r$2)) return r$2;
					do {
						if (Zl(t$2, r$2.next)) return r$2.next;
						if (i$1 <= r$2.y && i$1 >= r$2.next.y && r$2.next.y !== r$2.y) {
							const t$3 = r$2.x + (i$1 - r$2.y) * (r$2.next.x - r$2.x) / (r$2.next.y - r$2.y);
							if (t$3 <= n$2 && t$3 > a$1 && (a$1 = t$3, s$1 = r$2.x < r$2.next.x ? r$2 : r$2.next, t$3 === n$2)) return s$1;
						}
						r$2 = r$2.next;
					} while (r$2 !== e$2);
					if (!s$1) return null;
					const o$1 = s$1, l$1 = s$1.x, u$1 = s$1.y;
					let c$1 = Infinity;
					r$2 = s$1;
					do {
						if (n$2 >= r$2.x && r$2.x >= l$1 && n$2 !== r$2.x && Nl(i$1 < u$1 ? n$2 : a$1, i$1, l$1, u$1, i$1 < u$1 ? a$1 : n$2, i$1, r$2.x, r$2.y)) {
							const e$3 = Math.abs(i$1 - r$2.y) / (n$2 - r$2.x);
							Jl(r$2, t$2) && (e$3 < c$1 || e$3 === c$1 && (r$2.x > s$1.x || r$2.x === s$1.x && Rl(s$1, r$2))) && (s$1 = r$2, c$1 = e$3);
						}
						r$2 = r$2.next;
					} while (r$2 !== o$1);
					return s$1;
				}(t$1, e$1);
				if (!r$1) return e$1;
				const n$1 = Wl(r$1, t$1);
				return Tl(n$1, n$1.next), Tl(r$1, r$1.next);
			}
			function Rl(t$1, e$1) {
				return Xl(t$1.prev, t$1, e$1.prev) < 0 && Xl(e$1.next, t$1, t$1.next) < 0;
			}
			function Ul(t$1, e$1, r$1, n$1, i$1) {
				return (t$1 = 1431655765 & ((t$1 = 858993459 & ((t$1 = 252645135 & ((t$1 = 16711935 & ((t$1 = (t$1 - r$1) * i$1 | 0) | t$1 << 8)) | t$1 << 4)) | t$1 << 2)) | t$1 << 1)) | (e$1 = 1431655765 & ((e$1 = 858993459 & ((e$1 = 252645135 & ((e$1 = 16711935 & ((e$1 = (e$1 - n$1) * i$1 | 0) | e$1 << 8)) | e$1 << 4)) | e$1 << 2)) | e$1 << 1)) << 1;
			}
			function jl(t$1) {
				let e$1 = t$1, r$1 = t$1;
				do
					(e$1.x < r$1.x || e$1.x === r$1.x && e$1.y < r$1.y) && (r$1 = e$1), e$1 = e$1.next;
				while (e$1 !== t$1);
				return r$1;
			}
			function Nl(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
				return (i$1 - a$1) * (e$1 - o$1) >= (t$1 - a$1) * (s$1 - o$1) && (t$1 - a$1) * (n$1 - o$1) >= (r$1 - a$1) * (e$1 - o$1) && (r$1 - a$1) * (s$1 - o$1) >= (i$1 - a$1) * (n$1 - o$1);
			}
			function ql(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
				return !(t$1 === a$1 && e$1 === o$1) && Nl(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1);
			}
			function Gl(t$1, e$1) {
				return t$1.next.i !== e$1.i && t$1.prev.i !== e$1.i && !function(t$2, e$2) {
					let r$1 = t$2;
					do {
						if (r$1.i !== t$2.i && r$1.next.i !== t$2.i && r$1.i !== e$2.i && r$1.next.i !== e$2.i && Yl(r$1, r$1.next, t$2, e$2)) return !0;
						r$1 = r$1.next;
					} while (r$1 !== t$2);
					return !1;
				}(t$1, e$1) && (Jl(t$1, e$1) && Jl(e$1, t$1) && function(t$2, e$2) {
					let r$1 = t$2, n$1 = !1;
					const i$1 = (t$2.x + e$2.x) / 2, s$1 = (t$2.y + e$2.y) / 2;
					do
						r$1.y > s$1 != r$1.next.y > s$1 && r$1.next.y !== r$1.y && i$1 < (r$1.next.x - r$1.x) * (s$1 - r$1.y) / (r$1.next.y - r$1.y) + r$1.x && (n$1 = !n$1), r$1 = r$1.next;
					while (r$1 !== t$2);
					return n$1;
				}(t$1, e$1) && (Xl(t$1.prev, t$1, e$1.prev) || Xl(t$1, e$1.prev, e$1)) || Zl(t$1, e$1) && Xl(t$1.prev, t$1, t$1.next) > 0 && Xl(e$1.prev, e$1, e$1.next) > 0);
			}
			function Xl(t$1, e$1, r$1) {
				return (e$1.y - t$1.y) * (r$1.x - e$1.x) - (e$1.x - t$1.x) * (r$1.y - e$1.y);
			}
			function Zl(t$1, e$1) {
				return t$1.x === e$1.x && t$1.y === e$1.y;
			}
			function Yl(t$1, e$1, r$1, n$1) {
				const i$1 = Kl(Xl(t$1, e$1, r$1)), s$1 = Kl(Xl(t$1, e$1, n$1)), a$1 = Kl(Xl(r$1, n$1, t$1)), o$1 = Kl(Xl(r$1, n$1, e$1));
				return i$1 !== s$1 && a$1 !== o$1 || !(0 !== i$1 || !Hl(t$1, r$1, e$1)) || !(0 !== s$1 || !Hl(t$1, n$1, e$1)) || !(0 !== a$1 || !Hl(r$1, t$1, n$1)) || !(0 !== o$1 || !Hl(r$1, e$1, n$1));
			}
			function Hl(t$1, e$1, r$1) {
				return e$1.x <= Math.max(t$1.x, r$1.x) && e$1.x >= Math.min(t$1.x, r$1.x) && e$1.y <= Math.max(t$1.y, r$1.y) && e$1.y >= Math.min(t$1.y, r$1.y);
			}
			function Kl(t$1) {
				return t$1 > 0 ? 1 : t$1 < 0 ? -1 : 0;
			}
			function Jl(t$1, e$1) {
				return Xl(t$1.prev, t$1, t$1.next) < 0 ? Xl(t$1, e$1, t$1.next) >= 0 && Xl(t$1, t$1.prev, e$1) >= 0 : Xl(t$1, e$1, t$1.prev) < 0 || Xl(t$1, t$1.next, e$1) < 0;
			}
			function Wl(t$1, e$1) {
				const r$1 = eu(t$1.i, t$1.x, t$1.y), n$1 = eu(e$1.i, e$1.x, e$1.y), i$1 = t$1.next, s$1 = e$1.prev;
				return t$1.next = e$1, e$1.prev = t$1, r$1.next = i$1, i$1.prev = r$1, n$1.next = r$1, r$1.prev = n$1, s$1.next = n$1, n$1.prev = s$1, n$1;
			}
			function Ql(t$1, e$1, r$1, n$1) {
				const i$1 = eu(t$1, e$1, r$1);
				return n$1 ? (i$1.next = n$1.next, i$1.prev = n$1, n$1.next.prev = i$1, n$1.next = i$1) : (i$1.prev = i$1, i$1.next = i$1), i$1;
			}
			function tu(t$1) {
				t$1.next.prev = t$1.prev, t$1.prev.next = t$1.next, t$1.prevZ && (t$1.prevZ.nextZ = t$1.nextZ), t$1.nextZ && (t$1.nextZ.prevZ = t$1.prevZ);
			}
			function eu(t$1, e$1, r$1) {
				return {
					i: t$1,
					x: e$1,
					y: r$1,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			class ru {
				constructor(t$1, e$1) {
					if (e$1 > t$1) throw new Error("Min granularity must not be greater than base granularity.");
					this._baseZoomGranularity = t$1, this._minGranularity = e$1;
				}
				getGranularityForZoomLevel(t$1) {
					return Math.max(Math.floor(this._baseZoomGranularity / (1 << t$1)), this._minGranularity, 1);
				}
			}
			class nu {
				constructor(t$1) {
					this.fill = t$1.fill, this.line = t$1.line, this.tile = t$1.tile, this.stencil = t$1.stencil, this.circle = t$1.circle;
				}
			}
			nu.noSubdivision = new nu({
				fill: new ru(0, 0),
				line: new ru(0, 0),
				tile: new ru(0, 0),
				stencil: new ru(0, 0),
				circle: 1
			}), os("SubdivisionGranularityExpression", ru), os("SubdivisionGranularitySetting", nu);
			const iu = -32768, su = 32767;
			class au {
				constructor(t$1, e$1) {
					this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t$1, this._granularityCellSize = P / t$1, this._canonical = e$1;
				}
				_getKey(t$1, e$1) {
					return (t$1 += 32768) << 16 | e$1 + 32768;
				}
				_vertexToIndex(t$1, e$1) {
					if (t$1 < -32768 || e$1 < -32768 || t$1 > 32767 || e$1 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
					const r$1 = 0 | Math.round(t$1), n$1 = 0 | Math.round(e$1), i$1 = this._getKey(r$1, n$1);
					if (this._vertexDictionary.has(i$1)) return this._vertexDictionary.get(i$1);
					const s$1 = this._vertexBuffer.length / 2;
					return this._vertexDictionary.set(i$1, s$1), this._vertexBuffer.push(r$1, n$1), s$1;
				}
				_subdivideTrianglesScanline(t$1) {
					if (this._granularity < 2) return function(t$2, e$2) {
						const r$2 = [];
						for (let n$1 = 0; n$1 < e$2.length; n$1 += 3) {
							const i$1 = e$2[n$1], s$1 = e$2[n$1 + 1], a$1 = e$2[n$1 + 2], o$1 = t$2[2 * i$1], l$1 = t$2[2 * i$1 + 1];
							(t$2[2 * s$1] - o$1) * (t$2[2 * a$1 + 1] - l$1) - (t$2[2 * s$1 + 1] - l$1) * (t$2[2 * a$1] - o$1) > 0 ? (r$2.push(i$1), r$2.push(a$1), r$2.push(s$1)) : (r$2.push(i$1), r$2.push(s$1), r$2.push(a$1));
						}
						return r$2;
					}(this._vertexBuffer, t$1);
					const e$1 = [], r$1 = t$1.length;
					for (let n$1 = 0; n$1 < r$1; n$1 += 3) {
						const r$2 = [
							t$1[n$1 + 0],
							t$1[n$1 + 1],
							t$1[n$1 + 2]
						], i$1 = [
							this._vertexBuffer[2 * t$1[n$1 + 0] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 0] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 1] + 1],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 0],
							this._vertexBuffer[2 * t$1[n$1 + 2] + 1]
						];
						let s$1 = Infinity, a$1 = Infinity, o$1 = -Infinity, l$1 = -Infinity;
						for (let t$2 = 0; t$2 < 3; t$2++) {
							const e$2 = i$1[2 * t$2], r$3 = i$1[2 * t$2 + 1];
							s$1 = Math.min(s$1, e$2), o$1 = Math.max(o$1, e$2), a$1 = Math.min(a$1, r$3), l$1 = Math.max(l$1, r$3);
						}
						if (s$1 === o$1 || a$1 === l$1) continue;
						const u$1 = Math.floor(s$1 / this._granularityCellSize), c$1 = Math.ceil(o$1 / this._granularityCellSize), h$1 = Math.floor(a$1 / this._granularityCellSize), p$1 = Math.ceil(l$1 / this._granularityCellSize);
						if (u$1 !== c$1 || h$1 !== p$1) for (let t$2 = h$1; t$2 < p$1; t$2++) {
							const n$2 = this._scanlineGenerateVertexRingForCellRow(t$2, i$1, r$2);
							uu(this._vertexBuffer, n$2, e$1);
						}
						else e$1.push(...r$2);
					}
					return e$1;
				}
				_scanlineGenerateVertexRingForCellRow(t$1, e$1, r$1) {
					const n$1 = t$1 * this._granularityCellSize, i$1 = n$1 + this._granularityCellSize, s$1 = [];
					for (let t$2 = 0; t$2 < 3; t$2++) {
						const a$1 = e$1[2 * t$2], o$1 = e$1[2 * t$2 + 1], l$1 = e$1[2 * (t$2 + 1) % 6], u$1 = e$1[(2 * (t$2 + 1) + 1) % 6], c$1 = e$1[2 * (t$2 + 2) % 6], h$1 = e$1[(2 * (t$2 + 2) + 1) % 6], p$1 = l$1 - a$1, f$1 = u$1 - o$1, d$1 = 0 === p$1, y$1 = 0 === f$1, m$1 = (n$1 - o$1) / f$1, g$1 = (i$1 - o$1) / f$1, x$1 = Math.min(m$1, g$1), v$1 = Math.max(m$1, g$1);
						if (!y$1 && (x$1 >= 1 || v$1 <= 0) || y$1 && (o$1 < n$1 || o$1 > i$1)) {
							u$1 >= n$1 && u$1 <= i$1 && s$1.push(r$1[(t$2 + 1) % 3]);
							continue;
						}
						!y$1 && x$1 > 0 && s$1.push(this._vertexToIndex(a$1 + p$1 * x$1, o$1 + f$1 * x$1));
						const b$1 = a$1 + p$1 * Math.max(x$1, 0), w$1 = a$1 + p$1 * Math.min(v$1, 1);
						d$1 || this._generateIntraEdgeVertices(s$1, a$1, o$1, l$1, u$1, b$1, w$1), !y$1 && v$1 < 1 && s$1.push(this._vertexToIndex(a$1 + p$1 * v$1, o$1 + f$1 * v$1)), (y$1 || u$1 >= n$1 && u$1 <= i$1) && s$1.push(r$1[(t$2 + 1) % 3]), !y$1 && (u$1 <= n$1 || u$1 >= i$1) && this._generateInterEdgeVertices(s$1, a$1, o$1, l$1, u$1, c$1, h$1, w$1, n$1, i$1);
					}
					return s$1;
				}
				_generateIntraEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = n$1 - e$1, l$1 = i$1 - r$1, u$1 = 0 === l$1, c$1 = u$1 ? Math.min(e$1, n$1) : Math.min(s$1, a$1), h$1 = u$1 ? Math.max(e$1, n$1) : Math.max(s$1, a$1), p$1 = Math.floor(c$1 / this._granularityCellSize) + 1, f$1 = Math.ceil(h$1 / this._granularityCellSize) - 1;
					if (u$1 ? e$1 < n$1 : s$1 < a$1) for (let n$2 = p$1; n$2 <= f$1; n$2++) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
					else for (let n$2 = f$1; n$2 >= p$1; n$2--) {
						const i$2 = n$2 * this._granularityCellSize;
						t$1.push(this._vertexToIndex(i$2, r$1 + l$1 * (i$2 - e$1) / o$1));
					}
				}
				_generateInterEdgeVertices(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1) {
					const c$1 = i$1 - r$1, h$1 = s$1 - n$1, p$1 = a$1 - i$1, f$1 = (l$1 - i$1) / p$1, d$1 = (u$1 - i$1) / p$1, y$1 = Math.min(f$1, d$1), m$1 = Math.max(f$1, d$1), g$1 = n$1 + h$1 * y$1;
					let x$1 = Math.floor(Math.min(g$1, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(g$1, o$1) / this._granularityCellSize) - 1, b$1 = o$1 < g$1;
					const w$1 = 0 === p$1;
					if (w$1 && (a$1 === l$1 || a$1 === u$1)) return;
					if (w$1 || y$1 >= 1 || m$1 <= 0) {
						const t$2 = r$1 - a$1, n$2 = s$1 + (e$1 - s$1) * Math.min((l$1 - a$1) / t$2, (u$1 - a$1) / t$2);
						x$1 = Math.floor(Math.min(n$2, o$1) / this._granularityCellSize) + 1, v$1 = Math.ceil(Math.max(n$2, o$1) / this._granularityCellSize) - 1, b$1 = o$1 < n$2;
					}
					const _$1 = c$1 > 0 ? u$1 : l$1;
					if (b$1) for (let e$2 = x$1; e$2 <= v$1; e$2++) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$1));
					else for (let e$2 = v$1; e$2 >= x$1; e$2--) t$1.push(this._vertexToIndex(e$2 * this._granularityCellSize, _$1));
				}
				_generateOutline(t$1) {
					const e$1 = [];
					for (const r$1 of t$1) {
						const t$2 = lu(r$1, this._granularity, !0), n$1 = this._pointArrayToIndices(t$2), i$1 = [];
						for (let t$3 = 1; t$3 < n$1.length; t$3++) i$1.push(n$1[t$3 - 1]), i$1.push(n$1[t$3]);
						e$1.push(i$1);
					}
					return e$1;
				}
				_handlePoles(t$1) {
					let e$1 = !1, r$1 = !1;
					this._canonical && (0 === this._canonical.y && (e$1 = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (r$1 = !0)), (e$1 || r$1) && this._fillPoles(t$1, e$1, r$1);
				}
				_ensureNoPoleVertices() {
					const t$1 = this._vertexBuffer;
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) {
						const r$1 = t$1[e$1 + 1];
						r$1 === iu && (t$1[e$1 + 1] = -32767), r$1 === su && (t$1[e$1 + 1] = 32766);
					}
				}
				_generatePoleQuad(t$1, e$1, r$1, n$1, i$1, s$1) {
					n$1 > i$1 != (s$1 === iu) ? (t$1.push(e$1), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(this._vertexToIndex(n$1, s$1))) : (t$1.push(r$1), t$1.push(e$1), t$1.push(this._vertexToIndex(n$1, s$1)), t$1.push(this._vertexToIndex(i$1, s$1)), t$1.push(r$1), t$1.push(this._vertexToIndex(n$1, s$1)));
				}
				_fillPoles(t$1, e$1, r$1) {
					const n$1 = this._vertexBuffer, i$1 = P, s$1 = t$1.length;
					for (let a$1 = 2; a$1 < s$1; a$1 += 3) {
						const s$2 = t$1[a$1 - 2], o$1 = t$1[a$1 - 1], l$1 = t$1[a$1], u$1 = n$1[2 * s$2], c$1 = n$1[2 * s$2 + 1], h$1 = n$1[2 * o$1], p$1 = n$1[2 * o$1 + 1], f$1 = n$1[2 * l$1], d$1 = n$1[2 * l$1 + 1];
						e$1 && (0 === c$1 && 0 === p$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, iu), 0 === p$1 && 0 === d$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, iu), 0 === d$1 && 0 === c$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, iu)), r$1 && (c$1 === i$1 && p$1 === i$1 && this._generatePoleQuad(t$1, s$2, o$1, u$1, h$1, su), p$1 === i$1 && d$1 === i$1 && this._generatePoleQuad(t$1, o$1, l$1, h$1, f$1, su), d$1 === i$1 && c$1 === i$1 && this._generatePoleQuad(t$1, l$1, s$2, f$1, u$1, su));
					}
				}
				_initializeVertices(t$1) {
					for (let e$1 = 0; e$1 < t$1.length; e$1 += 2) this._vertexToIndex(t$1[e$1], t$1[e$1 + 1]);
				}
				subdividePolygonInternal(t$1, e$1) {
					if (this._used) throw new Error("Subdivision: multiple use not allowed.");
					this._used = !0;
					const { flattened: r$1, holeIndices: n$1 } = function(t$2) {
						const e$2 = [], r$2 = [];
						for (const n$2 of t$2) if (0 !== n$2.length) {
							n$2 !== t$2[0] && e$2.push(r$2.length / 2);
							for (let t$3 = 0; t$3 < n$2.length; t$3++) r$2.push(n$2[t$3].x), r$2.push(n$2[t$3].y);
						}
						return {
							flattened: r$2,
							holeIndices: e$2
						};
					}(t$1);
					let i$1;
					this._initializeVertices(r$1);
					try {
						const t$2 = function(t$3, e$3, r$2 = 2) {
							const n$2 = e$3 && e$3.length, i$2 = n$2 ? e$3[0] * r$2 : t$3.length;
							let s$2 = El(t$3, 0, i$2, r$2, !0);
							const a$1 = [];
							if (!s$2 || s$2.next === s$2.prev) return a$1;
							let o$1, l$1, u$1;
							if (n$2 && (s$2 = function(t$4, e$4, r$3, n$3) {
								const i$3 = [];
								for (let r$4 = 0, s$3 = e$4.length; r$4 < s$3; r$4++) {
									const a$2 = El(t$4, e$4[r$4] * n$3, r$4 < s$3 - 1 ? e$4[r$4 + 1] * n$3 : t$4.length, n$3, !1);
									a$2 === a$2.next && (a$2.steiner = !0), i$3.push(jl(a$2));
								}
								i$3.sort(Ll);
								for (let t$5 = 0; t$5 < i$3.length; t$5++) r$3 = Ol(i$3[t$5], r$3);
								return r$3;
							}(t$3, e$3, s$2, r$2)), t$3.length > 80 * r$2) {
								o$1 = t$3[0], l$1 = t$3[1];
								let e$4 = o$1, n$3 = l$1;
								for (let s$3 = r$2; s$3 < i$2; s$3 += r$2) {
									const r$3 = t$3[s$3], i$3 = t$3[s$3 + 1];
									r$3 < o$1 && (o$1 = r$3), i$3 < l$1 && (l$1 = i$3), r$3 > e$4 && (e$4 = r$3), i$3 > n$3 && (n$3 = i$3);
								}
								u$1 = Math.max(e$4 - o$1, n$3 - l$1), u$1 = 0 !== u$1 ? 32767 / u$1 : 0;
							}
							return Bl(s$2, a$1, r$2, o$1, l$1, u$1, 0), a$1;
						}(r$1, n$1), e$2 = this._convertIndices(r$1, t$2);
						i$1 = this._subdivideTrianglesScanline(e$2);
					} catch (t$2) {
						console.error(t$2);
					}
					let s$1 = [];
					return e$1 && (s$1 = this._generateOutline(t$1)), this._ensureNoPoleVertices(), this._handlePoles(i$1), {
						verticesFlattened: this._vertexBuffer,
						indicesTriangles: i$1,
						indicesLineList: s$1
					};
				}
				_convertIndices(t$1, e$1) {
					const r$1 = [];
					for (let n$1 = 0; n$1 < e$1.length; n$1++) r$1.push(this._vertexToIndex(t$1[2 * e$1[n$1]], t$1[2 * e$1[n$1] + 1]));
					return r$1;
				}
				_pointArrayToIndices(t$1) {
					const e$1 = [];
					for (let r$1 = 0; r$1 < t$1.length; r$1++) {
						const n$1 = t$1[r$1];
						e$1.push(this._vertexToIndex(n$1.x, n$1.y));
					}
					return e$1;
				}
			}
			function ou(t$1, e$1, r$1, n$1 = !0) {
				return new au(r$1, e$1).subdividePolygonInternal(t$1, n$1);
			}
			function lu(t$1, e$1, n$1 = !1) {
				if (!t$1 || t$1.length < 1) return [];
				if (t$1.length < 2) return [];
				const i$1 = t$1[0], s$1 = t$1[t$1.length - 1], a$1 = n$1 && (i$1.x !== s$1.x || i$1.y !== s$1.y);
				if (e$1 < 2) return a$1 ? [...t$1, t$1[0]] : [...t$1];
				const o$1 = Math.floor(P / e$1), l$1 = [];
				l$1.push(new r(t$1[0].x, t$1[0].y));
				const u$1 = t$1.length, c$1 = a$1 ? u$1 : u$1 - 1;
				for (let e$2 = 0; e$2 < c$1; e$2++) {
					const n$2 = t$1[e$2], i$2 = e$2 < u$1 - 1 ? t$1[e$2 + 1] : t$1[0], s$2 = n$2.x, a$2 = n$2.y, c$2 = i$2.x, h$1 = i$2.y, p$1 = s$2 !== c$2, f$1 = a$2 !== h$1;
					if (!p$1 && !f$1) continue;
					const d$1 = c$2 - s$2, y$1 = h$1 - a$2, m$1 = Math.abs(d$1), g$1 = Math.abs(y$1);
					let x$1 = s$2, v$1 = a$2;
					for (;;) {
						const t$2 = d$1 > 0 ? (Math.floor(x$1 / o$1) + 1) * o$1 : (Math.ceil(x$1 / o$1) - 1) * o$1, e$3 = y$1 > 0 ? (Math.floor(v$1 / o$1) + 1) * o$1 : (Math.ceil(v$1 / o$1) - 1) * o$1, n$3 = Math.abs(x$1 - t$2), i$3 = Math.abs(v$1 - e$3), s$3 = Math.abs(x$1 - c$2), a$3 = Math.abs(v$1 - h$1), u$2 = p$1 ? n$3 / m$1 : Number.POSITIVE_INFINITY, b$2 = f$1 ? i$3 / g$1 : Number.POSITIVE_INFINITY;
						if ((s$3 <= n$3 || !p$1) && (a$3 <= i$3 || !f$1)) break;
						if (u$2 < b$2 && p$1 || !f$1) {
							x$1 = t$2, v$1 += y$1 * u$2;
							const e$4 = new r(x$1, Math.round(v$1));
							l$1[l$1.length - 1].x === e$4.x && l$1[l$1.length - 1].y === e$4.y || l$1.push(e$4);
						} else {
							x$1 += d$1 * b$2, v$1 = e$3;
							const t$3 = new r(Math.round(x$1), v$1);
							l$1[l$1.length - 1].x === t$3.x && l$1[l$1.length - 1].y === t$3.y || l$1.push(t$3);
						}
					}
					const b$1 = new r(c$2, h$1);
					l$1[l$1.length - 1].x === b$1.x && l$1[l$1.length - 1].y === b$1.y || l$1.push(b$1);
				}
				return l$1;
			}
			function uu(t$1, e$1, r$1) {
				if (0 === e$1.length) throw new Error("Subdivision vertex ring is empty.");
				let n$1 = 0, i$1 = t$1[2 * e$1[0]];
				for (let r$2 = 1; r$2 < e$1.length; r$2++) {
					const s$2 = t$1[2 * e$1[r$2]];
					s$2 < i$1 && (i$1 = s$2, n$1 = r$2);
				}
				const s$1 = e$1.length;
				let a$1 = n$1, o$1 = (a$1 + 1) % s$1;
				for (;;) {
					const n$2 = a$1 - 1 >= 0 ? a$1 - 1 : s$1 - 1, i$2 = (o$1 + 1) % s$1, l$1 = t$1[2 * e$1[n$2]], u$1 = t$1[2 * e$1[i$2]], c$1 = t$1[2 * e$1[a$1]], h$1 = t$1[2 * e$1[a$1] + 1], p$1 = t$1[2 * e$1[o$1] + 1];
					let f$1 = !1;
					if (l$1 < u$1) f$1 = !0;
					else if (l$1 > u$1) f$1 = !1;
					else {
						const r$2 = p$1 - h$1, s$2 = -(t$1[2 * e$1[o$1]] - c$1), a$2 = h$1 < p$1 ? 1 : -1;
						((l$1 - c$1) * r$2 + (t$1[2 * e$1[n$2] + 1] - h$1) * s$2) * a$2 > ((u$1 - c$1) * r$2 + (t$1[2 * e$1[i$2] + 1] - h$1) * s$2) * a$2 && (f$1 = !0);
					}
					if (f$1) {
						const t$2 = e$1[n$2], i$3 = e$1[a$1], l$2 = e$1[o$1];
						t$2 !== i$3 && t$2 !== l$2 && i$3 !== l$2 && r$1.push(l$2, i$3, t$2), a$1--, a$1 < 0 && (a$1 = s$1 - 1);
					} else {
						const t$2 = e$1[i$2], n$3 = e$1[a$1], l$2 = e$1[o$1];
						t$2 !== n$3 && t$2 !== l$2 && n$3 !== l$2 && r$1.push(l$2, n$3, t$2), o$1++, o$1 >= s$1 && (o$1 = 0);
					}
					if (n$2 === i$2) break;
				}
			}
			function cu(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
				const u$1 = i$1.length / 2, c$1 = a$1 && o$1 && l$1;
				if (u$1 < Ka.MAX_VERTEX_ARRAY_LENGTH) {
					const h$1 = e$1.prepareSegment(u$1, r$1, n$1), p$1 = h$1.vertexLength;
					for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) n$1.emplaceBack(p$1 + s$1[t$2], p$1 + s$1[t$2 + 1], p$1 + s$1[t$2 + 2]);
					let f$1, d$1;
					h$1.vertexLength += u$1, h$1.primitiveLength += s$1.length / 3, c$1 && (d$1 = a$1.prepareSegment(u$1, r$1, o$1), f$1 = d$1.vertexLength, d$1.vertexLength += u$1);
					for (let e$2 = 0; e$2 < i$1.length; e$2 += 2) t$1(i$1[e$2], i$1[e$2 + 1]);
					if (c$1) for (let t$2 = 0; t$2 < l$1.length; t$2++) {
						const e$2 = l$1[t$2];
						for (let t$3 = 1; t$3 < e$2.length; t$3 += 2) o$1.emplaceBack(f$1 + e$2[t$3 - 1], f$1 + e$2[t$3]);
						d$1.primitiveLength += e$2.length / 2;
					}
				} else (function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$2 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$2.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 2; h$1 < i$2.length; h$1 += 3) {
						const p$1 = i$2[h$1 - 2], f$1 = i$2[h$1 - 1], d$1 = i$2[h$1];
						let y$1 = a$2[p$1] < l$2, m$1 = a$2[f$1] < l$2, g$1 = a$2[d$1] < l$2;
						u$2.vertexLength + ((y$1 ? 1 : 0) + (m$1 ? 1 : 0) + (g$1 ? 1 : 0)) > Ka.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, y$1 = !0, m$1 = !0, g$1 = !0, c$2 = 0);
						const x$1 = hu(a$2, n$2, s$2, o$2, p$1, y$1, u$2), v$1 = hu(a$2, n$2, s$2, o$2, f$1, m$1, u$2), b$1 = hu(a$2, n$2, s$2, o$2, d$1, g$1, u$2);
						r$2.emplaceBack(c$2 + x$1 - l$2, c$2 + v$1 - l$2, c$2 + b$1 - l$2), u$2.primitiveLength++;
					}
				})(e$1, r$1, n$1, i$1, s$1, t$1), c$1 && function(t$2, e$2, r$2, n$2, i$2, s$2) {
					const a$2 = [];
					for (let t$3 = 0; t$3 < n$2.length / 2; t$3++) a$2.push(-1);
					const o$2 = { count: 0 };
					let l$2 = 0, u$2 = t$2.getOrCreateLatestSegment(e$2, r$2), c$2 = u$2.vertexLength;
					for (let h$1 = 0; h$1 < i$2.length; h$1++) {
						const p$1 = i$2[h$1];
						for (let f$1 = 1; f$1 < i$2[h$1].length; f$1 += 2) {
							const i$3 = p$1[f$1 - 1], h$2 = p$1[f$1];
							let d$1 = a$2[i$3] < l$2, y$1 = a$2[h$2] < l$2;
							u$2.vertexLength + ((d$1 ? 1 : 0) + (y$1 ? 1 : 0)) > Ka.MAX_VERTEX_ARRAY_LENGTH && (u$2 = t$2.createNewSegment(e$2, r$2), l$2 = o$2.count, d$1 = !0, y$1 = !0, c$2 = 0);
							const m$1 = hu(a$2, n$2, s$2, o$2, i$3, d$1, u$2), g$1 = hu(a$2, n$2, s$2, o$2, h$2, y$1, u$2);
							r$2.emplaceBack(c$2 + m$1 - l$2, c$2 + g$1 - l$2), u$2.primitiveLength++;
						}
					}
				}(a$1, r$1, o$1, i$1, l$1, t$1), e$1.forceNewSegmentOnNextPrepare(), a$1?.forceNewSegmentOnNextPrepare();
			}
			function hu(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
				if (s$1) {
					const s$2 = n$1.count;
					return r$1(e$1[2 * i$1], e$1[2 * i$1 + 1]), t$1[i$1] = n$1.count, n$1.count++, a$1.vertexLength++, s$2;
				}
				return t$1[i$1];
			}
			class pu {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new Fa(), this.indexArray = new Xa(), this.indexArray2 = new Za(), this.programConfigurations = new Io(t$1.layers, t$1.zoom), this.segments = new Ka(), this.segments2 = new Ka(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Pl("fill", this.layers, e$1);
					const n$1 = this.layers[0].layout.get("fill-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: a$1, id: o$1, index: l$1, sourceLayerIndex: u$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, c$1 = Bo(a$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new zs(this.zoom), c$1, r$1)) continue;
						const h$1 = i$1 ? n$1.evaluate(c$1, {}, r$1, e$1.availableImages) : void 0, p$1 = {
							id: o$1,
							properties: a$1.properties,
							type: a$1.type,
							sourceLayerIndex: u$1,
							index: l$1,
							geometry: t$2 ? c$1.geometry : To(a$1),
							patterns: {},
							sortKey: h$1
						};
						s$1.push(p$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a$1 } = n$2;
						if (this.hasDependencies) {
							const t$2 = Cl("fill", this.layers, n$2, { zoom: this.zoom }, e$1);
							this.patternFeatures.push(t$2);
						} else this.addFeature(n$2, i$2, s$2, r$1, {}, e$1.subdivisionGranularity);
						e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a$1, this.index);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.patternFeatures) this.addFeature(n$1, n$1.geometry, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, zl), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t$1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const t$2 of Qr(e$1, 500)) {
						const e$2 = ou(t$2, n$1, s$1.fill.getGranularityForZoomLevel(n$1.z)), r$2 = this.layoutVertexArray;
						cu(((t$3, e$3) => {
							r$2.emplaceBack(t$3, e$3);
						}), this.segments, this.layoutVertexArray, this.indexArray, e$2.verticesFlattened, e$2.indicesTriangles, this.segments2, this.indexArray2, e$2.indicesLineList);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
			}
			let fu, du;
			os("FillBucket", pu, { omit: ["layers", "patternFeatures"] });
			var yu = {
				get paint() {
					return du = du || new Ns({
						"fill-antialias": new Ls(xt.paint_fill["fill-antialias"]),
						"fill-opacity": new Os(xt.paint_fill["fill-opacity"]),
						"fill-color": new Os(xt.paint_fill["fill-color"]),
						"fill-outline-color": new Os(xt.paint_fill["fill-outline-color"]),
						"fill-translate": new Ls(xt.paint_fill["fill-translate"]),
						"fill-translate-anchor": new Ls(xt.paint_fill["fill-translate-anchor"]),
						"fill-pattern": new Rs(xt.paint_fill["fill-pattern"])
					});
				},
				get layout() {
					return fu = fu || new Ns({ "fill-sort-key": new Os(xt.layout_fill["fill-sort-key"]) });
				}
			};
			class mu extends Gs {
				constructor(t$1, e$1) {
					super(t$1, yu, e$1);
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1);
					const r$1 = this.paint._values["fill-outline-color"];
					"constant" === r$1.value.kind && void 0 === r$1.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
				}
				createBucket(t$1) {
					return new pu(t$1);
				}
				queryRadius() {
					return Ho(this.paint.get("fill-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, geometry: e$1, transform: r$1, pixelsToTileUnits: n$1 }) {
					return Oo(Ko(t$1, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r$1.bearingInRadians, n$1), e$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			const gu = Hs([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_normal_ed",
				components: 4,
				type: "Int16"
			}], 4), xu = Hs([{
				name: "a_centroid",
				components: 2,
				type: "Int16"
			}], 4), { members: vu } = gu;
			class bu {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.properties = {}, this.extent = r$1, this.type = 0, this.id = void 0, this._pbf = t$1, this._geometry = -1, this._keys = n$1, this._values = i$1, t$1.readFields(wu, this, e$1);
				}
				loadGeometry() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos, n$1 = [];
					let i$1, s$1 = 1, a$1 = 0, o$1 = 0, l$1 = 0;
					for (; t$1.pos < e$1;) {
						if (a$1 <= 0) {
							const e$2 = t$1.readVarint();
							s$1 = 7 & e$2, a$1 = e$2 >> 3;
						}
						if (a$1--, 1 === s$1 || 2 === s$1) o$1 += t$1.readSVarint(), l$1 += t$1.readSVarint(), 1 === s$1 && (i$1 && n$1.push(i$1), i$1 = []), i$1 && i$1.push(new r(o$1, l$1));
						else {
							if (7 !== s$1) throw new Error(`unknown command ${s$1}`);
							i$1 && i$1.push(i$1[0].clone());
						}
					}
					return i$1 && n$1.push(i$1), n$1;
				}
				bbox() {
					const t$1 = this._pbf;
					t$1.pos = this._geometry;
					const e$1 = t$1.readVarint() + t$1.pos;
					let r$1 = 1, n$1 = 0, i$1 = 0, s$1 = 0, a$1 = Infinity, o$1 = -Infinity, l$1 = Infinity, u$1 = -Infinity;
					for (; t$1.pos < e$1;) {
						if (n$1 <= 0) {
							const e$2 = t$1.readVarint();
							r$1 = 7 & e$2, n$1 = e$2 >> 3;
						}
						if (n$1--, 1 === r$1 || 2 === r$1) i$1 += t$1.readSVarint(), s$1 += t$1.readSVarint(), i$1 < a$1 && (a$1 = i$1), i$1 > o$1 && (o$1 = i$1), s$1 < l$1 && (l$1 = s$1), s$1 > u$1 && (u$1 = s$1);
						else if (7 !== r$1) throw new Error(`unknown command ${r$1}`);
					}
					return [
						a$1,
						l$1,
						o$1,
						u$1
					];
				}
				toGeoJSON(t$1, e$1, r$1) {
					const n$1 = this.extent * Math.pow(2, r$1), i$1 = this.extent * t$1, s$1 = this.extent * e$1, a$1 = this.loadGeometry();
					function o$1(t$2) {
						return [360 * (t$2.x + i$1) / n$1 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t$2.y + s$1) / n$1) * Math.PI)) - 90];
					}
					function l$1(t$2) {
						return t$2.map(o$1);
					}
					let u$1;
					if (1 === this.type) {
						const t$2 = [];
						for (const e$3 of a$1) t$2.push(e$3[0]);
						const e$2 = l$1(t$2);
						u$1 = 1 === t$2.length ? {
							type: "Point",
							coordinates: e$2[0]
						} : {
							type: "MultiPoint",
							coordinates: e$2
						};
					} else if (2 === this.type) {
						const t$2 = a$1.map(l$1);
						u$1 = 1 === t$2.length ? {
							type: "LineString",
							coordinates: t$2[0]
						} : {
							type: "MultiLineString",
							coordinates: t$2
						};
					} else {
						if (3 !== this.type) throw new Error("unknown feature type");
						{
							const t$2 = function(t$3) {
								const e$3 = t$3.length;
								if (e$3 <= 1) return [t$3];
								const r$2 = [];
								let n$2, i$2;
								for (let s$2 = 0; s$2 < e$3; s$2++) {
									const e$4 = _u(t$3[s$2]);
									0 !== e$4 && (void 0 === i$2 && (i$2 = e$4 < 0), i$2 === e$4 < 0 ? (n$2 && r$2.push(n$2), n$2 = [t$3[s$2]]) : n$2 && n$2.push(t$3[s$2]));
								}
								return n$2 && r$2.push(n$2), r$2;
							}(a$1), e$2 = [];
							for (const r$2 of t$2) e$2.push(r$2.map(l$1));
							u$1 = 1 === e$2.length ? {
								type: "Polygon",
								coordinates: e$2[0]
							} : {
								type: "MultiPolygon",
								coordinates: e$2
							};
						}
					}
					const c$1 = {
						type: "Feature",
						geometry: u$1,
						properties: this.properties
					};
					return null != this.id && (c$1.id = this.id), c$1;
				}
			}
			function wu(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? function(t$2, e$2) {
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = e$2._keys[t$2.readVarint()], n$1 = e$2._values[t$2.readVarint()];
						e$2.properties[r$3] = n$1;
					}
				}(r$1, e$1) : 3 === t$1 ? e$1.type = r$1.readVarint() : 4 === t$1 && (e$1._geometry = r$1.pos);
			}
			function _u(t$1) {
				let e$1 = 0;
				for (let r$1, n$1, i$1 = 0, s$1 = t$1.length, a$1 = s$1 - 1; i$1 < s$1; a$1 = i$1++) r$1 = t$1[i$1], n$1 = t$1[a$1], e$1 += (n$1.x - r$1.x) * (r$1.y + n$1.y);
				return e$1;
			}
			bu.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Su {
				constructor(t$1, e$1) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t$1, this._keys = [], this._values = [], this._features = [], t$1.readFields(Au, this, e$1), this.length = this._features.length;
				}
				feature(t$1) {
					if (t$1 < 0 || t$1 >= this._features.length) throw new Error("feature index out of bounds");
					this._pbf.pos = this._features[t$1];
					const e$1 = this._pbf.readVarint() + this._pbf.pos;
					return new bu(this._pbf, e$1, this.extent, this._keys, this._values);
				}
			}
			function Au(t$1, e$1, r$1) {
				15 === t$1 ? e$1.version = r$1.readVarint() : 1 === t$1 ? e$1.name = r$1.readString() : 5 === t$1 ? e$1.extent = r$1.readVarint() : 2 === t$1 ? e$1._features.push(r$1.pos) : 3 === t$1 ? e$1._keys.push(r$1.readString()) : 4 === t$1 && e$1._values.push(function(t$2) {
					let e$2 = null;
					const r$2 = t$2.readVarint() + t$2.pos;
					for (; t$2.pos < r$2;) {
						const r$3 = t$2.readVarint() >> 3;
						e$2 = 1 === r$3 ? t$2.readString() : 2 === r$3 ? t$2.readFloat() : 3 === r$3 ? t$2.readDouble() : 4 === r$3 ? t$2.readVarint64() : 5 === r$3 ? t$2.readVarint() : 6 === r$3 ? t$2.readSVarint() : 7 === r$3 ? t$2.readBoolean() : null;
					}
					if (null == e$2) throw new Error("unknown feature value");
					return e$2;
				}(r$1));
			}
			class ku {
				constructor(t$1, e$1) {
					this.layers = t$1.readFields(Mu, {}, e$1);
				}
			}
			function Mu(t$1, e$1, r$1) {
				if (3 === t$1) {
					const t$2 = new Su(r$1, r$1.readVarint() + r$1.pos);
					t$2.length && (e$1[t$2.name] = t$2);
				}
			}
			const Iu = Math.pow(2, 13);
			function zu(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
				t$1.emplaceBack(e$1, r$1, 2 * Math.floor(n$1 * Iu) + a$1, i$1 * Iu * 2, s$1 * Iu * 2, Math.round(o$1));
			}
			class Pu {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.layoutVertexArray = new Da(), this.centroidVertexArray = new Ba(), this.indexArray = new Xa(), this.programConfigurations = new Io(t$1.layers, t$1.zoom), this.segments = new Ka(), this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.features = [], this.hasDependencies = Pl("fill-extrusion", this.layers, e$1);
					for (const { feature: n$1, id: i$1, index: s$1, sourceLayerIndex: a$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, o$1 = Bo(n$1, t$2);
						if (!this.layers[0]._featureFilter.filter(new zs(this.zoom), o$1, r$1)) continue;
						const l$1 = {
							id: i$1,
							sourceLayerIndex: a$1,
							index: s$1,
							geometry: t$2 ? o$1.geometry : To(n$1),
							properties: n$1.properties,
							type: n$1.type,
							patterns: {}
						};
						this.hasDependencies ? this.features.push(Cl("fill-extrusion", this.layers, l$1, { zoom: this.zoom }, e$1)) : this.addFeature(l$1, l$1.geometry, s$1, r$1, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(n$1, l$1.geometry, s$1, a$1, this.index, !0);
					}
				}
				addFeatures(t$1, e$1, r$1) {
					for (const n$1 of this.features) {
						const { geometry: i$1 } = n$1;
						this.addFeature(n$1, i$1, n$1.index, e$1, r$1, t$1.subdivisionGranularity);
					}
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, { imagePositions: r$1 });
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, vu), this.centroidVertexBuffer = t$1.createVertexBuffer(this.centroidVertexArray, xu.members, !0), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1) {
					for (const r$2 of Qr(e$1, 500)) {
						const e$2 = {
							x: 0,
							y: 0,
							sampleCount: 0
						}, i$2 = this.layoutVertexArray.length;
						this.processPolygon(e$2, n$1, t$1, r$2, s$1);
						const a$1 = this.layoutVertexArray.length - i$2, o$1 = Math.floor(e$2.x / e$2.sampleCount), l$1 = Math.floor(e$2.y / e$2.sampleCount);
						for (let t$2 = 0; t$2 < a$1; t$2++) this.centroidVertexArray.emplaceBack(o$1, l$1);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						canonical: n$1
					});
				}
				processPolygon(t$1, e$1, r$1, n$1, i$1) {
					if (n$1.length < 1) return;
					if (Tu(n$1[0])) return;
					for (const e$2 of n$1) 0 !== e$2.length && Cu(t$1, e$2);
					const s$1 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a$1 = i$1.fill.getGranularityForZoomLevel(e$1.z), o$1 = "Polygon" === bu.types[r$1.type];
					for (const t$2 of n$1) {
						if (0 === t$2.length) continue;
						if (Tu(t$2)) continue;
						const e$2 = lu(t$2, a$1, o$1);
						this._generateSideFaces(e$2, s$1);
					}
					if (!o$1) return;
					const l$1 = ou(n$1, e$1, a$1, !1), u$1 = this.layoutVertexArray;
					cu(((t$2, e$2) => {
						zu(u$1, t$2, e$2, 0, 0, 1, 1, 0);
					}), this.segments, this.layoutVertexArray, this.indexArray, l$1.verticesFlattened, l$1.indicesTriangles);
				}
				_generateSideFaces(t$1, e$1) {
					let r$1 = 0;
					for (let n$1 = 1; n$1 < t$1.length; n$1++) {
						const i$1 = t$1[n$1], s$1 = t$1[n$1 - 1];
						if (Eu(i$1, s$1)) continue;
						e$1.segment.vertexLength + 4 > Ka.MAX_VERTEX_ARRAY_LENGTH && (e$1.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
						const a$1 = i$1.sub(s$1)._perp()._unit(), o$1 = s$1.dist(i$1);
						r$1 + o$1 > 32768 && (r$1 = 0), zu(this.layoutVertexArray, i$1.x, i$1.y, a$1.x, a$1.y, 0, 0, r$1), zu(this.layoutVertexArray, i$1.x, i$1.y, a$1.x, a$1.y, 0, 1, r$1), r$1 += o$1, zu(this.layoutVertexArray, s$1.x, s$1.y, a$1.x, a$1.y, 0, 0, r$1), zu(this.layoutVertexArray, s$1.x, s$1.y, a$1.x, a$1.y, 0, 1, r$1);
						const l$1 = e$1.segment.vertexLength;
						this.indexArray.emplaceBack(l$1, l$1 + 2, l$1 + 1), this.indexArray.emplaceBack(l$1 + 1, l$1 + 2, l$1 + 3), e$1.segment.vertexLength += 4, e$1.segment.primitiveLength += 2;
					}
				}
			}
			function Cu(t$1, e$1) {
				for (let r$1 = 0; r$1 < e$1.length; r$1++) {
					const n$1 = e$1[r$1];
					r$1 === e$1.length - 1 && e$1[0].x === n$1.x && e$1[0].y === n$1.y || (t$1.x += n$1.x, t$1.y += n$1.y, t$1.sampleCount++);
				}
			}
			function Eu(t$1, e$1) {
				return t$1.x === e$1.x && (t$1.x < 0 || t$1.x > P) || t$1.y === e$1.y && (t$1.y < 0 || t$1.y > P);
			}
			function Tu(t$1) {
				return t$1.every(((t$2) => t$2.x < 0)) || t$1.every(((t$2) => t$2.x > P)) || t$1.every(((t$2) => t$2.y < 0)) || t$1.every(((t$2) => t$2.y > P));
			}
			let Bu;
			os("FillExtrusionBucket", Pu, { omit: ["layers", "features"] });
			var Vu = { get paint() {
				return Bu = Bu || new Ns({
					"fill-extrusion-opacity": new Ls(xt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
					"fill-extrusion-color": new Os(xt["paint_fill-extrusion"]["fill-extrusion-color"]),
					"fill-extrusion-translate": new Ls(xt["paint_fill-extrusion"]["fill-extrusion-translate"]),
					"fill-extrusion-translate-anchor": new Ls(xt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
					"fill-extrusion-pattern": new Rs(xt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
					"fill-extrusion-height": new Os(xt["paint_fill-extrusion"]["fill-extrusion-height"]),
					"fill-extrusion-base": new Os(xt["paint_fill-extrusion"]["fill-extrusion-base"]),
					"fill-extrusion-vertical-gradient": new Ls(xt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
				});
			} };
			class Fu extends Gs {
				constructor(t$1, e$1) {
					super(t$1, Vu, e$1);
				}
				createBucket(t$1) {
					return new Pu(t$1);
				}
				queryRadius() {
					return Ho(this.paint.get("fill-extrusion-translate"));
				}
				is3D() {
					return !0;
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a$1, pixelPosMatrix: o$1 }) {
					const l$1 = Ko(t$1, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s$1.bearingInRadians, a$1), u$1 = this.paint.get("fill-extrusion-height").evaluate(e$1, n$1), c$1 = this.paint.get("fill-extrusion-base").evaluate(e$1, n$1), h$1 = function(t$2, e$2) {
						const n$2 = [];
						for (const i$2 of t$2) {
							const t$3 = [
								i$2.x,
								i$2.y,
								0,
								1
							];
							A(t$3, t$3, e$2), n$2.push(new r(t$3[0] / t$3[3], t$3[1] / t$3[3]));
						}
						return n$2;
					}(l$1, o$1), p$1 = function(t$2, e$2, n$2, i$2) {
						const s$2 = [], a$2 = [], o$2 = i$2[8] * e$2, l$2 = i$2[9] * e$2, u$2 = i$2[10] * e$2, c$2 = i$2[11] * e$2, h$2 = i$2[8] * n$2, p$2 = i$2[9] * n$2, f$1 = i$2[10] * n$2, d$1 = i$2[11] * n$2;
						for (const e$3 of t$2) {
							const t$3 = [], n$3 = [];
							for (const s$3 of e$3) {
								const e$4 = s$3.x, a$3 = s$3.y, y$1 = i$2[0] * e$4 + i$2[4] * a$3 + i$2[12], m$1 = i$2[1] * e$4 + i$2[5] * a$3 + i$2[13], g$1 = i$2[2] * e$4 + i$2[6] * a$3 + i$2[14], x$1 = i$2[3] * e$4 + i$2[7] * a$3 + i$2[15], v$1 = g$1 + u$2, b$1 = x$1 + c$2, w$1 = y$1 + h$2, _$1 = m$1 + p$2, S$1 = g$1 + f$1, A$1 = x$1 + d$1, k$1 = new r((y$1 + o$2) / b$1, (m$1 + l$2) / b$1);
								k$1.z = v$1 / b$1, t$3.push(k$1);
								const M$1 = new r(w$1 / A$1, _$1 / A$1);
								M$1.z = S$1 / A$1, n$3.push(M$1);
							}
							s$2.push(t$3), a$2.push(n$3);
						}
						return [s$2, a$2];
					}(i$1, c$1, u$1, o$1);
					return function(t$2, e$2, r$1) {
						let n$2 = Infinity;
						Oo(r$1, e$2) && (n$2 = $u(r$1, e$2[0]));
						for (let i$2 = 0; i$2 < e$2.length; i$2++) {
							const s$2 = e$2[i$2], a$2 = t$2[i$2];
							for (let t$3 = 0; t$3 < s$2.length - 1; t$3++) {
								const e$3 = s$2[t$3], i$3 = [
									e$3,
									s$2[t$3 + 1],
									a$2[t$3 + 1],
									a$2[t$3],
									e$3
								];
								$o(r$1, i$3) && (n$2 = Math.min(n$2, $u(r$1, i$3)));
							}
						}
						return n$2 !== Infinity && n$2;
					}(p$1[0], p$1[1], h$1);
				}
			}
			function Du(t$1, e$1) {
				return t$1.x * e$1.x + t$1.y * e$1.y;
			}
			function $u(t$1, e$1) {
				if (1 === t$1.length) {
					let r$1 = 0;
					const n$1 = e$1[r$1++];
					let i$1;
					for (; !i$1 || n$1.equals(i$1);) if (i$1 = e$1[r$1++], !i$1) return Infinity;
					for (; r$1 < e$1.length; r$1++) {
						const s$1 = e$1[r$1], a$1 = t$1[0], o$1 = i$1.sub(n$1), l$1 = s$1.sub(n$1), u$1 = a$1.sub(n$1), c$1 = Du(o$1, o$1), h$1 = Du(o$1, l$1), p$1 = Du(l$1, l$1), f$1 = Du(u$1, o$1), d$1 = Du(u$1, l$1), y$1 = c$1 * p$1 - h$1 * h$1, m$1 = (p$1 * f$1 - h$1 * d$1) / y$1, g$1 = (c$1 * d$1 - h$1 * f$1) / y$1, x$1 = n$1.z * (1 - m$1 - g$1) + i$1.z * m$1 + s$1.z * g$1;
						if (isFinite(x$1)) return x$1;
					}
					return Infinity;
				}
				{
					let t$2 = Infinity;
					for (const r$1 of e$1) t$2 = Math.min(t$2, r$1.z);
					return t$2;
				}
			}
			const { members: Ou } = Hs([{
				name: "a_pos_normal",
				components: 2,
				type: "Int16"
			}, {
				name: "a_data",
				components: 4,
				type: "Uint8"
			}], 4), { members: Uu } = Hs([{
				name: "a_uv_x",
				components: 1,
				type: "Float32"
			}, {
				name: "a_split_index",
				components: 1,
				type: "Float32"
			}]), ju = Math.cos(Math.PI / 180 * 37.5), Nu = Math.pow(2, 14) / .5;
			class qu {
				constructor(t$1) {
					this.zoom = t$1.zoom, this.overscaling = t$1.overscaling, this.layers = t$1.layers, this.layerIds = this.layers.map(((t$2) => t$2.id)), this.index = t$1.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((t$2) => {
						this.gradients[t$2.id] = {};
					})), this.layoutVertexArray = new $a(), this.layoutVertexArray2 = new La(), this.indexArray = new Xa(), this.programConfigurations = new Io(t$1.layers, t$1.zoom), this.segments = new Ka(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((t$2) => t$2.isStateDependent())).map(((t$2) => t$2.id));
				}
				populate(t$1, e$1, r$1) {
					this.hasDependencies = Pl("line", this.layers, e$1) || this.hasLineDasharray(this.layers);
					const n$1 = this.layers[0].layout.get("line-sort-key"), i$1 = !n$1.isConstant(), s$1 = [];
					for (const { feature: e$2, id: a$1, index: o$1, sourceLayerIndex: l$1 } of t$1) {
						const t$2 = this.layers[0]._featureFilter.needGeometry, u$1 = Bo(e$2, t$2);
						if (!this.layers[0]._featureFilter.filter(new zs(this.zoom), u$1, r$1)) continue;
						const c$1 = i$1 ? n$1.evaluate(u$1, {}, r$1) : void 0, h$1 = {
							id: a$1,
							properties: e$2.properties,
							type: e$2.type,
							sourceLayerIndex: l$1,
							index: o$1,
							geometry: t$2 ? u$1.geometry : To(e$2),
							patterns: {},
							dashes: {},
							sortKey: c$1
						};
						s$1.push(h$1);
					}
					i$1 && s$1.sort(((t$2, e$2) => t$2.sortKey - e$2.sortKey));
					for (const n$2 of s$1) {
						const { geometry: i$2, index: s$2, sourceLayerIndex: a$1 } = n$2;
						this.hasDependencies ? (Pl("line", this.layers, e$1) ? Cl("line", this.layers, n$2, { zoom: this.zoom }, e$1) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, n$2, this.zoom, e$1), this.patternFeatures.push(n$2)) : this.addFeature(n$2, i$2, s$2, r$1, {}, {}, e$1.subdivisionGranularity), e$1.featureIndex.insert(t$1[s$2].feature, i$2, s$2, a$1, this.index);
					}
				}
				update(t$1, e$1, r$1, n$1) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t$1, e$1, this.stateDependentLayers, {
						imagePositions: r$1,
						dashPositions: n$1
					});
				}
				addFeatures(t$1, e$1, r$1, n$1) {
					for (const i$1 of this.patternFeatures) this.addFeature(i$1, i$1.geometry, i$1.index, e$1, r$1, n$1, t$1.subdivisionGranularity);
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(t$1) {
					this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t$1.createVertexBuffer(this.layoutVertexArray2, Uu)), this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Ou), this.indexBuffer = t$1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t$1), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(t$1) {
					if (t$1.properties && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t$1.properties, "mapbox_clip_end")) return {
						start: +t$1.properties.mapbox_clip_start,
						end: +t$1.properties.mapbox_clip_end
					};
				}
				addFeature(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
					const o$1 = this.layers[0].layout, l$1 = o$1.get("line-join").evaluate(t$1, {}), u$1 = o$1.get("line-cap"), c$1 = o$1.get("line-miter-limit"), h$1 = o$1.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(t$1);
					for (const r$2 of e$1) this.addLine(r$2, t$1, l$1, u$1, c$1, h$1, n$1, a$1);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t$1, r$1, {
						imagePositions: i$1,
						dashPositions: s$1,
						canonical: n$1
					});
				}
				addLine(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
					if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t$1 = lu(t$1, a$1 ? o$1.line.getGranularityForZoomLevel(a$1.z) : 1), this.lineClips) {
						this.lineClipsArray.push(this.lineClips);
						for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) this.totalDistance += t$1[e$2].dist(t$1[e$2 + 1]);
						this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
					}
					const l$1 = "Polygon" === bu.types[e$1.type];
					let u$1 = t$1.length;
					for (; u$1 >= 2 && t$1[u$1 - 1].equals(t$1[u$1 - 2]);) u$1--;
					let c$1 = 0;
					for (; c$1 < u$1 - 1 && t$1[c$1].equals(t$1[c$1 + 1]);) c$1++;
					if (u$1 < (l$1 ? 3 : 2)) return;
					"bevel" === r$1 && (i$1 = 1.05);
					const h$1 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p$1 = this.segments.prepareSegment(10 * u$1, this.layoutVertexArray, this.indexArray);
					let f$1, d$1, y$1, m$1, g$1;
					this.e1 = this.e2 = -1, l$1 && (f$1 = t$1[u$1 - 2], g$1 = t$1[c$1].sub(f$1)._unit()._perp());
					for (let e$2 = c$1; e$2 < u$1; e$2++) {
						if (y$1 = e$2 === u$1 - 1 ? l$1 ? t$1[c$1 + 1] : void 0 : t$1[e$2 + 1], y$1 && t$1[e$2].equals(y$1)) continue;
						g$1 && (m$1 = g$1), f$1 && (d$1 = f$1), f$1 = t$1[e$2], g$1 = y$1 ? y$1.sub(f$1)._unit()._perp() : m$1, m$1 = m$1 || g$1;
						let a$2 = m$1.add(g$1);
						0 === a$2.x && 0 === a$2.y || a$2._unit();
						const o$2 = m$1.x * g$1.x + m$1.y * g$1.y, x$1 = a$2.x * g$1.x + a$2.y * g$1.y, v$1 = 0 !== x$1 ? 1 / x$1 : Infinity, b$1 = 2 * Math.sqrt(2 - 2 * x$1), w$1 = x$1 < ju && d$1 && y$1, _$1 = m$1.x * g$1.y - m$1.y * g$1.x > 0;
						if (w$1 && e$2 > c$1) {
							const t$2 = f$1.dist(d$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.sub(f$1.sub(d$1)._mult(h$1 / t$2)._round());
								this.updateDistance(d$1, e$3), this.addCurrentVertex(e$3, m$1, 0, 0, p$1), d$1 = e$3;
							}
						}
						const S$1 = d$1 && y$1;
						let A$1 = S$1 ? r$1 : l$1 ? "butt" : n$1;
						if (S$1 && "round" === A$1 && (v$1 < s$1 ? A$1 = "miter" : v$1 <= 2 && (A$1 = "fakeround")), "miter" === A$1 && v$1 > i$1 && (A$1 = "bevel"), "bevel" === A$1 && (v$1 > 2 && (A$1 = "flipbevel"), v$1 < i$1 && (A$1 = "miter")), d$1 && this.updateDistance(d$1, f$1), "miter" === A$1) a$2._mult(v$1), this.addCurrentVertex(f$1, a$2, 0, 0, p$1);
						else if ("flipbevel" === A$1) {
							if (v$1 > 100) a$2 = g$1.mult(-1);
							else {
								const t$2 = v$1 * m$1.add(g$1).mag() / m$1.sub(g$1).mag();
								a$2._perp()._mult(t$2 * (_$1 ? -1 : 1));
							}
							this.addCurrentVertex(f$1, a$2, 0, 0, p$1), this.addCurrentVertex(f$1, a$2.mult(-1), 0, 0, p$1);
						} else if ("bevel" === A$1 || "fakeround" === A$1) {
							const t$2 = -Math.sqrt(v$1 * v$1 - 1), e$3 = _$1 ? t$2 : 0, r$2 = _$1 ? 0 : t$2;
							if (d$1 && this.addCurrentVertex(f$1, m$1, e$3, r$2, p$1), "fakeround" === A$1) {
								const t$3 = Math.round(180 * b$1 / Math.PI / 20);
								for (let e$4 = 1; e$4 < t$3; e$4++) {
									let r$3 = e$4 / t$3;
									if (.5 !== r$3) {
										const t$4 = r$3 - .5;
										r$3 += r$3 * t$4 * (r$3 - 1) * ((1.0904 + o$2 * (o$2 * (3.55645 - 1.43519 * o$2) - 3.2452)) * t$4 * t$4 + (.848013 + o$2 * (.215638 * o$2 - 1.06021)));
									}
									const n$2 = g$1.sub(m$1)._mult(r$3)._add(m$1)._unit()._mult(_$1 ? -1 : 1);
									this.addHalfVertex(f$1, n$2.x, n$2.y, !1, _$1, 0, p$1);
								}
							}
							y$1 && this.addCurrentVertex(f$1, g$1, -e$3, -r$2, p$1);
						} else if ("butt" === A$1) this.addCurrentVertex(f$1, a$2, 0, 0, p$1);
						else if ("square" === A$1) {
							const t$2 = d$1 ? 1 : -1;
							this.addCurrentVertex(f$1, a$2, t$2, t$2, p$1);
						} else "round" === A$1 && (d$1 && (this.addCurrentVertex(f$1, m$1, 0, 0, p$1), this.addCurrentVertex(f$1, m$1, 1, 1, p$1, !0)), y$1 && (this.addCurrentVertex(f$1, g$1, -1, -1, p$1, !0), this.addCurrentVertex(f$1, g$1, 0, 0, p$1)));
						if (w$1 && e$2 < u$1 - 1) {
							const t$2 = f$1.dist(y$1);
							if (t$2 > 2 * h$1) {
								const e$3 = f$1.add(y$1.sub(f$1)._mult(h$1 / t$2)._round());
								this.updateDistance(f$1, e$3), this.addCurrentVertex(e$3, g$1, 0, 0, p$1), f$1 = e$3;
							}
						}
					}
				}
				addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1 = !1) {
					const a$1 = e$1.y * n$1 - e$1.x, o$1 = -e$1.y - e$1.x * n$1;
					this.addHalfVertex(t$1, e$1.x + e$1.y * r$1, e$1.y - e$1.x * r$1, s$1, !1, r$1, i$1), this.addHalfVertex(t$1, a$1, o$1, s$1, !0, -n$1, i$1), this.distance > Nu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t$1, e$1, r$1, n$1, i$1, s$1));
				}
				addHalfVertex({ x: t$1, y: e$1 }, r$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = .5 * (this.lineClips ? this.scaledDistance * (Nu - 1) : this.scaledDistance);
					this.layoutVertexArray.emplaceBack((t$1 << 1) + (i$1 ? 1 : 0), (e$1 << 1) + (s$1 ? 1 : 0), Math.round(63 * r$1) + 128, Math.round(63 * n$1) + 128, 1 + (0 === a$1 ? 0 : a$1 < 0 ? -1 : 1) | (63 & l$1) << 2, l$1 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
					const u$1 = o$1.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u$1, this.e2), o$1.primitiveLength++), s$1 ? this.e2 = u$1 : this.e1 = u$1;
				}
				updateScaledDistance() {
					this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
				}
				updateDistance(t$1, e$1) {
					this.distance += t$1.dist(e$1), this.updateScaledDistance();
				}
				hasLineDasharray(t$1) {
					for (const e$1 of t$1) {
						const t$2 = e$1.paint.get("line-dasharray");
						if (t$2 && !t$2.isConstant()) return !0;
					}
					return !1;
				}
				addLineDashDependencies(t$1, e$1, r$1, n$1) {
					for (const i$1 of t$1) {
						const t$2 = i$1.paint.get("line-dasharray");
						if (!t$2 || "constant" === t$2.value.kind) continue;
						const s$1 = "round" === i$1.layout.get("line-cap"), a$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 - 1 }, e$1, {}),
							round: s$1
						}, o$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 }, e$1, {}),
							round: s$1
						}, l$1 = {
							dasharray: t$2.value.evaluate({ zoom: r$1 + 1 }, e$1, {}),
							round: s$1
						}, u$1 = `${a$1.dasharray.join(",")},${a$1.round}`, c$1 = `${o$1.dasharray.join(",")},${o$1.round}`, h$1 = `${l$1.dasharray.join(",")},${l$1.round}`;
						n$1.dashDependencies[u$1] = a$1, n$1.dashDependencies[c$1] = o$1, n$1.dashDependencies[h$1] = l$1, e$1.dashes[i$1.id] = {
							min: u$1,
							mid: c$1,
							max: h$1
						};
					}
				}
			}
			let Gu, Xu;
			os("LineBucket", qu, { omit: ["layers", "patternFeatures"] });
			var Zu = {
				get paint() {
					return Xu = Xu || new Ns({
						"line-opacity": new Os(xt.paint_line["line-opacity"]),
						"line-color": new Os(xt.paint_line["line-color"]),
						"line-translate": new Ls(xt.paint_line["line-translate"]),
						"line-translate-anchor": new Ls(xt.paint_line["line-translate-anchor"]),
						"line-width": new Os(xt.paint_line["line-width"]),
						"line-gap-width": new Os(xt.paint_line["line-gap-width"]),
						"line-offset": new Os(xt.paint_line["line-offset"]),
						"line-blur": new Os(xt.paint_line["line-blur"]),
						"line-dasharray": new Rs(xt.paint_line["line-dasharray"]),
						"line-pattern": new Rs(xt.paint_line["line-pattern"]),
						"line-gradient": new js(xt.paint_line["line-gradient"])
					});
				},
				get layout() {
					return Gu = Gu || new Ns({
						"line-cap": new Ls(xt.layout_line["line-cap"]),
						"line-join": new Os(xt.layout_line["line-join"]),
						"line-miter-limit": new Ls(xt.layout_line["line-miter-limit"]),
						"line-round-limit": new Ls(xt.layout_line["line-round-limit"]),
						"line-sort-key": new Os(xt.layout_line["line-sort-key"])
					});
				}
			};
			class Yu extends Os {
				possiblyEvaluate(t$1, e$1) {
					return e$1 = new zs(Math.floor(e$1.zoom), {
						now: e$1.now,
						fadeDuration: e$1.fadeDuration,
						zoomHistory: e$1.zoomHistory,
						transition: e$1.transition
					}), super.possiblyEvaluate(t$1, e$1);
				}
				evaluate(t$1, e$1, r$1, n$1) {
					return e$1 = L({}, e$1, { zoom: Math.floor(e$1.zoom) }), super.evaluate(t$1, e$1, r$1, n$1);
				}
			}
			let Hu;
			class Ku extends Gs {
				constructor(t$1, e$1) {
					super(t$1, Zu, e$1), this.gradientVersion = 0, Hu || (Hu = new Yu(Zu.paint.properties["line-width"].specification), Hu.useIntegerZoom = !0);
				}
				_handleSpecialPaintPropertyUpdate(t$1) {
					if ("line-gradient" === t$1) {
						const t$2 = this.gradientExpression();
						this.stepInterpolant = !!function(t$3) {
							return void 0 !== t$3._styleExpression;
						}(t$2) && t$2._styleExpression.expression instanceof ar, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
					}
				}
				gradientExpression() {
					return this._transitionablePaint._values["line-gradient"].value.expression;
				}
				recalculate(t$1, e$1) {
					super.recalculate(t$1, e$1), this.paint._values["line-floorwidth"] = Hu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t$1);
				}
				createBucket(t$1) {
					return new qu(t$1);
				}
				queryRadius(t$1) {
					const e$1 = t$1, r$1 = Ju(Yo("line-width", this, e$1), Yo("line-gap-width", this, e$1)), n$1 = Yo("line-offset", this, e$1);
					return r$1 / 2 + Math.abs(n$1) + Ho(this.paint.get("line-translate"));
				}
				queryIntersectsFeature({ queryGeometry: t$1, feature: e$1, featureState: n$1, geometry: i$1, transform: s$1, pixelsToTileUnits: a$1 }) {
					const o$1 = Ko(t$1, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s$1.bearingInRadians, a$1), l$1 = a$1 / 2 * Ju(this.paint.get("line-width").evaluate(e$1, n$1), this.paint.get("line-gap-width").evaluate(e$1, n$1)), u$1 = this.paint.get("line-offset").evaluate(e$1, n$1);
					return u$1 && (i$1 = function(t$2, e$2) {
						const n$2 = [];
						for (let i$2 = 0; i$2 < t$2.length; i$2++) {
							const s$2 = t$2[i$2], a$2 = [];
							for (let t$3 = 0; t$3 < s$2.length; t$3++) {
								const n$3 = s$2[t$3 - 1], i$3 = s$2[t$3], o$2 = s$2[t$3 + 1], l$2 = 0 === t$3 ? new r(0, 0) : i$3.sub(n$3)._unit()._perp(), u$2 = t$3 === s$2.length - 1 ? new r(0, 0) : o$2.sub(i$3)._unit()._perp(), c$1 = l$2._add(u$2)._unit(), h$1 = c$1.x * u$2.x + c$1.y * u$2.y;
								0 !== h$1 && c$1._mult(1 / h$1), a$2.push(c$1._mult(e$2)._add(i$3));
							}
							n$2.push(a$2);
						}
						return n$2;
					}(i$1, u$1 * a$1)), function(t$2, e$2, r$1) {
						for (let n$2 = 0; n$2 < e$2.length; n$2++) {
							const i$2 = e$2[n$2];
							if (t$2.length >= 3) {
								for (let e$3 = 0; e$3 < i$2.length; e$3++) if (Xo(t$2, i$2[e$3])) return !0;
							}
							if (Ro(t$2, i$2, r$1)) return !0;
						}
						return !1;
					}(o$1, i$1, l$1);
				}
				isTileClipped() {
					return !0;
				}
			}
			function Ju(t$1, e$1) {
				return e$1 > 0 ? e$1 + 2 * t$1 : t$1;
			}
			const Wu = Hs([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), Qu = Hs([{
				name: "a_projected_pos",
				components: 3,
				type: "Float32"
			}], 4);
			Hs([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			const tc = Hs([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_box_real",
					components: 2,
					type: "Int16"
				}
			]);
			Hs([
				{
					type: "Int16",
					name: "anchorPointX"
				},
				{
					type: "Int16",
					name: "anchorPointY"
				},
				{
					type: "Int16",
					name: "x1"
				},
				{
					type: "Int16",
					name: "y1"
				},
				{
					type: "Int16",
					name: "x2"
				},
				{
					type: "Int16",
					name: "y2"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			const ec = Hs([
				{
					name: "a_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), rc = Hs([
				{
					name: "a_pos",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			function nc(t$1, e$1, r$1) {
				return t$1.sections.forEach(((t$2) => {
					t$2.text = function(t$3, e$2, r$2) {
						const n$1 = e$2.layout.get("text-transform").evaluate(r$2, {});
						return "uppercase" === n$1 ? t$3 = t$3.toLocaleUpperCase() : "lowercase" === n$1 && (t$3 = t$3.toLocaleLowerCase()), Is.applyArabicShaping && (t$3 = Is.applyArabicShaping(t$3)), t$3;
					}(t$2.text, e$1, r$1);
				})), t$1;
			}
			Hs([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), Hs([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				}
			]), Hs([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					name: "textBoxScale"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetStartIndex"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetEndIndex"
				}
			]), Hs([{
				type: "Float32",
				name: "offsetX"
			}]), Hs([
				{
					type: "Int16",
					name: "x"
				},
				{
					type: "Int16",
					name: "y"
				},
				{
					type: "Int16",
					name: "tileUnitDistanceFromAnchor"
				}
			]), Hs([{
				type: "Uint16",
				name: "textAnchor"
			}, {
				type: "Float32",
				components: 2,
				name: "textOffset"
			}]);
			const ic = {
				"!": "︕",
				"#": "＃",
				$: "＄",
				"%": "％",
				"&": "＆",
				"(": "︵",
				")": "︶",
				"*": "＊",
				"+": "＋",
				",": "︐",
				"-": "︲",
				".": "・",
				"/": "／",
				":": "︓",
				";": "︔",
				"<": "︿",
				"=": "＝",
				">": "﹀",
				"?": "︖",
				"@": "＠",
				"[": "﹇",
				"\\": "＼",
				"]": "﹈",
				"^": "＾",
				_: "︳",
				"`": "｀",
				"{": "︷",
				"|": "―",
				"}": "︸",
				"~": "～",
				"¢": "￠",
				"£": "￡",
				"¥": "￥",
				"¦": "￤",
				"¬": "￢",
				"¯": "￣",
				"–": "︲",
				"—": "︱",
				"‘": "﹃",
				"’": "﹄",
				"“": "﹁",
				"”": "﹂",
				"…": "︙",
				"‧": "・",
				"₩": "￦",
				"、": "︑",
				"。": "︒",
				"〈": "︿",
				"〉": "﹀",
				"《": "︽",
				"》": "︾",
				"「": "﹁",
				"」": "﹂",
				"『": "﹃",
				"』": "﹄",
				"【": "︻",
				"】": "︼",
				"〔": "︹",
				"〕": "︺",
				"〖": "︗",
				"〗": "︘",
				"！": "︕",
				"（": "︵",
				"）": "︶",
				"，": "︐",
				"－": "︲",
				"．": "・",
				"：": "︓",
				"；": "︔",
				"＜": "︿",
				"＞": "﹀",
				"？": "︖",
				"［": "﹇",
				"］": "﹈",
				"＿": "︳",
				"｛": "︷",
				"｜": "―",
				"｝": "︸",
				"｟": "︵",
				"｠": "︶",
				"｡": "︒",
				"｢": "﹁",
				"｣": "﹂"
			};
			var sc = 24;
			const ac = 4294967296, oc = 1 / ac, lc = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
			class uc {
				constructor(t$1 = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(t$1) ? t$1 : new Uint8Array(t$1), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(t$1, e$1, r$1 = this.length) {
					for (; this.pos < r$1;) {
						const r$2 = this.readVarint(), n$1 = r$2 >> 3, i$1 = this.pos;
						this.type = 7 & r$2, t$1(n$1, e$1, this), this.pos === i$1 && this.skip(r$2);
					}
					return e$1;
				}
				readMessage(t$1, e$1) {
					return this.readFields(t$1, e$1, this.readVarint() + this.pos);
				}
				readFixed32() {
					const t$1 = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readSFixed32() {
					const t$1 = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * ac;
					return this.pos += 8, t$1;
				}
				readSFixed64() {
					const t$1 = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * ac;
					return this.pos += 8, t$1;
				}
				readFloat() {
					const t$1 = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, t$1;
				}
				readDouble() {
					const t$1 = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, t$1;
				}
				readVarint(t$1) {
					const e$1 = this.buf;
					let r$1, n$1;
					return n$1 = e$1[this.pos++], r$1 = 127 & n$1, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 7, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 14, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos++], r$1 |= (127 & n$1) << 21, n$1 < 128 ? r$1 : (n$1 = e$1[this.pos], r$1 |= (15 & n$1) << 28, function(t$2, e$2, r$2) {
						const n$2 = r$2.buf;
						let i$1, s$1;
						if (s$1 = n$2[r$2.pos++], i$1 = (112 & s$1) >> 4, s$1 < 128) return cc(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 3, s$1 < 128) return cc(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 10, s$1 < 128) return cc(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 17, s$1 < 128) return cc(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (127 & s$1) << 24, s$1 < 128) return cc(t$2, i$1, e$2);
						if (s$1 = n$2[r$2.pos++], i$1 |= (1 & s$1) << 31, s$1 < 128) return cc(t$2, i$1, e$2);
						throw new Error("Expected varint not more than 10 bytes");
					}(r$1, t$1, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					const t$1 = this.readVarint();
					return t$1 % 2 == 1 ? (t$1 + 1) / -2 : t$1 / 2;
				}
				readBoolean() {
					return Boolean(this.readVarint());
				}
				readString() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.pos;
					return this.pos = t$1, t$1 - e$1 >= 12 && lc ? lc.decode(this.buf.subarray(e$1, t$1)) : function(t$2, e$2, r$1) {
						let n$1 = "", i$1 = e$2;
						for (; i$1 < r$1;) {
							const e$3 = t$2[i$1];
							let s$1, a$1, o$1, l$1 = null, u$1 = e$3 > 239 ? 4 : e$3 > 223 ? 3 : e$3 > 191 ? 2 : 1;
							if (i$1 + u$1 > r$1) break;
							1 === u$1 ? e$3 < 128 && (l$1 = e$3) : 2 === u$1 ? (s$1 = t$2[i$1 + 1], 128 == (192 & s$1) && (l$1 = (31 & e$3) << 6 | 63 & s$1, l$1 <= 127 && (l$1 = null))) : 3 === u$1 ? (s$1 = t$2[i$1 + 1], a$1 = t$2[i$1 + 2], 128 == (192 & s$1) && 128 == (192 & a$1) && (l$1 = (15 & e$3) << 12 | (63 & s$1) << 6 | 63 & a$1, (l$1 <= 2047 || l$1 >= 55296 && l$1 <= 57343) && (l$1 = null))) : 4 === u$1 && (s$1 = t$2[i$1 + 1], a$1 = t$2[i$1 + 2], o$1 = t$2[i$1 + 3], 128 == (192 & s$1) && 128 == (192 & a$1) && 128 == (192 & o$1) && (l$1 = (15 & e$3) << 18 | (63 & s$1) << 12 | (63 & a$1) << 6 | 63 & o$1, (l$1 <= 65535 || l$1 >= 1114112) && (l$1 = null))), null === l$1 ? (l$1 = 65533, u$1 = 1) : l$1 > 65535 && (l$1 -= 65536, n$1 += String.fromCharCode(l$1 >>> 10 & 1023 | 55296), l$1 = 56320 | 1023 & l$1), n$1 += String.fromCharCode(l$1), i$1 += u$1;
						}
						return n$1;
					}(this.buf, e$1, t$1);
				}
				readBytes() {
					const t$1 = this.readVarint() + this.pos, e$1 = this.buf.subarray(this.pos, t$1);
					return this.pos = t$1, e$1;
				}
				readPackedVarint(t$1 = [], e$1) {
					const r$1 = this.readPackedEnd();
					for (; this.pos < r$1;) t$1.push(this.readVarint(e$1));
					return t$1;
				}
				readPackedSVarint(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSVarint());
					return t$1;
				}
				readPackedBoolean(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readBoolean());
					return t$1;
				}
				readPackedFloat(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFloat());
					return t$1;
				}
				readPackedDouble(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readDouble());
					return t$1;
				}
				readPackedFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed32());
					return t$1;
				}
				readPackedSFixed32(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed32());
					return t$1;
				}
				readPackedFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readFixed64());
					return t$1;
				}
				readPackedSFixed64(t$1 = []) {
					const e$1 = this.readPackedEnd();
					for (; this.pos < e$1;) t$1.push(this.readSFixed64());
					return t$1;
				}
				readPackedEnd() {
					return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(t$1) {
					const e$1 = 7 & t$1;
					if (0 === e$1) for (; this.buf[this.pos++] > 127;);
					else if (2 === e$1) this.pos = this.readVarint() + this.pos;
					else if (5 === e$1) this.pos += 4;
					else {
						if (1 !== e$1) throw new Error(`Unimplemented type: ${e$1}`);
						this.pos += 8;
					}
				}
				writeTag(t$1, e$1) {
					this.writeVarint(t$1 << 3 | e$1);
				}
				realloc(t$1) {
					let e$1 = this.length || 16;
					for (; e$1 < this.pos + t$1;) e$1 *= 2;
					if (e$1 !== this.length) {
						const t$2 = new Uint8Array(e$1);
						t$2.set(this.buf), this.buf = t$2, this.dataView = new DataView(t$2.buffer), this.length = e$1;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeSFixed32(t$1) {
					this.realloc(4), this.dataView.setInt32(this.pos, t$1, !0), this.pos += 4;
				}
				writeFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * oc), !0), this.pos += 8;
				}
				writeSFixed64(t$1) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & t$1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t$1 * oc), !0), this.pos += 8;
				}
				writeVarint(t$1) {
					(t$1 = +t$1 || 0) > 268435455 || t$1 < 0 ? function(t$2, e$1) {
						let r$1, n$1;
						if (t$2 >= 0 ? (r$1 = t$2 % 4294967296 | 0, n$1 = t$2 / 4294967296 | 0) : (r$1 = ~(-t$2 % 4294967296), n$1 = ~(-t$2 / 4294967296), 4294967295 ^ r$1 ? r$1 = r$1 + 1 | 0 : (r$1 = 0, n$1 = n$1 + 1 | 0)), t$2 >= 0x10000000000000000 || t$2 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
						e$1.realloc(10), function(t$3, e$2, r$2) {
							r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, t$3 >>>= 7, r$2.buf[r$2.pos++] = 127 & t$3 | 128, r$2.buf[r$2.pos] = 127 & (t$3 >>>= 7);
						}(r$1, 0, e$1), function(t$3, e$2) {
							const r$2 = (7 & t$3) << 4;
							e$2.buf[e$2.pos++] |= r$2 | ((t$3 >>>= 3) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3 | ((t$3 >>>= 7) ? 128 : 0), t$3 && (e$2.buf[e$2.pos++] = 127 & t$3)))));
						}(n$1, e$1);
					}(t$1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t$1 | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = 127 & (t$1 >>>= 7) | (t$1 > 127 ? 128 : 0), t$1 <= 127 || (this.buf[this.pos++] = t$1 >>> 7 & 127))));
				}
				writeSVarint(t$1) {
					this.writeVarint(t$1 < 0 ? 2 * -t$1 - 1 : 2 * t$1);
				}
				writeBoolean(t$1) {
					this.writeVarint(+t$1);
				}
				writeString(t$1) {
					t$1 = String(t$1), this.realloc(4 * t$1.length), this.pos++;
					const e$1 = this.pos;
					this.pos = function(t$2, e$2, r$2) {
						for (let n$1, i$1, s$1 = 0; s$1 < e$2.length; s$1++) {
							if (n$1 = e$2.charCodeAt(s$1), n$1 > 55295 && n$1 < 57344) {
								if (!i$1) {
									n$1 > 56319 || s$1 + 1 === e$2.length ? (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189) : i$1 = n$1;
									continue;
								}
								if (n$1 < 56320) {
									t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = n$1;
									continue;
								}
								n$1 = i$1 - 55296 << 10 | n$1 - 56320 | 65536, i$1 = null;
							} else i$1 && (t$2[r$2++] = 239, t$2[r$2++] = 191, t$2[r$2++] = 189, i$1 = null);
							n$1 < 128 ? t$2[r$2++] = n$1 : (n$1 < 2048 ? t$2[r$2++] = n$1 >> 6 | 192 : (n$1 < 65536 ? t$2[r$2++] = n$1 >> 12 | 224 : (t$2[r$2++] = n$1 >> 18 | 240, t$2[r$2++] = n$1 >> 12 & 63 | 128), t$2[r$2++] = n$1 >> 6 & 63 | 128), t$2[r$2++] = 63 & n$1 | 128);
						}
						return r$2;
					}(this.buf, t$1, this.pos);
					const r$1 = this.pos - e$1;
					r$1 >= 128 && hc(e$1, r$1, this), this.pos = e$1 - 1, this.writeVarint(r$1), this.pos += r$1;
				}
				writeFloat(t$1) {
					this.realloc(4), this.dataView.setFloat32(this.pos, t$1, !0), this.pos += 4;
				}
				writeDouble(t$1) {
					this.realloc(8), this.dataView.setFloat64(this.pos, t$1, !0), this.pos += 8;
				}
				writeBytes(t$1) {
					const e$1 = t$1.length;
					this.writeVarint(e$1), this.realloc(e$1);
					for (let r$1 = 0; r$1 < e$1; r$1++) this.buf[this.pos++] = t$1[r$1];
				}
				writeRawMessage(t$1, e$1) {
					this.pos++;
					const r$1 = this.pos;
					t$1(e$1, this);
					const n$1 = this.pos - r$1;
					n$1 >= 128 && hc(r$1, n$1, this), this.pos = r$1 - 1, this.writeVarint(n$1), this.pos += n$1;
				}
				writeMessage(t$1, e$1, r$1) {
					this.writeTag(t$1, 2), this.writeRawMessage(e$1, r$1);
				}
				writePackedVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, pc, e$1);
				}
				writePackedSVarint(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, fc, e$1);
				}
				writePackedBoolean(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, mc, e$1);
				}
				writePackedFloat(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, dc, e$1);
				}
				writePackedDouble(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, yc, e$1);
				}
				writePackedFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, gc, e$1);
				}
				writePackedSFixed32(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, xc, e$1);
				}
				writePackedFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, vc, e$1);
				}
				writePackedSFixed64(t$1, e$1) {
					e$1.length && this.writeMessage(t$1, bc, e$1);
				}
				writeBytesField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeBytes(e$1);
				}
				writeFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFixed32(e$1);
				}
				writeSFixed32Field(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeSFixed32(e$1);
				}
				writeFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeFixed64(e$1);
				}
				writeSFixed64Field(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeSFixed64(e$1);
				}
				writeVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeVarint(e$1);
				}
				writeSVarintField(t$1, e$1) {
					this.writeTag(t$1, 0), this.writeSVarint(e$1);
				}
				writeStringField(t$1, e$1) {
					this.writeTag(t$1, 2), this.writeString(e$1);
				}
				writeFloatField(t$1, e$1) {
					this.writeTag(t$1, 5), this.writeFloat(e$1);
				}
				writeDoubleField(t$1, e$1) {
					this.writeTag(t$1, 1), this.writeDouble(e$1);
				}
				writeBooleanField(t$1, e$1) {
					this.writeVarintField(t$1, +e$1);
				}
			}
			function cc(t$1, e$1, r$1) {
				return r$1 ? 4294967296 * e$1 + (t$1 >>> 0) : 4294967296 * (e$1 >>> 0) + (t$1 >>> 0);
			}
			function hc(t$1, e$1, r$1) {
				const n$1 = e$1 <= 16383 ? 1 : e$1 <= 2097151 ? 2 : e$1 <= 268435455 ? 3 : Math.floor(Math.log(e$1) / (7 * Math.LN2));
				r$1.realloc(n$1);
				for (let e$2 = r$1.pos - 1; e$2 >= t$1; e$2--) r$1.buf[e$2 + n$1] = r$1.buf[e$2];
			}
			function pc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeVarint(t$1[r$1]);
			}
			function fc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSVarint(t$1[r$1]);
			}
			function dc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFloat(t$1[r$1]);
			}
			function yc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeDouble(t$1[r$1]);
			}
			function mc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeBoolean(t$1[r$1]);
			}
			function gc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed32(t$1[r$1]);
			}
			function xc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed32(t$1[r$1]);
			}
			function vc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeFixed64(t$1[r$1]);
			}
			function bc(t$1, e$1) {
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1.writeSFixed64(t$1[r$1]);
			}
			function wc(t$1, e$1, r$1) {
				1 === t$1 && r$1.readMessage(_c, e$1);
			}
			function _c(t$1, e$1, r$1) {
				if (3 === t$1) {
					const { id: t$2, bitmap: n$1, width: i$1, height: s$1, left: a$1, top: o$1, advance: l$1 } = r$1.readMessage(Sc, {});
					e$1.push({
						id: t$2,
						bitmap: new fl({
							width: i$1 + 6,
							height: s$1 + 6
						}, n$1),
						metrics: {
							width: i$1,
							height: s$1,
							left: a$1,
							top: o$1,
							advance: l$1
						}
					});
				}
			}
			function Sc(t$1, e$1, r$1) {
				1 === t$1 ? e$1.id = r$1.readVarint() : 2 === t$1 ? e$1.bitmap = r$1.readBytes() : 3 === t$1 ? e$1.width = r$1.readVarint() : 4 === t$1 ? e$1.height = r$1.readVarint() : 5 === t$1 ? e$1.left = r$1.readSVarint() : 6 === t$1 ? e$1.top = r$1.readSVarint() : 7 === t$1 && (e$1.advance = r$1.readVarint());
			}
			function Ac(t$1) {
				let e$1 = 0, r$1 = 0;
				for (const n$2 of t$1) e$1 += n$2.w * n$2.h, r$1 = Math.max(r$1, n$2.w);
				t$1.sort(((t$2, e$2) => e$2.h - t$2.h));
				const n$1 = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(e$1 / .95)), r$1),
					h: Infinity
				}];
				let i$1 = 0, s$1 = 0;
				for (const e$2 of t$1) for (let t$2 = n$1.length - 1; t$2 >= 0; t$2--) {
					const r$2 = n$1[t$2];
					if (!(e$2.w > r$2.w || e$2.h > r$2.h)) {
						if (e$2.x = r$2.x, e$2.y = r$2.y, s$1 = Math.max(s$1, e$2.y + e$2.h), i$1 = Math.max(i$1, e$2.x + e$2.w), e$2.w === r$2.w && e$2.h === r$2.h) {
							const e$3 = n$1.pop();
							e$3 && t$2 < n$1.length && (n$1[t$2] = e$3);
						} else e$2.h === r$2.h ? (r$2.x += e$2.w, r$2.w -= e$2.w) : e$2.w === r$2.w ? (r$2.y += e$2.h, r$2.h -= e$2.h) : (n$1.push({
							x: r$2.x + e$2.w,
							y: r$2.y,
							w: r$2.w - e$2.w,
							h: e$2.h
						}), r$2.y += e$2.h, r$2.h -= e$2.h);
						break;
					}
				}
				return {
					w: i$1,
					h: s$1,
					fill: e$1 / (i$1 * s$1) || 0
				};
			}
			class kc {
				constructor(t$1, { pixelRatio: e$1, version: r$1, stretchX: n$1, stretchY: i$1, content: s$1, textFitWidth: a$1, textFitHeight: o$1 }) {
					this.paddedRect = t$1, this.pixelRatio = e$1, this.stretchX = n$1, this.stretchY = i$1, this.content = s$1, this.version = r$1, this.textFitWidth = a$1, this.textFitHeight = o$1;
				}
				get tl() {
					return [this.paddedRect.x + 1, this.paddedRect.y + 1];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
				}
				get tlbr() {
					return this.tl.concat(this.br);
				}
				get displaySize() {
					return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
				}
			}
			class Mc {
				constructor(t$1, e$1) {
					const r$1 = {}, n$1 = {};
					this.haveRenderCallbacks = [];
					const i$1 = [];
					this.addImages(t$1, r$1, i$1), this.addImages(e$1, n$1, i$1);
					const { w: s$1, h: a$1 } = Ac(i$1), o$1 = new dl({
						width: s$1 || 1,
						height: a$1 || 1
					});
					for (const e$2 in t$1) {
						const n$2 = t$1[e$2], i$2 = r$1[e$2].paddedRect;
						dl.copy(n$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: i$2.x + 1,
							y: i$2.y + 1
						}, n$2.data);
					}
					for (const t$2 in e$1) {
						const r$2 = e$1[t$2], i$2 = n$1[t$2].paddedRect, s$2 = i$2.x + 1, a$2 = i$2.y + 1, l$1 = r$2.data.width, u$1 = r$2.data.height;
						dl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$2
						}, r$2.data), dl.copy(r$2.data, o$1, {
							x: 0,
							y: u$1 - 1
						}, {
							x: s$2,
							y: a$2 - 1
						}, {
							width: l$1,
							height: 1
						}), dl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2,
							y: a$2 + u$1
						}, {
							width: l$1,
							height: 1
						}), dl.copy(r$2.data, o$1, {
							x: l$1 - 1,
							y: 0
						}, {
							x: s$2 - 1,
							y: a$2
						}, {
							width: 1,
							height: u$1
						}), dl.copy(r$2.data, o$1, {
							x: 0,
							y: 0
						}, {
							x: s$2 + l$1,
							y: a$2
						}, {
							width: 1,
							height: u$1
						});
					}
					this.image = o$1, this.iconPositions = r$1, this.patternPositions = n$1;
				}
				addImages(t$1, e$1, r$1) {
					for (const n$1 in t$1) {
						const i$1 = t$1[n$1], s$1 = {
							x: 0,
							y: 0,
							w: i$1.data.width + 2,
							h: i$1.data.height + 2
						};
						r$1.push(s$1), e$1[n$1] = new kc(s$1, i$1), i$1.hasRenderCallback && this.haveRenderCallbacks.push(n$1);
					}
				}
				patchUpdatedImages(t$1, e$1) {
					t$1.dispatchRenderCallbacks(this.haveRenderCallbacks);
					for (const r$1 in t$1.updatedImages) this.patchUpdatedImage(this.iconPositions[r$1], t$1.getImage(r$1), e$1), this.patchUpdatedImage(this.patternPositions[r$1], t$1.getImage(r$1), e$1);
				}
				patchUpdatedImage(t$1, e$1, r$1) {
					if (!t$1 || !e$1) return;
					if (t$1.version === e$1.version) return;
					t$1.version = e$1.version;
					const [n$1, i$1] = t$1.tl;
					r$1.update(e$1.data, void 0, {
						x: n$1,
						y: i$1
					});
				}
			}
			var Ic;
			os("ImagePosition", kc), os("ImageAtlas", Mc), t.ao = void 0, (Ic = t.ao || (t.ao = {}))[Ic.none = 0] = "none", Ic[Ic.horizontal = 1] = "horizontal", Ic[Ic.vertical = 2] = "vertical", Ic[Ic.horizontalOnly = 3] = "horizontalOnly";
			class zc {
				constructor() {
					this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
				}
				static forText(t$1, e$1, r$1) {
					const n$1 = new zc();
					return n$1.scale = t$1 || 1, n$1.fontStack = e$1, n$1.verticalAlign = r$1 || "bottom", n$1;
				}
				static forImage(t$1, e$1) {
					const r$1 = new zc();
					return r$1.imageName = t$1, r$1.verticalAlign = e$1 || "bottom", r$1;
				}
			}
			class Pc {
				constructor() {
					this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
				}
				static fromFeature(t$1, e$1) {
					const r$1 = new Pc();
					for (let n$1 = 0; n$1 < t$1.sections.length; n$1++) {
						const i$1 = t$1.sections[n$1];
						i$1.image ? r$1.addImageSection(i$1) : r$1.addTextSection(i$1, e$1);
					}
					return r$1;
				}
				length() {
					return this.text.length;
				}
				getSection(t$1) {
					return this.sections[this.sectionIndex[t$1]];
				}
				getSectionIndex(t$1) {
					return this.sectionIndex[t$1];
				}
				getCharCode(t$1) {
					return this.text.charCodeAt(t$1);
				}
				verticalizePunctuation() {
					this.text = function(t$1) {
						let e$1 = "";
						for (let r$1 = 0; r$1 < t$1.length; r$1++) {
							const n$1 = t$1.charCodeAt(r$1 + 1) || null, i$1 = t$1.charCodeAt(r$1 - 1) || null;
							e$1 += n$1 && _s(n$1) && !ic[t$1[r$1 + 1]] || i$1 && _s(i$1) && !ic[t$1[r$1 - 1]] || !ic[t$1[r$1]] ? t$1[r$1] : ic[t$1[r$1]];
						}
						return e$1;
					}(this.text);
				}
				trim() {
					let t$1 = 0;
					for (let e$2 = 0; e$2 < this.text.length && Ec[this.text.charCodeAt(e$2)]; e$2++) t$1++;
					let e$1 = this.text.length;
					for (let r$1 = this.text.length - 1; r$1 >= 0 && r$1 >= t$1 && Ec[this.text.charCodeAt(r$1)]; r$1--) e$1--;
					this.text = this.text.substring(t$1, e$1), this.sectionIndex = this.sectionIndex.slice(t$1, e$1);
				}
				substring(t$1, e$1) {
					const r$1 = new Pc();
					return r$1.text = this.text.substring(t$1, e$1), r$1.sectionIndex = this.sectionIndex.slice(t$1, e$1), r$1.sections = this.sections, r$1;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((t$1, e$1) => Math.max(t$1, this.sections[e$1].scale)), 0);
				}
				getMaxImageSize(t$1) {
					let e$1 = 0, r$1 = 0;
					for (let n$1 = 0; n$1 < this.length(); n$1++) {
						const i$1 = this.getSection(n$1);
						if (i$1.imageName) {
							const n$2 = t$1[i$1.imageName];
							if (!n$2) continue;
							const s$1 = n$2.displaySize;
							e$1 = Math.max(e$1, s$1[0]), r$1 = Math.max(r$1, s$1[1]);
						}
					}
					return {
						maxImageWidth: e$1,
						maxImageHeight: r$1
					};
				}
				addTextSection(t$1, e$1) {
					this.text += t$1.text, this.sections.push(zc.forText(t$1.scale, t$1.fontStack || e$1, t$1.verticalAlign));
					const r$1 = this.sections.length - 1;
					for (let e$2 = 0; e$2 < t$1.text.length; ++e$2) this.sectionIndex.push(r$1);
				}
				addImageSection(t$1) {
					const e$1 = t$1.image ? t$1.image.name : "";
					if (0 === e$1.length) return void q("Can't add FormattedSection with an empty image.");
					const r$1 = this.getNextImageSectionCharCode();
					r$1 ? (this.text += String.fromCharCode(r$1), this.sections.push(zc.forImage(e$1, t$1.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : q("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
			}
			function Cc(e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = Pc.fromFeature(e$1, s$1);
				let g$1;
				p$1 === t.ao.vertical && m$1.verticalizePunctuation();
				const { processBidirectionalText: x$1, processStyledBidirectionalText: v$1 } = Is;
				if (x$1 && 1 === m$1.sections.length) {
					g$1 = [];
					const t$1 = x$1(m$1.toString(), Oc(m$1, c$1, a$1, r$1, i$1, d$1));
					for (const e$2 of t$1) {
						const t$2 = new Pc();
						t$2.text = e$2, t$2.sections = m$1.sections;
						for (let r$2 = 0; r$2 < e$2.length; r$2++) t$2.sectionIndex.push(0);
						g$1.push(t$2);
					}
				} else if (v$1) {
					g$1 = [];
					const t$1 = v$1(m$1.text, m$1.sectionIndex, Oc(m$1, c$1, a$1, r$1, i$1, d$1));
					for (const e$2 of t$1) {
						const t$2 = new Pc();
						t$2.text = e$2[0], t$2.sectionIndex = e$2[1], t$2.sections = m$1.sections, g$1.push(t$2);
					}
				} else g$1 = function(t$1, e$2) {
					const r$2 = [], n$2 = t$1.text;
					let i$2 = 0;
					for (const n$3 of e$2) r$2.push(t$1.substring(i$2, n$3)), i$2 = n$3;
					return i$2 < n$2.length && r$2.push(t$1.substring(i$2, n$2.length)), r$2;
				}(m$1, Oc(m$1, c$1, a$1, r$1, i$1, d$1));
				const b$1 = [], w$1 = {
					positionedLines: b$1,
					text: m$1.toString(),
					top: h$1[1],
					bottom: h$1[1],
					left: h$1[0],
					right: h$1[0],
					writingMode: p$1,
					iconsInText: !1,
					verticalizable: !1
				};
				return function(t$1, e$2, r$2, n$2, i$2, s$2, a$2, o$2, l$2, u$2, c$2, h$2) {
					let p$2 = 0, f$2 = 0, d$2 = 0, y$2 = 0;
					const m$2 = "right" === o$2 ? 1 : "left" === o$2 ? 0 : .5, g$2 = sc / h$2;
					let x$2 = 0;
					for (const a$3 of i$2) {
						a$3.trim();
						const i$3 = a$3.getMaxScale(), o$3 = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						t$1.positionedLines[x$2] = o$3;
						const h$3 = o$3.positionedGlyphs;
						let v$3 = 0;
						if (!a$3.length()) {
							f$2 += s$2, ++x$2;
							continue;
						}
						const b$3 = Uc(n$2, a$3, g$2);
						for (let s$3 = 0; s$3 < a$3.length(); s$3++) {
							const o$4 = a$3.getSection(s$3), d$3 = a$3.getSectionIndex(s$3), y$3 = a$3.getCharCode(s$3), m$3 = Nc(l$2, c$2, y$3);
							let x$3;
							if (o$4.imageName) {
								if (t$1.iconsInText = !0, o$4.scale = o$4.scale * g$2, x$3 = Gc(o$4, m$3, i$3, b$3, n$2), !x$3) continue;
								v$3 = Math.max(v$3, x$3.imageOffset);
							} else if (x$3 = qc(o$4, y$3, m$3, b$3, e$2, r$2), !x$3) continue;
							const { rect: w$3, metrics: _$1, baselineOffset: S$1 } = x$3;
							h$3.push({
								glyph: y$3,
								imageName: o$4.imageName,
								x: p$2,
								y: f$2 + S$1 + -17,
								vertical: m$3,
								scale: o$4.scale,
								fontStack: o$4.fontStack,
								sectionIndex: d$3,
								metrics: _$1,
								rect: w$3
							}), m$3 ? (t$1.verticalizable = !0, p$2 += (o$4.imageName ? _$1.advance : sc) * o$4.scale + u$2) : p$2 += _$1.advance * o$4.scale + u$2;
						}
						0 !== h$3.length && (d$2 = Math.max(p$2 - u$2, d$2), Xc(h$3, 0, h$3.length - 1, m$2)), p$2 = 0, o$3.lineOffset = Math.max(v$3, (i$3 - 1) * sc);
						const w$2 = s$2 * i$3 + v$3;
						f$2 += w$2, y$2 = Math.max(w$2, y$2), ++x$2;
					}
					const { horizontalAlign: v$2, verticalAlign: b$2 } = Rc(a$2);
					(function(t$2, e$3, r$3, n$3, i$3, s$3, a$3, o$3, l$3) {
						const u$3 = (e$3 - r$3) * i$3;
						let c$3 = 0;
						c$3 = s$3 !== a$3 ? -o$3 * n$3 - -17 : -n$3 * l$3 * a$3 + .5 * a$3;
						for (const e$4 of t$2) for (const t$3 of e$4.positionedGlyphs) t$3.x += u$3, t$3.y += c$3;
					})(t$1.positionedLines, m$2, v$2, b$2, d$2, y$2, s$2, f$2, i$2.length), t$1.top += -b$2 * f$2, t$1.bottom = t$1.top + f$2, t$1.left += -v$2 * d$2, t$1.right = t$1.left + d$2;
				}(w$1, r$1, n$1, i$1, g$1, o$1, l$1, u$1, p$1, c$1, f$1, y$1), !function(t$1) {
					for (const e$2 of t$1) if (0 !== e$2.positionedGlyphs.length) return !1;
					return !0;
				}(b$1) && w$1;
			}
			const Ec = {
				9: !0,
				10: !0,
				11: !0,
				12: !0,
				13: !0,
				32: !0
			}, Tc = {
				10: !0,
				32: !0,
				38: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			}, Bc = { 40: !0 };
			function Vc(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (e$1.imageName) {
					const t$2 = n$1[e$1.imageName];
					return t$2 ? t$2.displaySize[0] * e$1.scale * sc / s$1 + i$1 : 0;
				}
				{
					const n$2 = r$1[e$1.fontStack], s$2 = n$2 && n$2[t$1];
					return s$2 ? s$2.metrics.advance * e$1.scale + i$1 : 0;
				}
			}
			function Fc(t$1, e$1, r$1, n$1) {
				const i$1 = Math.pow(t$1 - e$1, 2);
				return n$1 ? t$1 < e$1 ? i$1 / 2 : 2 * i$1 : i$1 + Math.abs(r$1) * r$1;
			}
			function Dc(t$1, e$1, r$1) {
				let n$1 = 0;
				return 10 === t$1 && (n$1 -= 1e4), r$1 && (n$1 += 150), 40 !== t$1 && 65288 !== t$1 || (n$1 += 50), 41 !== e$1 && 65289 !== e$1 || (n$1 += 50), n$1;
			}
			function $c(t$1, e$1, r$1, n$1, i$1, s$1) {
				let a$1 = null, o$1 = Fc(e$1, r$1, i$1, s$1);
				for (const t$2 of n$1) {
					const n$2 = Fc(e$1 - t$2.x, r$1, i$1, s$1) + t$2.badness;
					n$2 <= o$1 && (a$1 = t$2, o$1 = n$2);
				}
				return {
					index: t$1,
					x: e$1,
					priorBreak: a$1,
					badness: o$1
				};
			}
			function Lc(t$1) {
				return t$1 ? Lc(t$1.priorBreak).concat(t$1.index) : [];
			}
			function Oc(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (!t$1) return [];
				const a$1 = [], o$1 = function(t$2, e$2, r$2, n$2, i$2, s$2) {
					let a$2 = 0;
					for (let r$3 = 0; r$3 < t$2.length(); r$3++) {
						const o$2 = t$2.getSection(r$3);
						a$2 += Vc(t$2.getCharCode(r$3), o$2, n$2, i$2, e$2, s$2);
					}
					return a$2 / Math.max(1, Math.ceil(a$2 / r$2));
				}(t$1, e$1, r$1, n$1, i$1, s$1), l$1 = t$1.text.indexOf("​") >= 0;
				let u$1 = 0;
				for (let r$2 = 0; r$2 < t$1.length(); r$2++) {
					const h$1 = t$1.getSection(r$2), p$1 = t$1.getCharCode(r$2);
					if (Ec[p$1] || (u$1 += Vc(p$1, h$1, n$1, i$1, e$1, s$1)), r$2 < t$1.length() - 1) {
						const e$2 = !((c$1 = p$1) < 11904) && (!!ds["CJK Compatibility Forms"](c$1) || !!ds["CJK Compatibility"](c$1) || !!ds["CJK Strokes"](c$1) || !!ds["CJK Symbols and Punctuation"](c$1) || !!ds["Enclosed CJK Letters and Months"](c$1) || !!ds["Halfwidth and Fullwidth Forms"](c$1) || !!ds["Ideographic Description Characters"](c$1) || !!ds["Vertical Forms"](c$1) || bs.test(String.fromCodePoint(c$1)));
						(Tc[p$1] || e$2 || h$1.imageName || r$2 !== t$1.length() - 2 && Bc[t$1.getCharCode(r$2 + 1)]) && a$1.push($c(r$2 + 1, u$1, o$1, a$1, Dc(p$1, t$1.getCharCode(r$2 + 1), e$2 && l$1), !1));
					}
				}
				var c$1;
				return Lc($c(t$1.length(), u$1, o$1, a$1, 0, !0));
			}
			function Rc(t$1) {
				let e$1 = .5, r$1 = .5;
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right":
						e$1 = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": e$1 = 0;
				}
				switch (t$1) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						r$1 = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": r$1 = 0;
				}
				return {
					horizontalAlign: e$1,
					verticalAlign: r$1
				};
			}
			function Uc(t$1, e$1, r$1) {
				const n$1 = e$1.getMaxScale() * sc, { maxImageWidth: i$1, maxImageHeight: s$1 } = e$1.getMaxImageSize(t$1), a$1 = Math.max(n$1, s$1 * r$1);
				return {
					verticalLineContentWidth: Math.max(n$1, i$1 * r$1),
					horizontalLineContentHeight: a$1
				};
			}
			function jc(t$1) {
				switch (t$1) {
					case "top": return 0;
					case "center": return .5;
					default: return 1;
				}
			}
			function Nc(e$1, r$1, n$1) {
				return !(e$1 === t.ao.horizontal || !r$1 && !ws(n$1) || r$1 && (Ec[n$1] || (i$1 = n$1, /\p{sc=Arab}/u.test(String.fromCodePoint(i$1)))));
				var i$1;
			}
			function qc(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a$1 = s$1[t$1.fontStack], o$1 = function(t$2, e$2, r$2, n$2) {
					if (t$2 && t$2.rect) return t$2;
					const i$2 = e$2[r$2.fontStack], s$2 = i$2 && i$2[n$2];
					return s$2 ? {
						rect: null,
						metrics: s$2.metrics
					} : null;
				}(a$1 && a$1[e$1], i$1, t$1, e$1);
				if (null === o$1) return null;
				let l$1;
				if (r$1) l$1 = n$1.verticalLineContentWidth - t$1.scale * sc;
				else {
					const e$2 = jc(t$1.verticalAlign);
					l$1 = (n$1.horizontalLineContentHeight - t$1.scale * sc) * e$2;
				}
				return {
					rect: o$1.rect,
					metrics: o$1.metrics,
					baselineOffset: l$1
				};
			}
			function Gc(t$1, e$1, r$1, n$1, i$1) {
				const s$1 = i$1[t$1.imageName];
				if (!s$1) return null;
				const a$1 = s$1.paddedRect, o$1 = s$1.displaySize, l$1 = {
					width: o$1[0],
					height: o$1[1],
					left: 1,
					top: -3,
					advance: e$1 ? o$1[1] : o$1[0]
				};
				let u$1;
				if (e$1) u$1 = n$1.verticalLineContentWidth - o$1[1] * t$1.scale;
				else {
					const e$2 = jc(t$1.verticalAlign);
					u$1 = (n$1.horizontalLineContentHeight - o$1[1] * t$1.scale) * e$2;
				}
				return {
					rect: a$1,
					metrics: l$1,
					baselineOffset: u$1,
					imageOffset: (e$1 ? o$1[0] : o$1[1]) * t$1.scale - sc * r$1
				};
			}
			function Xc(t$1, e$1, r$1, n$1) {
				if (0 === n$1) return;
				const i$1 = t$1[r$1], s$1 = (t$1[r$1].x + i$1.metrics.advance * i$1.scale) * n$1;
				for (let n$2 = e$1; n$2 <= r$1; n$2++) t$1[n$2].x -= s$1;
			}
			function Zc(t$1, e$1, r$1) {
				const { horizontalAlign: n$1, verticalAlign: i$1 } = Rc(r$1), s$1 = e$1[0] - t$1.displaySize[0] * n$1, a$1 = e$1[1] - t$1.displaySize[1] * i$1;
				return {
					image: t$1,
					top: a$1,
					bottom: a$1 + t$1.displaySize[1],
					left: s$1,
					right: s$1 + t$1.displaySize[0]
				};
			}
			function Yc(t$1) {
				var e$1, r$1;
				let n$1 = t$1.left, i$1 = t$1.top, s$1 = t$1.right - n$1, a$1 = t$1.bottom - i$1;
				const o$1 = null !== (e$1 = t$1.image.textFitWidth) && void 0 !== e$1 ? e$1 : "stretchOrShrink", l$1 = null !== (r$1 = t$1.image.textFitHeight) && void 0 !== r$1 ? r$1 : "stretchOrShrink", u$1 = (t$1.image.content[2] - t$1.image.content[0]) / (t$1.image.content[3] - t$1.image.content[1]);
				if ("proportional" === l$1) {
					if ("stretchOnly" === o$1 && s$1 / a$1 < u$1 || "proportional" === o$1) {
						const t$2 = Math.ceil(a$1 * u$1);
						n$1 *= t$2 / s$1, s$1 = t$2;
					}
				} else if ("proportional" === o$1 && "stretchOnly" === l$1 && 0 !== u$1 && s$1 / a$1 > u$1) {
					const t$2 = Math.ceil(s$1 / u$1);
					i$1 *= t$2 / a$1, a$1 = t$2;
				}
				return {
					x1: n$1,
					y1: i$1,
					x2: n$1 + s$1,
					y2: i$1 + a$1
				};
			}
			function Hc(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a$1 = t$1.image;
				let o$1;
				if (a$1.content) {
					const t$2 = a$1.content, e$2 = a$1.pixelRatio || 1;
					o$1 = [
						t$2[0] / e$2,
						t$2[1] / e$2,
						a$1.displaySize[0] - t$2[2] / e$2,
						a$1.displaySize[1] - t$2[3] / e$2
					];
				}
				const l$1 = e$1.left * s$1, u$1 = e$1.right * s$1;
				let c$1, h$1, p$1, f$1;
				"width" === r$1 || "both" === r$1 ? (f$1 = i$1[0] + l$1 - n$1[3], h$1 = i$1[0] + u$1 + n$1[1]) : (f$1 = i$1[0] + (l$1 + u$1 - a$1.displaySize[0]) / 2, h$1 = f$1 + a$1.displaySize[0]);
				const d$1 = e$1.top * s$1, y$1 = e$1.bottom * s$1;
				return "height" === r$1 || "both" === r$1 ? (c$1 = i$1[1] + d$1 - n$1[0], p$1 = i$1[1] + y$1 + n$1[2]) : (c$1 = i$1[1] + (d$1 + y$1 - a$1.displaySize[1]) / 2, p$1 = c$1 + a$1.displaySize[1]), {
					image: a$1,
					top: c$1,
					right: h$1,
					bottom: p$1,
					left: f$1,
					collisionPadding: o$1
				};
			}
			const Kc = 128, Jc = 32640;
			function Wc(t$1, e$1) {
				const { expression: r$1 } = e$1;
				if ("constant" === r$1.kind) return {
					kind: "constant",
					layoutSize: r$1.evaluate(new zs(t$1 + 1))
				};
				if ("source" === r$1.kind) return { kind: "source" };
				{
					const { zoomStops: e$2, interpolationType: n$1 } = r$1;
					let i$1 = 0;
					for (; i$1 < e$2.length && e$2[i$1] <= t$1;) i$1++;
					i$1 = Math.max(0, i$1 - 1);
					let s$1 = i$1;
					for (; s$1 < e$2.length && e$2[s$1] < t$1 + 1;) s$1++;
					s$1 = Math.min(e$2.length - 1, s$1);
					const a$1 = e$2[i$1], o$1 = e$2[s$1];
					return "composite" === r$1.kind ? {
						kind: "composite",
						minZoom: a$1,
						maxZoom: o$1,
						interpolationType: n$1
					} : {
						kind: "camera",
						minZoom: a$1,
						maxZoom: o$1,
						minSize: r$1.evaluate(new zs(a$1)),
						maxSize: r$1.evaluate(new zs(o$1)),
						interpolationType: n$1
					};
				}
			}
			function Qc(t$1, e$1, r$1) {
				let n$1 = "never";
				const i$1 = t$1.get(e$1);
				return i$1 ? n$1 = i$1 : t$1.get(r$1) && (n$1 = "always"), n$1;
			}
			const th = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function eh(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1) {
				const f$1 = o$1 ? Math.min(Jc, Math.round(o$1[0])) : 0, d$1 = o$1 ? Math.min(Jc, Math.round(o$1[1])) : 0;
				t$1.emplaceBack(e$1, r$1, Math.round(32 * n$1), Math.round(32 * i$1), s$1, a$1, (f$1 << 1) + (l$1 ? 1 : 0), d$1, 16 * u$1, 16 * c$1, 256 * h$1, 256 * p$1);
			}
			function rh(t$1, e$1, r$1) {
				t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1), t$1.emplaceBack(e$1.x, e$1.y, r$1);
			}
			function nh(t$1) {
				for (const e$1 of t$1.sections) if (Ms(e$1.text)) return !0;
				return !1;
			}
			class ih {
				constructor(t$1) {
					this.layoutVertexArray = new Ua(), this.indexArray = new Xa(), this.programConfigurations = t$1, this.segments = new Ka(), this.dynamicLayoutVertexArray = new ja(), this.opacityVertexArray = new Na(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Aa();
				}
				isEmpty() {
					return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
				}
				upload(t$1, e$1, r$1, n$1) {
					this.isEmpty() || (r$1 && (this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, Wu.members), this.indexBuffer = t$1.createIndexBuffer(this.indexArray, e$1), this.dynamicLayoutVertexBuffer = t$1.createVertexBuffer(this.dynamicLayoutVertexArray, Qu.members, !0), this.opacityVertexBuffer = t$1.createVertexBuffer(this.opacityVertexArray, th, !0), this.opacityVertexBuffer.itemSize = 1), (r$1 || n$1) && this.programConfigurations.upload(t$1));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
				}
			}
			os("SymbolBuffers", ih);
			class sh {
				constructor(t$1, e$1, r$1) {
					this.layoutVertexArray = new t$1(), this.layoutAttributes = e$1, this.indexArray = new r$1(), this.segments = new Ka(), this.collisionVertexArray = new Ga();
				}
				upload(t$1) {
					this.layoutVertexBuffer = t$1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t$1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t$1.createVertexBuffer(this.collisionVertexArray, tc.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
				}
			}
			os("CollisionBuffers", sh);
			class ah {
				constructor(e$1) {
					this.collisionBoxArray = e$1.collisionBoxArray, this.zoom = e$1.zoom, this.overscaling = e$1.overscaling, this.layers = e$1.layers, this.layerIds = this.layers.map(((t$1) => t$1.id)), this.index = e$1.index, this.pixelRatio = e$1.pixelRatio, this.sourceLayerIndex = e$1.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
					const r$1 = this.layers[0]._unevaluatedLayout._values;
					this.textSizeData = Wc(this.zoom, r$1["text-size"]), this.iconSizeData = Wc(this.zoom, r$1["icon-size"]);
					const n$1 = this.layers[0].layout, i$1 = n$1.get("symbol-sort-key"), s$1 = n$1.get("symbol-z-order");
					this.canOverlap = "never" !== Qc(n$1, "text-overlap", "text-allow-overlap") || "never" !== Qc(n$1, "icon-overlap", "icon-allow-overlap") || n$1.get("text-ignore-placement") || n$1.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s$1 && !i$1.isConstant(), this.sortFeaturesByY = ("viewport-y" === s$1 || "auto" === s$1 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n$1.get("symbol-placement") && (this.writingModes = n$1.get("text-writing-mode").map(((e$2) => t.ao[e$2]))), this.stateDependentLayerIds = this.layers.filter(((t$1) => t$1.isStateDependent())).map(((t$1) => t$1.id)), this.sourceID = e$1.sourceID;
				}
				createArrays() {
					this.text = new ih(new Io(this.layers, this.zoom, ((t$1) => /^text/.test(t$1)))), this.icon = new ih(new Io(this.layers, this.zoom, ((t$1) => /^icon/.test(t$1)))), this.glyphOffsetArray = new Ia(), this.lineVertexArray = new za(), this.symbolInstances = new Ma(), this.textAnchorOffsets = new Ca();
				}
				calculateGlyphDependencies(t$1, e$1, r$1, n$1, i$1) {
					for (let s$1 = 0; s$1 < t$1.length; s$1++) if (e$1[t$1.charCodeAt(s$1)] = !0, (r$1 || n$1) && i$1) {
						const r$2 = ic[t$1.charAt(s$1)];
						r$2 && (e$1[r$2.charCodeAt(0)] = !0);
					}
				}
				populate(e$1, r$1, n$1) {
					const i$1 = this.layers[0], s$1 = i$1.layout, a$1 = s$1.get("text-font"), o$1 = s$1.get("text-field"), l$1 = s$1.get("icon-image"), u$1 = ("constant" !== o$1.value.kind || o$1.value.value instanceof Ce && !o$1.value.value.isEmpty() || o$1.value.value.toString().length > 0) && ("constant" !== a$1.value.kind || a$1.value.value.length > 0), c$1 = "constant" !== l$1.value.kind || !!l$1.value.value || Object.keys(l$1.parameters).length > 0, h$1 = s$1.get("symbol-sort-key");
					if (this.features = [], !u$1 && !c$1) return;
					const p$1 = r$1.iconDependencies, f$1 = r$1.glyphDependencies, d$1 = r$1.availableImages, y$1 = new zs(this.zoom);
					for (const { feature: r$2, id: o$2, index: l$2, sourceLayerIndex: m$1 } of e$1) {
						const e$2 = i$1._featureFilter.needGeometry, g$1 = Bo(r$2, e$2);
						if (!i$1._featureFilter.filter(y$1, g$1, n$1)) continue;
						let x$1, v$1;
						if (e$2 || (g$1.geometry = To(r$2)), u$1) {
							const t$1 = i$1.getValueAndResolveTokens("text-field", g$1, n$1, d$1), e$3 = Ce.factory(t$1), r$3 = this.hasRTLText = this.hasRTLText || nh(e$3);
							(!r$3 || "unavailable" === Is.getRTLTextPluginStatus() || r$3 && Is.isParsed()) && (x$1 = nc(e$3, i$1, g$1));
						}
						if (c$1) {
							const t$1 = i$1.getValueAndResolveTokens("icon-image", g$1, n$1, d$1);
							v$1 = t$1 instanceof $e ? t$1 : $e.fromString(t$1);
						}
						if (!x$1 && !v$1) continue;
						const b$1 = this.sortFeaturesByKey ? h$1.evaluate(g$1, {}, n$1) : void 0;
						if (this.features.push({
							id: o$2,
							text: x$1,
							icon: v$1,
							index: l$2,
							sourceLayerIndex: m$1,
							geometry: g$1.geometry,
							properties: r$2.properties,
							type: bu.types[r$2.type],
							sortKey: b$1
						}), v$1 && (p$1[v$1.name] = !0), x$1) {
							const e$3 = a$1.evaluate(g$1, {}, n$1).join(","), r$3 = "viewport" !== s$1.get("text-rotation-alignment") && "point" !== s$1.get("symbol-placement");
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ao.vertical) >= 0;
							for (const t$1 of x$1.sections) if (t$1.image) p$1[t$1.image.name] = !0;
							else {
								const n$2 = ys(x$1.toString()), i$2 = t$1.fontStack || e$3, s$2 = f$1[i$2] = f$1[i$2] || {};
								this.calculateGlyphDependencies(t$1.text, s$2, r$3, this.allowVerticalPlacement, n$2);
							}
						}
					}
					"line" === s$1.get("symbol-placement") && (this.features = function(t$1) {
						const e$2 = {}, r$2 = {}, n$2 = [];
						let i$2 = 0;
						function s$2(e$3) {
							n$2.push(t$1[e$3]), i$2++;
						}
						function a$2(t$2, e$3, i$3) {
							const s$3 = r$2[t$2];
							return delete r$2[t$2], r$2[e$3] = s$3, n$2[s$3].geometry[0].pop(), n$2[s$3].geometry[0] = n$2[s$3].geometry[0].concat(i$3[0]), s$3;
						}
						function o$2(t$2, r$3, i$3) {
							const s$3 = e$2[r$3];
							return delete e$2[r$3], e$2[t$2] = s$3, n$2[s$3].geometry[0].shift(), n$2[s$3].geometry[0] = i$3[0].concat(n$2[s$3].geometry[0]), s$3;
						}
						function l$2(t$2, e$3, r$3) {
							const n$3 = r$3 ? e$3[0][e$3[0].length - 1] : e$3[0][0];
							return `${t$2}:${n$3.x}:${n$3.y}`;
						}
						for (let u$2 = 0; u$2 < t$1.length; u$2++) {
							const c$2 = t$1[u$2], h$2 = c$2.geometry, p$2 = c$2.text ? c$2.text.toString() : null;
							if (!p$2) {
								s$2(u$2);
								continue;
							}
							const f$2 = l$2(p$2, h$2), d$2 = l$2(p$2, h$2, !0);
							if (f$2 in r$2 && d$2 in e$2 && r$2[f$2] !== e$2[d$2]) {
								const t$2 = o$2(f$2, d$2, h$2), i$3 = a$2(f$2, d$2, n$2[t$2].geometry);
								delete e$2[f$2], delete r$2[d$2], r$2[l$2(p$2, n$2[i$3].geometry, !0)] = i$3, n$2[t$2].geometry = null;
							} else f$2 in r$2 ? a$2(f$2, d$2, h$2) : d$2 in e$2 ? o$2(f$2, d$2, h$2) : (s$2(u$2), e$2[f$2] = i$2 - 1, r$2[d$2] = i$2 - 1);
						}
						return n$2.filter(((t$2) => t$2.geometry));
					}(this.features)), this.sortFeaturesByKey && this.features.sort(((t$1, e$2) => t$1.sortKey - e$2.sortKey));
				}
				update(t$1, e$1, r$1) {
					this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }), this.icon.programConfigurations.updatePaintArrays(t$1, e$1, this.layers, { imagePositions: r$1 }));
				}
				isEmpty() {
					return 0 === this.symbolInstances.length && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(t$1) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t$1), this.iconCollisionBox.upload(t$1)), this.text.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t$1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(t$1, e$1) {
					const r$1 = this.lineVertexArray.length;
					if (void 0 !== t$1.segment) {
						let r$2 = t$1.dist(e$1[t$1.segment + 1]), n$1 = t$1.dist(e$1[t$1.segment]);
						const i$1 = {};
						for (let n$2 = t$1.segment + 1; n$2 < e$1.length; n$2++) i$1[n$2] = {
							x: e$1[n$2].x,
							y: e$1[n$2].y,
							tileUnitDistanceFromAnchor: r$2
						}, n$2 < e$1.length - 1 && (r$2 += e$1[n$2 + 1].dist(e$1[n$2]));
						for (let r$3 = t$1.segment || 0; r$3 >= 0; r$3--) i$1[r$3] = {
							x: e$1[r$3].x,
							y: e$1[r$3].y,
							tileUnitDistanceFromAnchor: n$1
						}, r$3 > 0 && (n$1 += e$1[r$3 - 1].dist(e$1[r$3]));
						for (let t$2 = 0; t$2 < e$1.length; t$2++) {
							const e$2 = i$1[t$2];
							this.lineVertexArray.emplaceBack(e$2.x, e$2.y, e$2.tileUnitDistanceFromAnchor);
						}
					}
					return {
						lineStartIndex: r$1,
						lineLength: this.lineVertexArray.length - r$1
					};
				}
				addSymbols(e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1) {
					const f$1 = e$1.indexArray, d$1 = e$1.layoutVertexArray, y$1 = e$1.segments.prepareSegment(4 * r$1.length, d$1, f$1, this.canOverlap ? a$1.sortKey : void 0), m$1 = this.glyphOffsetArray.length, g$1 = y$1.vertexLength, x$1 = this.allowVerticalPlacement && o$1 === t.ao.vertical ? Math.PI / 2 : 0, v$1 = a$1.text && a$1.text.sections;
					for (let t$1 = 0; t$1 < r$1.length; t$1++) {
						const { tl: i$2, tr: s$2, bl: o$2, br: u$2, tex: c$2, pixelOffsetTL: h$2, pixelOffsetBR: m$2, minFontScaleX: g$2, minFontScaleY: b$1, glyphOffset: w$1, isSDF: _$1, sectionIndex: S$1 } = r$1[t$1], A$1 = y$1.vertexLength, k$1 = w$1[1];
						eh(d$1, l$1.x, l$1.y, i$2.x, k$1 + i$2.y, c$2.x, c$2.y, n$1, _$1, h$2.x, h$2.y, g$2, b$1), eh(d$1, l$1.x, l$1.y, s$2.x, k$1 + s$2.y, c$2.x + c$2.w, c$2.y, n$1, _$1, m$2.x, h$2.y, g$2, b$1), eh(d$1, l$1.x, l$1.y, o$2.x, k$1 + o$2.y, c$2.x, c$2.y + c$2.h, n$1, _$1, h$2.x, m$2.y, g$2, b$1), eh(d$1, l$1.x, l$1.y, u$2.x, k$1 + u$2.y, c$2.x + c$2.w, c$2.y + c$2.h, n$1, _$1, m$2.x, m$2.y, g$2, b$1), rh(e$1.dynamicLayoutVertexArray, l$1, x$1), f$1.emplaceBack(A$1, A$1 + 2, A$1 + 1), f$1.emplaceBack(A$1 + 1, A$1 + 2, A$1 + 3), y$1.vertexLength += 4, y$1.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w$1[0]), t$1 !== r$1.length - 1 && S$1 === r$1[t$1 + 1].sectionIndex || e$1.programConfigurations.populatePaintArrays(d$1.length, a$1, a$1.index, {
							imagePositions: {},
							canonical: p$1,
							formattedSection: v$1 && v$1[S$1]
						});
					}
					e$1.placedSymbolArray.emplaceBack(l$1.x, l$1.y, m$1, this.glyphOffsetArray.length - m$1, g$1, u$1, c$1, l$1.segment, n$1 ? n$1[0] : 0, n$1 ? n$1[1] : 0, i$1[0], i$1[1], o$1, 0, !1, 0, h$1);
				}
				_addCollisionDebugVertex(t$1, e$1, r$1, n$1, i$1, s$1) {
					return e$1.emplaceBack(0, 0), t$1.emplaceBack(r$1.x, r$1.y, n$1, i$1, Math.round(s$1.x), Math.round(s$1.y));
				}
				addCollisionDebugVertices(t$1, e$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = s$1.segments.prepareSegment(4, s$1.layoutVertexArray, s$1.indexArray), u$1 = l$1.vertexLength, c$1 = s$1.layoutVertexArray, h$1 = s$1.collisionVertexArray, p$1 = o$1.anchorX, f$1 = o$1.anchorY;
					this._addCollisionDebugVertex(c$1, h$1, a$1, p$1, f$1, new r(t$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a$1, p$1, f$1, new r(n$1, e$1)), this._addCollisionDebugVertex(c$1, h$1, a$1, p$1, f$1, new r(n$1, i$1)), this._addCollisionDebugVertex(c$1, h$1, a$1, p$1, f$1, new r(t$1, i$1)), l$1.vertexLength += 4;
					const d$1 = s$1.indexArray;
					d$1.emplaceBack(u$1, u$1 + 1), d$1.emplaceBack(u$1 + 1, u$1 + 2), d$1.emplaceBack(u$1 + 2, u$1 + 3), d$1.emplaceBack(u$1 + 3, u$1), l$1.primitiveLength += 4;
				}
				addDebugCollisionBoxes(t$1, e$1, r$1, n$1) {
					for (let i$1 = t$1; i$1 < e$1; i$1++) {
						const t$2 = this.collisionBoxArray.get(i$1);
						this.addCollisionDebugVertices(t$2.x1, t$2.y1, t$2.x2, t$2.y2, n$1 ? this.textCollisionBox : this.iconCollisionBox, t$2.anchorPoint, r$1);
					}
				}
				generateCollisionDebugBuffers() {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new sh(qa, ec.members, Za), this.iconCollisionBox = new sh(qa, ec.members, Za);
					for (let t$1 = 0; t$1 < this.symbolInstances.length; t$1++) {
						const e$1 = this.symbolInstances.get(t$1);
						this.addDebugCollisionBoxes(e$1.textBoxStartIndex, e$1.textBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.verticalTextBoxStartIndex, e$1.verticalTextBoxEndIndex, e$1, !0), this.addDebugCollisionBoxes(e$1.iconBoxStartIndex, e$1.iconBoxEndIndex, e$1, !1), this.addDebugCollisionBoxes(e$1.verticalIconBoxStartIndex, e$1.verticalIconBoxEndIndex, e$1, !1);
					}
				}
				_deserializeCollisionBoxesForSymbol(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
					const u$1 = {};
					for (let n$2 = e$1; n$2 < r$1; n$2++) {
						const e$2 = t$1.get(n$2);
						u$1.textBox = {
							x1: e$2.x1,
							y1: e$2.y1,
							x2: e$2.x2,
							y2: e$2.y2,
							anchorPointX: e$2.anchorPointX,
							anchorPointY: e$2.anchorPointY
						}, u$1.textFeatureIndex = e$2.featureIndex;
						break;
					}
					for (let e$2 = n$1; e$2 < i$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalTextBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalTextFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = s$1; e$2 < a$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.iconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.iconFeatureIndex = r$2.featureIndex;
						break;
					}
					for (let e$2 = o$1; e$2 < l$1; e$2++) {
						const r$2 = t$1.get(e$2);
						u$1.verticalIconBox = {
							x1: r$2.x1,
							y1: r$2.y1,
							x2: r$2.x2,
							y2: r$2.y2,
							anchorPointX: r$2.anchorPointX,
							anchorPointY: r$2.anchorPointY
						}, u$1.verticalIconFeatureIndex = r$2.featureIndex;
						break;
					}
					return u$1;
				}
				deserializeCollisionBoxes(t$1) {
					this.collisionArrays = [];
					for (let e$1 = 0; e$1 < this.symbolInstances.length; e$1++) {
						const r$1 = this.symbolInstances.get(e$1);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t$1, r$1.textBoxStartIndex, r$1.textBoxEndIndex, r$1.verticalTextBoxStartIndex, r$1.verticalTextBoxEndIndex, r$1.iconBoxStartIndex, r$1.iconBoxEndIndex, r$1.verticalIconBoxStartIndex, r$1.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				addIndicesForPlacedSymbol(t$1, e$1) {
					const r$1 = t$1.placedSymbolArray.get(e$1), n$1 = r$1.vertexStartIndex + 4 * r$1.numGlyphs;
					for (let e$2 = r$1.vertexStartIndex; e$2 < n$1; e$2 += 4) t$1.indexArray.emplaceBack(e$2, e$2 + 2, e$2 + 1), t$1.indexArray.emplaceBack(e$2 + 1, e$2 + 2, e$2 + 3);
				}
				getSortedSymbolIndexes(t$1) {
					if (this.sortedAngle === t$1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
					const e$1 = Math.sin(t$1), r$1 = Math.cos(t$1), n$1 = [], i$1 = [], s$1 = [];
					for (let t$2 = 0; t$2 < this.symbolInstances.length; ++t$2) {
						s$1.push(t$2);
						const a$1 = this.symbolInstances.get(t$2);
						n$1.push(0 | Math.round(e$1 * a$1.anchorX + r$1 * a$1.anchorY)), i$1.push(a$1.featureIndex);
					}
					return s$1.sort(((t$2, e$2) => n$1[t$2] - n$1[e$2] || i$1[e$2] - i$1[t$2])), s$1;
				}
				addToSortKeyRanges(t$1, e$1) {
					const r$1 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					r$1 && r$1.sortKey === e$1 ? r$1.symbolInstanceEnd = t$1 + 1 : this.sortKeyRanges.push({
						sortKey: e$1,
						symbolInstanceStart: t$1,
						symbolInstanceEnd: t$1 + 1
					});
				}
				sortFeatures(t$1) {
					if (this.sortFeaturesByY && this.sortedAngle !== t$1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t$1), this.sortedAngle = t$1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (const t$2 of this.symbolInstanceIndexes) {
							const e$1 = this.symbolInstances.get(t$2);
							this.featureSortOrder.push(e$1.featureIndex), [
								e$1.rightJustifiedTextSymbolIndex,
								e$1.centerJustifiedTextSymbolIndex,
								e$1.leftJustifiedTextSymbolIndex
							].forEach(((t$3, e$2, r$1) => {
								t$3 >= 0 && r$1.indexOf(t$3) === e$2 && this.addIndicesForPlacedSymbol(this.text, t$3);
							})), e$1.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e$1.verticalPlacedTextSymbolIndex), e$1.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.placedIconSymbolIndex), e$1.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e$1.verticalPlacedIconSymbolIndex);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
			}
			let oh, lh;
			os("SymbolBucket", ah, { omit: [
				"layers",
				"collisionBoxArray",
				"features",
				"compareText"
			] }), ah.MAX_GLYPHS = 65535, ah.addDynamicAttributes = rh;
			var uh = {
				get paint() {
					return lh = lh || new Ns({
						"icon-opacity": new Os(xt.paint_symbol["icon-opacity"]),
						"icon-color": new Os(xt.paint_symbol["icon-color"]),
						"icon-halo-color": new Os(xt.paint_symbol["icon-halo-color"]),
						"icon-halo-width": new Os(xt.paint_symbol["icon-halo-width"]),
						"icon-halo-blur": new Os(xt.paint_symbol["icon-halo-blur"]),
						"icon-translate": new Ls(xt.paint_symbol["icon-translate"]),
						"icon-translate-anchor": new Ls(xt.paint_symbol["icon-translate-anchor"]),
						"text-opacity": new Os(xt.paint_symbol["text-opacity"]),
						"text-color": new Os(xt.paint_symbol["text-color"], {
							runtimeType: Lt,
							getOverride: (t$1) => t$1.textColor,
							hasOverride: (t$1) => !!t$1.textColor
						}),
						"text-halo-color": new Os(xt.paint_symbol["text-halo-color"]),
						"text-halo-width": new Os(xt.paint_symbol["text-halo-width"]),
						"text-halo-blur": new Os(xt.paint_symbol["text-halo-blur"]),
						"text-translate": new Ls(xt.paint_symbol["text-translate"]),
						"text-translate-anchor": new Ls(xt.paint_symbol["text-translate-anchor"])
					});
				},
				get layout() {
					return oh = oh || new Ns({
						"symbol-placement": new Ls(xt.layout_symbol["symbol-placement"]),
						"symbol-spacing": new Ls(xt.layout_symbol["symbol-spacing"]),
						"symbol-avoid-edges": new Ls(xt.layout_symbol["symbol-avoid-edges"]),
						"symbol-sort-key": new Os(xt.layout_symbol["symbol-sort-key"]),
						"symbol-z-order": new Ls(xt.layout_symbol["symbol-z-order"]),
						"icon-allow-overlap": new Ls(xt.layout_symbol["icon-allow-overlap"]),
						"icon-overlap": new Ls(xt.layout_symbol["icon-overlap"]),
						"icon-ignore-placement": new Ls(xt.layout_symbol["icon-ignore-placement"]),
						"icon-optional": new Ls(xt.layout_symbol["icon-optional"]),
						"icon-rotation-alignment": new Ls(xt.layout_symbol["icon-rotation-alignment"]),
						"icon-size": new Os(xt.layout_symbol["icon-size"]),
						"icon-text-fit": new Ls(xt.layout_symbol["icon-text-fit"]),
						"icon-text-fit-padding": new Ls(xt.layout_symbol["icon-text-fit-padding"]),
						"icon-image": new Os(xt.layout_symbol["icon-image"]),
						"icon-rotate": new Os(xt.layout_symbol["icon-rotate"]),
						"icon-padding": new Os(xt.layout_symbol["icon-padding"]),
						"icon-keep-upright": new Ls(xt.layout_symbol["icon-keep-upright"]),
						"icon-offset": new Os(xt.layout_symbol["icon-offset"]),
						"icon-anchor": new Os(xt.layout_symbol["icon-anchor"]),
						"icon-pitch-alignment": new Ls(xt.layout_symbol["icon-pitch-alignment"]),
						"text-pitch-alignment": new Ls(xt.layout_symbol["text-pitch-alignment"]),
						"text-rotation-alignment": new Ls(xt.layout_symbol["text-rotation-alignment"]),
						"text-field": new Os(xt.layout_symbol["text-field"]),
						"text-font": new Os(xt.layout_symbol["text-font"]),
						"text-size": new Os(xt.layout_symbol["text-size"]),
						"text-max-width": new Os(xt.layout_symbol["text-max-width"]),
						"text-line-height": new Ls(xt.layout_symbol["text-line-height"]),
						"text-letter-spacing": new Os(xt.layout_symbol["text-letter-spacing"]),
						"text-justify": new Os(xt.layout_symbol["text-justify"]),
						"text-radial-offset": new Os(xt.layout_symbol["text-radial-offset"]),
						"text-variable-anchor": new Ls(xt.layout_symbol["text-variable-anchor"]),
						"text-variable-anchor-offset": new Os(xt.layout_symbol["text-variable-anchor-offset"]),
						"text-anchor": new Os(xt.layout_symbol["text-anchor"]),
						"text-max-angle": new Ls(xt.layout_symbol["text-max-angle"]),
						"text-writing-mode": new Ls(xt.layout_symbol["text-writing-mode"]),
						"text-rotate": new Os(xt.layout_symbol["text-rotate"]),
						"text-padding": new Ls(xt.layout_symbol["text-padding"]),
						"text-keep-upright": new Ls(xt.layout_symbol["text-keep-upright"]),
						"text-transform": new Os(xt.layout_symbol["text-transform"]),
						"text-offset": new Os(xt.layout_symbol["text-offset"]),
						"text-allow-overlap": new Ls(xt.layout_symbol["text-allow-overlap"]),
						"text-overlap": new Ls(xt.layout_symbol["text-overlap"]),
						"text-ignore-placement": new Ls(xt.layout_symbol["text-ignore-placement"]),
						"text-optional": new Ls(xt.layout_symbol["text-optional"])
					});
				}
			};
			class ch {
				constructor(t$1) {
					if (void 0 === t$1.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
					this.type = t$1.property.overrides ? t$1.property.overrides.runtimeType : Vt, this.defaultValue = t$1;
				}
				evaluate(t$1) {
					if (t$1.formattedSection) {
						const e$1 = this.defaultValue.property.overrides;
						if (e$1 && e$1.hasOverride(t$1.formattedSection)) return e$1.getOverride(t$1.formattedSection);
					}
					return t$1.feature && t$1.featureState ? this.defaultValue.evaluate(t$1.feature, t$1.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(t$1) {
					this.defaultValue.isConstant() || t$1(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			os("FormatSectionOverride", ch, { omit: ["defaultValue"] });
			class hh extends Gs {
				constructor(t$1, e$1) {
					super(t$1, uh, e$1);
				}
				recalculate(t$1, e$1) {
					if (super.recalculate(t$1, e$1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
						const t$2 = this.layout.get("text-writing-mode");
						if (t$2) {
							const e$2 = [];
							for (const r$1 of t$2) e$2.indexOf(r$1) < 0 && e$2.push(r$1);
							this.layout._values["text-writing-mode"] = e$2;
						} else this.layout._values["text-writing-mode"] = ["horizontal"];
					}
					this._setPaintOverrides();
				}
				getValueAndResolveTokens(t$1, e$1, r$1, n$1) {
					const i$1 = this.layout.get(t$1).evaluate(e$1, {}, r$1, n$1), s$1 = this._unevaluatedLayout._values[t$1];
					return s$1.isDataDriven() || ei(s$1.value) || !i$1 ? i$1 : function(t$2, e$2) {
						return e$2.replace(/{([^{}]+)}/g, ((e$3, r$2) => t$2 && r$2 in t$2 ? String(t$2[r$2]) : ""));
					}(e$1.properties, i$1);
				}
				createBucket(t$1) {
					return new ah(t$1);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					throw new Error("Should take a different path in FeatureIndex");
				}
				_setPaintOverrides() {
					for (const t$1 of uh.paint.overridableProperties) {
						if (!hh.hasPaintOverride(this.layout, t$1)) continue;
						const e$1 = this.paint.get(t$1), r$1 = new ch(e$1), n$1 = new ti(r$1, e$1.property.specification);
						let i$1 = null;
						i$1 = "constant" === e$1.value.kind || "source" === e$1.value.kind ? new ni("source", n$1) : new ii("composite", n$1, e$1.value.zoomStops), this.paint._values[t$1] = new Ds(e$1.property, i$1, e$1.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(t$1, e$1, r$1) {
					return !(!this.layout || e$1.isDataDriven() || r$1.isDataDriven()) && hh.hasPaintOverride(this.layout, t$1);
				}
				static hasPaintOverride(t$1, e$1) {
					const r$1 = t$1.get("text-field"), n$1 = uh.paint.properties[e$1];
					let i$1 = !1;
					const s$1 = (t$2) => {
						for (const e$2 of t$2) if (n$1.overrides && n$1.overrides.hasOverride(e$2)) return void (i$1 = !0);
					};
					if ("constant" === r$1.value.kind && r$1.value.value instanceof Ce) s$1(r$1.value.value.sections);
					else if ("source" === r$1.value.kind || "composite" === r$1.value.kind) {
						const t$2 = (e$3) => {
							i$1 || (e$3 instanceof Ne && Ue(e$3.value) === Nt ? s$1(e$3.value.sections) : e$3 instanceof Ir ? s$1(e$3.sections) : e$3.eachChild(t$2));
						}, e$2 = r$1.value;
						e$2._styleExpression && t$2(e$2._styleExpression.expression);
					}
					return i$1;
				}
			}
			let ph;
			var fh = { get paint() {
				return ph = ph || new Ns({
					"background-color": new Ls(xt.paint_background["background-color"]),
					"background-pattern": new Us(xt.paint_background["background-pattern"]),
					"background-opacity": new Ls(xt.paint_background["background-opacity"])
				});
			} };
			class dh extends Gs {
				constructor(t$1, e$1) {
					super(t$1, fh, e$1);
				}
			}
			let yh;
			var mh = { get paint() {
				return yh = yh || new Ns({
					"raster-opacity": new Ls(xt.paint_raster["raster-opacity"]),
					"raster-hue-rotate": new Ls(xt.paint_raster["raster-hue-rotate"]),
					"raster-brightness-min": new Ls(xt.paint_raster["raster-brightness-min"]),
					"raster-brightness-max": new Ls(xt.paint_raster["raster-brightness-max"]),
					"raster-saturation": new Ls(xt.paint_raster["raster-saturation"]),
					"raster-contrast": new Ls(xt.paint_raster["raster-contrast"]),
					"raster-resampling": new Ls(xt.paint_raster["raster-resampling"]),
					"raster-fade-duration": new Ls(xt.paint_raster["raster-fade-duration"])
				});
			} };
			class gh extends Gs {
				constructor(t$1, e$1) {
					super(t$1, mh, e$1);
				}
			}
			class xh extends Gs {
				constructor(t$1, e$1) {
					super(t$1, {}, e$1), this.onAdd = (t$2) => {
						this.implementation.onAdd && this.implementation.onAdd(t$2, t$2.painter.context.gl);
					}, this.onRemove = (t$2) => {
						this.implementation.onRemove && this.implementation.onRemove(t$2, t$2.painter.context.gl);
					}, this.implementation = t$1;
				}
				is3D() {
					return "3d" === this.implementation.renderingMode;
				}
				hasOffscreenPass() {
					return void 0 !== this.implementation.prerender;
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {
					throw new Error("Custom layers cannot be serialized");
				}
			}
			class vh {
				constructor(t$1) {
					this._methodToThrottle = t$1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._methodToThrottle();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._methodToThrottle();
					}), 0));
				}
				remove() {
					delete this._channel, this._methodToThrottle = () => {};
				}
			}
			const bh = { once: !0 }, wh = 6371008.8;
			class _h {
				constructor(t$1, e$1) {
					if (isNaN(t$1) || isNaN(e$1)) throw new Error(`Invalid LngLat object: (${t$1}, ${e$1})`);
					if (this.lng = +t$1, this.lat = +e$1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new _h($(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(t$1) {
					const e$1 = Math.PI / 180, r$1 = this.lat * e$1, n$1 = t$1.lat * e$1, i$1 = Math.sin(r$1) * Math.sin(n$1) + Math.cos(r$1) * Math.cos(n$1) * Math.cos((t$1.lng - this.lng) * e$1);
					return wh * Math.acos(Math.min(i$1, 1));
				}
				static convert(t$1) {
					if (t$1 instanceof _h) return t$1;
					if (Array.isArray(t$1) && (2 === t$1.length || 3 === t$1.length)) return new _h(Number(t$1[0]), Number(t$1[1]));
					if (!Array.isArray(t$1) && "object" == typeof t$1 && null !== t$1) return new _h(Number("lng" in t$1 ? t$1.lng : t$1.lon), Number(t$1.lat));
					throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			const Sh = 2 * Math.PI * wh;
			function Ah(t$1) {
				return Sh * Math.cos(t$1 * Math.PI / 180);
			}
			function kh(t$1) {
				return (180 + t$1) / 360;
			}
			function Mh(t$1) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t$1 * Math.PI / 360))) / 360;
			}
			function Ih(t$1, e$1) {
				return t$1 / Ah(e$1);
			}
			function zh(t$1) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t$1) * Math.PI / 180)) - 90;
			}
			function Ph(t$1, e$1) {
				return t$1 * Ah(zh(e$1));
			}
			class Ch {
				constructor(t$1, e$1, r$1 = 0) {
					this.x = +t$1, this.y = +e$1, this.z = +r$1;
				}
				static fromLngLat(t$1, e$1 = 0) {
					const r$1 = _h.convert(t$1);
					return new Ch(kh(r$1.lng), Mh(r$1.lat), Ih(e$1, r$1.lat));
				}
				toLngLat() {
					return new _h(360 * this.x - 180, zh(this.y));
				}
				toAltitude() {
					return Ph(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / Sh * (t$1 = zh(this.y), 1 / Math.cos(t$1 * Math.PI / 180));
					var t$1;
				}
			}
			function Eh(t$1, e$1, r$1) {
				var n$1 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r$1);
				return [t$1 * n$1 - 2 * Math.PI * 6378137 / 2, e$1 * n$1 - 2 * Math.PI * 6378137 / 2];
			}
			class Th {
				constructor(t$1, e$1, r$1) {
					if (!function(t$2, e$2, r$2) {
						return !(t$2 < 0 || t$2 > 25 || r$2 < 0 || r$2 >= Math.pow(2, t$2) || e$2 < 0 || e$2 >= Math.pow(2, t$2));
					}(t$1, e$1, r$1)) throw new Error(`x=${e$1}, y=${r$1}, z=${t$1} outside of bounds. 0<=x<${Math.pow(2, t$1)}, 0<=y<${Math.pow(2, t$1)} 0<=z<=25 `);
					this.z = t$1, this.x = e$1, this.y = r$1, this.key = Fh(0, t$1, t$1, e$1, r$1);
				}
				equals(t$1) {
					return this.z === t$1.z && this.x === t$1.x && this.y === t$1.y;
				}
				url(t$1, e$1, r$1) {
					const n$1 = (s$1 = this.y, a$1 = this.z, o$1 = Eh(256 * (i$1 = this.x), 256 * (s$1 = Math.pow(2, a$1) - s$1 - 1), a$1), l$1 = Eh(256 * (i$1 + 1), 256 * (s$1 + 1), a$1), o$1[0] + "," + o$1[1] + "," + l$1[0] + "," + l$1[1]);
					var i$1, s$1, a$1, o$1, l$1;
					const u$1 = function(t$2, e$2, r$2) {
						let n$2, i$2 = "";
						for (let s$2 = t$2; s$2 > 0; s$2--) n$2 = 1 << s$2 - 1, i$2 += (e$2 & n$2 ? 1 : 0) + (r$2 & n$2 ? 2 : 0);
						return i$2;
					}(this.z, this.x, this.y);
					return t$1[(this.x + this.y) % t$1.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r$1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e$1 > 1 ? "@2x" : "").replace(/{quadkey}/g, u$1).replace(/{bbox-epsg-3857}/g, n$1);
				}
				isChildOf(t$1) {
					const e$1 = this.z - t$1.z;
					return e$1 > 0 && t$1.x === this.x >> e$1 && t$1.y === this.y >> e$1;
				}
				getTilePoint(t$1) {
					const e$1 = Math.pow(2, this.z);
					return new r((t$1.x * e$1 - this.x) * P, (t$1.y * e$1 - this.y) * P);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class Bh {
				constructor(t$1, e$1) {
					this.wrap = t$1, this.canonical = e$1, this.key = Fh(t$1, e$1.z, e$1.z, e$1.x, e$1.y);
				}
			}
			class Vh {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					if (this.terrainRttPosMatrix32f = null, t$1 < r$1) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t$1}; z = ${r$1}`);
					this.overscaledZ = t$1, this.wrap = e$1, this.canonical = new Th(r$1, +n$1, +i$1), this.key = Fh(e$1, t$1, r$1, n$1, i$1);
				}
				clone() {
					return new Vh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				equals(t$1) {
					return this.overscaledZ === t$1.overscaledZ && this.wrap === t$1.wrap && this.canonical.equals(t$1.canonical);
				}
				scaledTo(t$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const e$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? new Vh(t$1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Vh(t$1, this.wrap, t$1, this.canonical.x >> e$1, this.canonical.y >> e$1);
				}
				isOverscaled() {
					return this.overscaledZ > this.canonical.z;
				}
				calculateScaledKey(t$1, e$1) {
					if (t$1 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t$1}; overscaledZ = ${this.overscaledZ}`);
					const r$1 = this.canonical.z - t$1;
					return t$1 > this.canonical.z ? Fh(this.wrap * +e$1, t$1, this.canonical.z, this.canonical.x, this.canonical.y) : Fh(this.wrap * +e$1, t$1, t$1, this.canonical.x >> r$1, this.canonical.y >> r$1);
				}
				isChildOf(t$1) {
					if (t$1.wrap !== this.wrap) return !1;
					if (this.overscaledZ - t$1.overscaledZ <= 0) return !1;
					if (0 === t$1.overscaledZ) return this.overscaledZ > 0;
					const e$1 = this.canonical.z - t$1.canonical.z;
					return !(e$1 < 0) && t$1.canonical.x === this.canonical.x >> e$1 && t$1.canonical.y === this.canonical.y >> e$1;
				}
				children(t$1) {
					if (this.overscaledZ >= t$1) return [new Vh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					const e$1 = this.canonical.z + 1, r$1 = 2 * this.canonical.x, n$1 = 2 * this.canonical.y;
					return [
						new Vh(e$1, this.wrap, e$1, r$1, n$1),
						new Vh(e$1, this.wrap, e$1, r$1 + 1, n$1),
						new Vh(e$1, this.wrap, e$1, r$1, n$1 + 1),
						new Vh(e$1, this.wrap, e$1, r$1 + 1, n$1 + 1)
					];
				}
				isLessThan(t$1) {
					return this.wrap < t$1.wrap || !(this.wrap > t$1.wrap) && (this.overscaledZ < t$1.overscaledZ || !(this.overscaledZ > t$1.overscaledZ) && (this.canonical.x < t$1.canonical.x || !(this.canonical.x > t$1.canonical.x) && this.canonical.y < t$1.canonical.y));
				}
				wrapped() {
					return new Vh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(t$1) {
					return new Vh(this.overscaledZ, t$1, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return Math.pow(2, this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new Bh(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
				getTilePoint(t$1) {
					return this.canonical.getTilePoint(new Ch(t$1.x - this.wrap, t$1.y));
				}
			}
			function Fh(t$1, e$1, r$1, n$1, i$1) {
				(t$1 *= 2) < 0 && (t$1 = -1 * t$1 - 1);
				const s$1 = 1 << r$1;
				return (s$1 * s$1 * t$1 + s$1 * i$1 + n$1).toString(36) + r$1.toString(36) + e$1.toString(36);
			}
			function Dh(t$1, e$1) {
				return e$1 ? t$1.properties[e$1] : t$1.id;
			}
			os("CanonicalTileID", Th), os("OverscaledTileID", Vh, { omit: ["terrainRttPosMatrix32f"] });
			class $h {
				constructor() {
					this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity;
				}
				extend(t$1) {
					return this.minX = Math.min(this.minX, t$1.x), this.minY = Math.min(this.minY, t$1.y), this.maxX = Math.max(this.maxX, t$1.x), this.maxY = Math.max(this.maxY, t$1.y), this;
				}
				expandBy(t$1) {
					return this.minX -= t$1, this.minY -= t$1, this.maxX += t$1, this.maxY += t$1, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity), this;
				}
				shrinkBy(t$1) {
					return this.expandBy(-t$1);
				}
				map(t$1) {
					const e$1 = new $h();
					return e$1.extend(t$1(new r(this.minX, this.minY))), e$1.extend(t$1(new r(this.maxX, this.minY))), e$1.extend(t$1(new r(this.minX, this.maxY))), e$1.extend(t$1(new r(this.maxX, this.maxY))), e$1;
				}
				static fromPoints(t$1) {
					const e$1 = new $h();
					for (const r$1 of t$1) e$1.extend(r$1);
					return e$1;
				}
				contains(t$1) {
					return t$1.x >= this.minX && t$1.x <= this.maxX && t$1.y >= this.minY && t$1.y <= this.maxY;
				}
				empty() {
					return this.minX > this.maxX;
				}
				width() {
					return this.maxX - this.minX;
				}
				height() {
					return this.maxY - this.minY;
				}
				covers(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX >= this.minX && t$1.maxX <= this.maxX && t$1.minY >= this.minY && t$1.maxY <= this.maxY;
				}
				intersects(t$1) {
					return !this.empty() && !t$1.empty() && t$1.minX <= this.maxX && t$1.maxX >= this.minX && t$1.minY <= this.maxY && t$1.maxY >= this.minY;
				}
			}
			class Lh {
				constructor(t$1) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let e$1 = 0; e$1 < t$1.length; e$1++) {
						const r$1 = t$1[e$1];
						this._stringToNumber[r$1] = e$1, this._numberToString[e$1] = r$1;
					}
				}
				encode(t$1) {
					return this._stringToNumber[t$1];
				}
				decode(t$1) {
					if (t$1 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t$1} can't be >= this._numberToString.length ${this._numberToString.length}`);
					return this._numberToString[t$1];
				}
			}
			class Oh {
				constructor(t$1, e$1, r$1, n$1, i$1) {
					this.type = "Feature", this._vectorTileFeature = t$1, t$1._z = e$1, t$1._x = r$1, t$1._y = n$1, this.properties = t$1.properties, this.id = i$1;
				}
				get geometry() {
					return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
				}
				set geometry(t$1) {
					this._geometry = t$1;
				}
				toJSON() {
					const t$1 = { geometry: this.geometry };
					for (const e$1 in this) "_geometry" !== e$1 && "_vectorTileFeature" !== e$1 && (t$1[e$1] = this[e$1]);
					return t$1;
				}
			}
			class Rh {
				constructor(t$1, e$1) {
					this.tileID = t$1, this.x = t$1.canonical.x, this.y = t$1.canonical.y, this.z = t$1.canonical.z, this.grid = new ss(P, 16, 0), this.grid3D = new ss(P, 16, 0), this.featureIndexArray = new Ta(), this.promoteId = e$1;
				}
				insert(t$1, e$1, r$1, n$1, i$1, s$1) {
					const a$1 = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(r$1, n$1, i$1);
					const o$1 = s$1 ? this.grid3D : this.grid;
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const r$2 = e$1[t$2], n$2 = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let t$3 = 0; t$3 < r$2.length; t$3++) {
							const e$2 = r$2[t$3];
							n$2[0] = Math.min(n$2[0], e$2.x), n$2[1] = Math.min(n$2[1], e$2.y), n$2[2] = Math.max(n$2[2], e$2.x), n$2[3] = Math.max(n$2[3], e$2.y);
						}
						n$2[0] < P && n$2[1] < P && n$2[2] >= 0 && n$2[3] >= 0 && o$1.insert(a$1, n$2[0], n$2[1], n$2[2], n$2[3]);
					}
				}
				loadVTLayers() {
					return this.vtLayers || (this.vtLayers = new ku(new uc(this.rawTileData)).layers, this.sourceLayerCoder = new Lh(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
				}
				query(t$1, e$1, n$1, i$1) {
					this.loadVTLayers();
					const s$1 = t$1.params, a$1 = P / t$1.tileSize / t$1.scale, o$1 = pi(s$1.filter, s$1.globalState), l$1 = t$1.queryGeometry, u$1 = t$1.queryPadding * a$1, c$1 = $h.fromPoints(l$1), h$1 = this.grid.query(c$1.minX - u$1, c$1.minY - u$1, c$1.maxX + u$1, c$1.maxY + u$1), p$1 = $h.fromPoints(t$1.cameraQueryGeometry).expandBy(u$1), f$1 = this.grid3D.query(p$1.minX, p$1.minY, p$1.maxX, p$1.maxY, ((e$2, n$2, i$2, s$2) => function(t$2, e$3, n$3, i$3, s$3) {
						for (const r$1 of t$2) if (e$3 <= r$1.x && n$3 <= r$1.y && i$3 >= r$1.x && s$3 >= r$1.y) return !0;
						const a$2 = [
							new r(e$3, n$3),
							new r(e$3, s$3),
							new r(i$3, s$3),
							new r(i$3, n$3)
						];
						if (t$2.length > 2) {
							for (const e$4 of a$2) if (Xo(t$2, e$4)) return !0;
						}
						for (let e$4 = 0; e$4 < t$2.length - 1; e$4++) if (Zo(t$2[e$4], t$2[e$4 + 1], a$2)) return !0;
						return !1;
					}(t$1.cameraQueryGeometry, e$2 - u$1, n$2 - u$1, i$2 + u$1, s$2 + u$1)));
					for (const t$2 of f$1) h$1.push(t$2);
					h$1.sort(jh);
					const d$1 = {};
					let y$1;
					for (let r$1 = 0; r$1 < h$1.length; r$1++) {
						const u$2 = h$1[r$1];
						if (u$2 === y$1) continue;
						y$1 = u$2;
						const c$2 = this.featureIndexArray.get(u$2);
						let p$2 = null;
						this.loadMatchingFeature(d$1, c$2.bucketIndex, c$2.sourceLayerIndex, c$2.featureIndex, o$1, s$1.layers, s$1.availableImages, e$1, n$1, i$1, ((e$2, r$2, n$2) => (p$2 || (p$2 = To(e$2)), r$2.queryIntersectsFeature({
							queryGeometry: l$1,
							feature: e$2,
							featureState: n$2,
							geometry: p$2,
							zoom: this.z,
							transform: t$1.transform,
							pixelsToTileUnits: a$1,
							pixelPosMatrix: t$1.pixelPosMatrix,
							unwrappedTileID: this.tileID.toUnwrapped(),
							getElevation: t$1.getElevation
						}))));
					}
					return d$1;
				}
				loadMatchingFeature(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1) {
					const h$1 = this.bucketLayerIDs[e$1];
					if (s$1 && !h$1.some(((t$2) => s$1.has(t$2)))) return;
					const p$1 = this.sourceLayerCoder.decode(r$1), f$1 = this.vtLayers[p$1].feature(n$1);
					if (i$1.needGeometry) {
						const t$2 = Bo(f$1, !0);
						if (!i$1.filter(new zs(this.tileID.overscaledZ), t$2, this.tileID.canonical)) return;
					} else if (!i$1.filter(new zs(this.tileID.overscaledZ), f$1)) return;
					const d$1 = this.getId(f$1, p$1);
					for (let e$2 = 0; e$2 < h$1.length; e$2++) {
						const r$2 = h$1[e$2];
						if (s$1 && !s$1.has(r$2)) continue;
						const i$2 = o$1[r$2];
						if (!i$2) continue;
						let p$2 = {};
						d$1 && u$1 && (p$2 = u$1.getState(i$2.sourceLayer || "_geojsonTileLayer", d$1));
						const y$1 = L({}, l$1[r$2]);
						y$1.paint = Uh(y$1.paint, i$2.paint, f$1, p$2, a$1), y$1.layout = Uh(y$1.layout, i$2.layout, f$1, p$2, a$1);
						const m$1 = !c$1 || c$1(f$1, i$2, p$2);
						if (!m$1) continue;
						const g$1 = new Oh(f$1, this.z, this.x, this.y, d$1);
						g$1.layer = y$1;
						let x$1 = t$1[r$2];
						void 0 === x$1 && (x$1 = t$1[r$2] = []), x$1.push({
							featureIndex: n$1,
							feature: g$1,
							intersectionZ: m$1
						});
					}
				}
				lookupSymbolFeatures(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1) {
					const l$1 = {};
					this.loadVTLayers();
					const u$1 = pi(i$1.filterSpec, i$1.globalState);
					for (const i$2 of t$1) this.loadMatchingFeature(l$1, r$1, n$1, i$2, u$1, s$1, a$1, o$1, e$1);
					return l$1;
				}
				hasLayer(t$1) {
					for (const e$1 of this.bucketLayerIDs) for (const r$1 of e$1) if (t$1 === r$1) return !0;
					return !1;
				}
				getId(t$1, e$1) {
					var r$1;
					let n$1 = t$1.id;
					return this.promoteId && (n$1 = t$1.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e$1]], "boolean" == typeof n$1 && (n$1 = Number(n$1)), void 0 === n$1 && !(null === (r$1 = t$1.properties) || void 0 === r$1) && r$1.cluster && this.promoteId && (n$1 = Number(t$1.properties.cluster_id))), n$1;
				}
			}
			function Uh(t$1, e$1, r$1, n$1, i$1) {
				return R(t$1, ((t$2, s$1) => {
					const a$1 = e$1 instanceof $s ? e$1.get(s$1) : null;
					return a$1 && a$1.evaluate ? a$1.evaluate(r$1, n$1, i$1) : a$1;
				}));
			}
			function jh(t$1, e$1) {
				return e$1 - t$1;
			}
			function Nh(t$1, e$1, n$1, i$1, s$1) {
				const a$1 = [];
				for (let o$1 = 0; o$1 < t$1.length; o$1++) {
					const l$1 = t$1[o$1];
					let u$1;
					for (let t$2 = 0; t$2 < l$1.length - 1; t$2++) {
						let o$2 = l$1[t$2], c$1 = l$1[t$2 + 1];
						o$2.x < e$1 && c$1.x < e$1 || (o$2.x < e$1 ? o$2 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x < e$1 && (c$1 = new r(e$1, o$2.y + (e$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y < n$1 && c$1.y < n$1 || (o$2.y < n$1 ? o$2 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round() : c$1.y < n$1 && (c$1 = new r(o$2.x + (n$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), n$1)._round()), o$2.x >= i$1 && c$1.x >= i$1 || (o$2.x >= i$1 ? o$2 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round() : c$1.x >= i$1 && (c$1 = new r(i$1, o$2.y + (i$1 - o$2.x) / (c$1.x - o$2.x) * (c$1.y - o$2.y))._round()), o$2.y >= s$1 && c$1.y >= s$1 || (o$2.y >= s$1 ? o$2 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round() : c$1.y >= s$1 && (c$1 = new r(o$2.x + (s$1 - o$2.y) / (c$1.y - o$2.y) * (c$1.x - o$2.x), s$1)._round()), u$1 && o$2.equals(u$1[u$1.length - 1]) || (u$1 = [o$2], a$1.push(u$1)), u$1.push(c$1)))));
					}
				}
				return a$1;
			}
			os("FeatureIndex", Rh, { omit: ["rawTileData", "sourceLayerCoder"] });
			class qh extends r {
				constructor(t$1, e$1, r$1, n$1) {
					super(t$1, e$1), this.angle = r$1, void 0 !== n$1 && (this.segment = n$1);
				}
				clone() {
					return new qh(this.x, this.y, this.angle, this.segment);
				}
			}
			function Gh(t$1, e$1, r$1, n$1, i$1) {
				if (void 0 === e$1.segment || 0 === r$1) return !0;
				let s$1 = e$1, a$1 = e$1.segment + 1, o$1 = 0;
				for (; o$1 > -r$1 / 2;) {
					if (a$1--, a$1 < 0) return !1;
					o$1 -= t$1[a$1].dist(s$1), s$1 = t$1[a$1];
				}
				o$1 += t$1[a$1].dist(t$1[a$1 + 1]), a$1++;
				const l$1 = [];
				let u$1 = 0;
				for (; o$1 < r$1 / 2;) {
					const e$2 = t$1[a$1], r$2 = t$1[a$1 + 1];
					if (!r$2) return !1;
					let s$2 = t$1[a$1 - 1].angleTo(e$2) - e$2.angleTo(r$2);
					for (s$2 = Math.abs((s$2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l$1.push({
						distance: o$1,
						angleDelta: s$2
					}), u$1 += s$2; o$1 - l$1[0].distance > n$1;) u$1 -= l$1.shift().angleDelta;
					if (u$1 > i$1) return !1;
					a$1++, o$1 += e$2.dist(r$2);
				}
				return !0;
			}
			function Xh(t$1) {
				let e$1 = 0;
				for (let r$1 = 0; r$1 < t$1.length - 1; r$1++) e$1 += t$1[r$1].dist(t$1[r$1 + 1]);
				return e$1;
			}
			function Zh(t$1, e$1, r$1) {
				return t$1 ? .6 * e$1 * r$1 : 0;
			}
			function Yh(t$1, e$1) {
				return Math.max(t$1 ? t$1.right - t$1.left : 0, e$1 ? e$1.right - e$1.left : 0);
			}
			function Hh(t$1, e$1, r$1, n$1, i$1, s$1) {
				const a$1 = Zh(r$1, i$1, s$1), o$1 = Yh(r$1, n$1) * s$1;
				let l$1 = 0;
				const u$1 = Xh(t$1) / 2;
				for (let r$2 = 0; r$2 < t$1.length - 1; r$2++) {
					const n$2 = t$1[r$2], i$2 = t$1[r$2 + 1], s$2 = n$2.dist(i$2);
					if (l$1 + s$2 > u$1) {
						const c$1 = (u$1 - l$1) / s$2, h$1 = dr.number(n$2.x, i$2.x, c$1), p$1 = dr.number(n$2.y, i$2.y, c$1), f$1 = new qh(h$1, p$1, i$2.angleTo(n$2), r$2);
						return f$1._round(), !a$1 || Gh(t$1, f$1, o$1, a$1, e$1) ? f$1 : void 0;
					}
					l$1 += s$2;
				}
			}
			function Kh(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
				const u$1 = Zh(n$1, s$1, a$1), c$1 = Yh(n$1, i$1), h$1 = c$1 * a$1, p$1 = 0 === t$1[0].x || t$1[0].x === l$1 || 0 === t$1[0].y || t$1[0].y === l$1;
				return e$1 - h$1 < e$1 / 4 && (e$1 = h$1 + e$1 / 4), Jh(t$1, p$1 ? e$1 / 2 * o$1 % e$1 : (c$1 / 2 + 2 * s$1) * a$1 * o$1 % e$1, e$1, u$1, r$1, h$1, p$1, !1, l$1);
			}
			function Jh(t$1, e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1) {
				const u$1 = s$1 / 2, c$1 = Xh(t$1);
				let h$1 = 0, p$1 = e$1 - r$1, f$1 = [];
				for (let e$2 = 0; e$2 < t$1.length - 1; e$2++) {
					const a$2 = t$1[e$2], o$2 = t$1[e$2 + 1], d$1 = a$2.dist(o$2), y$1 = o$2.angleTo(a$2);
					for (; p$1 + r$1 < h$1 + d$1;) {
						p$1 += r$1;
						const m$1 = (p$1 - h$1) / d$1, g$1 = dr.number(a$2.x, o$2.x, m$1), x$1 = dr.number(a$2.y, o$2.y, m$1);
						if (g$1 >= 0 && g$1 < l$1 && x$1 >= 0 && x$1 < l$1 && p$1 - u$1 >= 0 && p$1 + u$1 <= c$1) {
							const r$2 = new qh(g$1, x$1, y$1, e$2);
							r$2._round(), n$1 && !Gh(t$1, r$2, s$1, n$1, i$1) || f$1.push(r$2);
						}
					}
					h$1 += d$1;
				}
				return o$1 || f$1.length || a$1 || (f$1 = Jh(t$1, h$1 / 2, r$1, n$1, i$1, s$1, a$1, !0, l$1)), f$1;
			}
			function Wh(t$1, e$1, n$1, i$1) {
				const s$1 = [], a$1 = t$1.image, o$1 = a$1.pixelRatio, l$1 = a$1.paddedRect.w - 2, u$1 = a$1.paddedRect.h - 2;
				let c$1 = {
					x1: t$1.left,
					y1: t$1.top,
					x2: t$1.right,
					y2: t$1.bottom
				};
				const h$1 = a$1.stretchX || [[0, l$1]], p$1 = a$1.stretchY || [[0, u$1]], f$1 = (t$2, e$2) => t$2 + e$2[1] - e$2[0], d$1 = h$1.reduce(f$1, 0), y$1 = p$1.reduce(f$1, 0), m$1 = l$1 - d$1, g$1 = u$1 - y$1;
				let x$1 = 0, v$1 = d$1, b$1 = 0, w$1 = y$1, _$1 = 0, S$1 = m$1, A$1 = 0, k$1 = g$1;
				if (a$1.content && i$1) {
					const e$2 = a$1.content, r$1 = e$2[2] - e$2[0], n$2 = e$2[3] - e$2[1];
					(a$1.textFitWidth || a$1.textFitHeight) && (c$1 = Yc(t$1)), x$1 = Qh(h$1, 0, e$2[0]), b$1 = Qh(p$1, 0, e$2[1]), v$1 = Qh(h$1, e$2[0], e$2[2]), w$1 = Qh(p$1, e$2[1], e$2[3]), _$1 = e$2[0] - x$1, A$1 = e$2[1] - b$1, S$1 = r$1 - v$1, k$1 = n$2 - w$1;
				}
				const M$1 = c$1.x1, I$1 = c$1.y1, z$1 = c$1.x2 - M$1, P$1 = c$1.y2 - I$1, C$1 = (t$2, i$2, s$2, l$2) => {
					const u$2 = ep(t$2.stretch - x$1, v$1, z$1, M$1), c$2 = rp(t$2.fixed - _$1, S$1, t$2.stretch, d$1), h$2 = ep(i$2.stretch - b$1, w$1, P$1, I$1), p$2 = rp(i$2.fixed - A$1, k$1, i$2.stretch, y$1), f$2 = ep(s$2.stretch - x$1, v$1, z$1, M$1), m$2 = rp(s$2.fixed - _$1, S$1, s$2.stretch, d$1), g$2 = ep(l$2.stretch - b$1, w$1, P$1, I$1), C$2 = rp(l$2.fixed - A$1, k$1, l$2.stretch, y$1), E$1 = new r(u$2, h$2), T$1 = new r(f$2, h$2), B$1 = new r(f$2, g$2), V$1 = new r(u$2, g$2), F$1 = new r(c$2 / o$1, p$2 / o$1), D$1 = new r(m$2 / o$1, C$2 / o$1), $$1 = e$1 * Math.PI / 180;
					if ($$1) {
						const t$3 = Math.sin($$1), e$2 = Math.cos($$1), r$1 = [
							e$2,
							-t$3,
							t$3,
							e$2
						];
						E$1._matMult(r$1), T$1._matMult(r$1), V$1._matMult(r$1), B$1._matMult(r$1);
					}
					const L$1 = t$2.stretch + t$2.fixed, O$1 = i$2.stretch + i$2.fixed;
					return {
						tl: E$1,
						tr: T$1,
						bl: V$1,
						br: B$1,
						tex: {
							x: a$1.paddedRect.x + 1 + L$1,
							y: a$1.paddedRect.y + 1 + O$1,
							w: s$2.stretch + s$2.fixed - L$1,
							h: l$2.stretch + l$2.fixed - O$1
						},
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: F$1,
						pixelOffsetBR: D$1,
						minFontScaleX: S$1 / o$1 / z$1,
						minFontScaleY: k$1 / o$1 / P$1,
						isSDF: n$1
					};
				};
				if (i$1 && (a$1.stretchX || a$1.stretchY)) {
					const t$2 = tp(h$1, m$1, d$1), e$2 = tp(p$1, g$1, y$1);
					for (let r$1 = 0; r$1 < t$2.length - 1; r$1++) {
						const n$2 = t$2[r$1], i$2 = t$2[r$1 + 1];
						for (let t$3 = 0; t$3 < e$2.length - 1; t$3++) s$1.push(C$1(n$2, e$2[t$3], i$2, e$2[t$3 + 1]));
					}
				} else s$1.push(C$1({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l$1 + 1
				}, {
					fixed: 0,
					stretch: u$1 + 1
				}));
				return s$1;
			}
			function Qh(t$1, e$1, r$1) {
				let n$1 = 0;
				for (const i$1 of t$1) n$1 += Math.max(e$1, Math.min(r$1, i$1[1])) - Math.max(e$1, Math.min(r$1, i$1[0]));
				return n$1;
			}
			function tp(t$1, e$1, r$1) {
				const n$1 = [{
					fixed: -1,
					stretch: 0
				}];
				for (const [e$2, r$2] of t$1) {
					const t$2 = n$1[n$1.length - 1];
					n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch
					}), n$1.push({
						fixed: e$2 - t$2.stretch,
						stretch: t$2.stretch + (r$2 - e$2)
					});
				}
				return n$1.push({
					fixed: e$1 + 1,
					stretch: r$1
				}), n$1;
			}
			function ep(t$1, e$1, r$1, n$1) {
				return t$1 / e$1 * r$1 + n$1;
			}
			function rp(t$1, e$1, r$1, n$1) {
				return t$1 - e$1 * r$1 / n$1;
			}
			os("Anchor", qh);
			class np {
				constructor(t$1, e$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1) {
					var h$1;
					if (this.boxStartIndex = t$1.length, u$1) {
						let t$2 = a$1.top, e$2 = a$1.bottom;
						const r$1 = a$1.collisionPadding;
						r$1 && (t$2 -= r$1[1], e$2 += r$1[3]);
						let n$2 = e$2 - t$2;
						n$2 > 0 && (n$2 = Math.max(10, n$2), this.circleDiameter = n$2);
					} else {
						const u$2 = (null === (h$1 = a$1.image) || void 0 === h$1 ? void 0 : h$1.content) && (a$1.image.textFitWidth || a$1.image.textFitHeight) ? Yc(a$1) : {
							x1: a$1.left,
							y1: a$1.top,
							x2: a$1.right,
							y2: a$1.bottom
						};
						u$2.y1 = u$2.y1 * o$1 - l$1[0], u$2.y2 = u$2.y2 * o$1 + l$1[2], u$2.x1 = u$2.x1 * o$1 - l$1[3], u$2.x2 = u$2.x2 * o$1 + l$1[1];
						const p$1 = a$1.collisionPadding;
						if (p$1 && (u$2.x1 -= p$1[0] * o$1, u$2.y1 -= p$1[1] * o$1, u$2.x2 += p$1[2] * o$1, u$2.y2 += p$1[3] * o$1), c$1) {
							const t$2 = new r(u$2.x1, u$2.y1), e$2 = new r(u$2.x2, u$2.y1), n$2 = new r(u$2.x1, u$2.y2), i$2 = new r(u$2.x2, u$2.y2), s$2 = c$1 * Math.PI / 180;
							t$2._rotate(s$2), e$2._rotate(s$2), n$2._rotate(s$2), i$2._rotate(s$2), u$2.x1 = Math.min(t$2.x, e$2.x, n$2.x, i$2.x), u$2.x2 = Math.max(t$2.x, e$2.x, n$2.x, i$2.x), u$2.y1 = Math.min(t$2.y, e$2.y, n$2.y, i$2.y), u$2.y2 = Math.max(t$2.y, e$2.y, n$2.y, i$2.y);
						}
						t$1.emplaceBack(e$1.x, e$1.y, u$2.x1, u$2.y1, u$2.x2, u$2.y2, n$1, i$1, s$1);
					}
					this.boxEndIndex = t$1.length;
				}
			}
			class ip {
				constructor(t$1 = [], e$1 = (t$2, e$2) => t$2 < e$2 ? -1 : t$2 > e$2 ? 1 : 0) {
					if (this.data = t$1, this.length = this.data.length, this.compare = e$1, this.length > 0) for (let t$2 = (this.length >> 1) - 1; t$2 >= 0; t$2--) this._down(t$2);
				}
				push(t$1) {
					this.data.push(t$1), this._up(this.length++);
				}
				pop() {
					if (0 === this.length) return;
					const t$1 = this.data[0], e$1 = this.data.pop();
					return --this.length > 0 && (this.data[0] = e$1, this._down(0)), t$1;
				}
				peek() {
					return this.data[0];
				}
				_up(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = e$1[t$1];
					for (; t$1 > 0;) {
						const i$1 = t$1 - 1 >> 1, s$1 = e$1[i$1];
						if (r$1(n$1, s$1) >= 0) break;
						e$1[t$1] = s$1, t$1 = i$1;
					}
					e$1[t$1] = n$1;
				}
				_down(t$1) {
					const { data: e$1, compare: r$1 } = this, n$1 = this.length >> 1, i$1 = e$1[t$1];
					for (; t$1 < n$1;) {
						let n$2 = 1 + (t$1 << 1);
						const s$1 = n$2 + 1;
						if (s$1 < this.length && r$1(e$1[s$1], e$1[n$2]) < 0 && (n$2 = s$1), r$1(e$1[n$2], i$1) >= 0) break;
						e$1[t$1] = e$1[n$2], t$1 = n$2;
					}
					e$1[t$1] = i$1;
				}
			}
			function sp(t$1, e$1 = 1, n$1 = !1) {
				const i$1 = $h.fromPoints(t$1[0]), s$1 = Math.min(i$1.width(), i$1.height());
				let a$1 = s$1 / 2;
				const o$1 = new ip([], ap), { minX: l$1, minY: u$1, maxX: c$1, maxY: h$1 } = i$1;
				if (0 === s$1) return new r(l$1, u$1);
				for (let e$2 = l$1; e$2 < c$1; e$2 += s$1) for (let r$1 = u$1; r$1 < h$1; r$1 += s$1) o$1.push(new op(e$2 + a$1, r$1 + a$1, a$1, t$1));
				let p$1 = function(t$2) {
					let e$2 = 0, r$1 = 0, n$2 = 0;
					const i$2 = t$2[0];
					for (let t$3 = 0, s$2 = i$2.length, a$2 = s$2 - 1; t$3 < s$2; a$2 = t$3++) {
						const s$3 = i$2[t$3], o$2 = i$2[a$2], l$2 = s$3.x * o$2.y - o$2.x * s$3.y;
						r$1 += (s$3.x + o$2.x) * l$2, n$2 += (s$3.y + o$2.y) * l$2, e$2 += 3 * l$2;
					}
					return new op(r$1 / e$2, n$2 / e$2, 0, t$2);
				}(t$1), f$1 = o$1.length;
				for (; o$1.length;) {
					const r$1 = o$1.pop();
					(r$1.d > p$1.d || !p$1.d) && (p$1 = r$1, n$1 && console.log("found best %d after %d probes", Math.round(1e4 * r$1.d) / 1e4, f$1)), r$1.max - p$1.d <= e$1 || (a$1 = r$1.h / 2, o$1.push(new op(r$1.p.x - a$1, r$1.p.y - a$1, a$1, t$1)), o$1.push(new op(r$1.p.x + a$1, r$1.p.y - a$1, a$1, t$1)), o$1.push(new op(r$1.p.x - a$1, r$1.p.y + a$1, a$1, t$1)), o$1.push(new op(r$1.p.x + a$1, r$1.p.y + a$1, a$1, t$1)), f$1 += 4);
				}
				return n$1 && (console.log(`num probes: ${f$1}`), console.log(`best distance: ${p$1.d}`)), p$1.p;
			}
			function ap(t$1, e$1) {
				return e$1.max - t$1.max;
			}
			function op(t$1, e$1, n$1, i$1) {
				this.p = new r(t$1, e$1), this.h = n$1, this.d = function(t$2, e$2) {
					let r$1 = !1, n$2 = Infinity;
					for (let i$2 = 0; i$2 < e$2.length; i$2++) {
						const s$1 = e$2[i$2];
						for (let e$3 = 0, i$3 = s$1.length, a$1 = i$3 - 1; e$3 < i$3; a$1 = e$3++) {
							const i$4 = s$1[e$3], o$1 = s$1[a$1];
							i$4.y > t$2.y != o$1.y > t$2.y && t$2.x < (o$1.x - i$4.x) * (t$2.y - i$4.y) / (o$1.y - i$4.y) + i$4.x && (r$1 = !r$1), n$2 = Math.min(n$2, qo(t$2, i$4, o$1));
						}
					}
					return (r$1 ? 1 : -1) * Math.sqrt(n$2);
				}(this.p, i$1), this.max = this.d + this.h * Math.SQRT2;
			}
			var lp;
			t.aE = void 0, (lp = t.aE || (t.aE = {}))[lp.center = 1] = "center", lp[lp.left = 2] = "left", lp[lp.right = 3] = "right", lp[lp.top = 4] = "top", lp[lp.bottom = 5] = "bottom", lp[lp["top-left"] = 6] = "top-left", lp[lp["top-right"] = 7] = "top-right", lp[lp["bottom-left"] = 8] = "bottom-left", lp[lp["bottom-right"] = 9] = "bottom-right";
			const up = Number.POSITIVE_INFINITY;
			function cp(t$1, e$1) {
				return e$1[1] !== up ? function(t$2, e$2, r$1) {
					let n$1 = 0, i$1 = 0;
					switch (e$2 = Math.abs(e$2), r$1 = Math.abs(r$1), t$2) {
						case "top-right":
						case "top-left":
						case "top":
							i$1 = r$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": i$1 = 7 - r$1;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
						case "right":
							n$1 = -e$2;
							break;
						case "top-left":
						case "bottom-left":
						case "left": n$1 = e$2;
					}
					return [n$1, i$1];
				}(t$1, e$1[0], e$1[1]) : function(t$2, e$2) {
					let r$1 = 0, n$1 = 0;
					e$2 < 0 && (e$2 = 0);
					const i$1 = e$2 / Math.SQRT2;
					switch (t$2) {
						case "top-right":
						case "top-left":
							n$1 = i$1 - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							n$1 = 7 - i$1;
							break;
						case "bottom":
							n$1 = 7 - e$2;
							break;
						case "top": n$1 = e$2 - 7;
					}
					switch (t$2) {
						case "top-right":
						case "bottom-right":
							r$1 = -i$1;
							break;
						case "top-left":
						case "bottom-left":
							r$1 = i$1;
							break;
						case "left":
							r$1 = e$2;
							break;
						case "right": r$1 = -e$2;
					}
					return [r$1, n$1];
				}(t$1, e$1[0]);
			}
			function hp(t$1, e$1, r$1) {
				var n$1;
				const i$1 = t$1.layout, s$1 = null === (n$1 = i$1.get("text-variable-anchor-offset")) || void 0 === n$1 ? void 0 : n$1.evaluate(e$1, {}, r$1);
				if (s$1) {
					const t$2 = s$1.values, e$2 = [];
					for (let r$2 = 0; r$2 < t$2.length; r$2 += 2) {
						const n$2 = e$2[r$2] = t$2[r$2], i$2 = t$2[r$2 + 1].map(((t$3) => t$3 * sc));
						n$2.startsWith("top") ? i$2[1] -= 7 : n$2.startsWith("bottom") && (i$2[1] += 7), e$2[r$2 + 1] = i$2;
					}
					return new De(e$2);
				}
				const a$1 = i$1.get("text-variable-anchor");
				if (a$1) {
					let n$2;
					n$2 = void 0 !== t$1._unevaluatedLayout.getValue("text-radial-offset") ? [i$1.get("text-radial-offset").evaluate(e$1, {}, r$1) * sc, up] : i$1.get("text-offset").evaluate(e$1, {}, r$1).map(((t$2) => t$2 * sc));
					const s$2 = [];
					for (const t$2 of a$1) s$2.push(t$2, cp(t$2, n$2));
					return new De(s$2);
				}
				return null;
			}
			function pp(t$1) {
				switch (t$1) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function fp(e$1, r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1) {
				let f$1 = a$1.textMaxSize.evaluate(r$1, {});
				void 0 === f$1 && (f$1 = o$1);
				const d$1 = e$1.layers[0].layout, y$1 = d$1.get("icon-offset").evaluate(r$1, {}, h$1), m$1 = yp(n$1.horizontal), g$1 = o$1 / 24, x$1 = e$1.tilePixelRatio * g$1, v$1 = e$1.tilePixelRatio * f$1 / 24, b$1 = e$1.tilePixelRatio * l$1, w$1 = e$1.tilePixelRatio * d$1.get("symbol-spacing"), _$1 = d$1.get("text-padding") * e$1.tilePixelRatio, S$1 = function(t$1, e$2, r$2, n$2 = 1) {
					const i$2 = t$1.get("icon-padding").evaluate(e$2, {}, r$2), s$2 = i$2 && i$2.values;
					return [
						s$2[0] * n$2,
						s$2[1] * n$2,
						s$2[2] * n$2,
						s$2[3] * n$2
					];
				}(d$1, r$1, h$1, e$1.tilePixelRatio), A$1 = d$1.get("text-max-angle") / 180 * Math.PI, k$1 = "viewport" !== d$1.get("text-rotation-alignment") && "point" !== d$1.get("symbol-placement"), M$1 = "map" === d$1.get("icon-rotation-alignment") && "point" !== d$1.get("symbol-placement"), I$1 = d$1.get("symbol-placement"), z$1 = w$1 / 2, C$1 = d$1.get("icon-text-fit");
				let E$1;
				i$1 && "none" !== C$1 && (e$1.allowVerticalPlacement && n$1.vertical && (E$1 = Hc(i$1, n$1.vertical, C$1, d$1.get("icon-text-fit-padding"), y$1, g$1)), m$1 && (i$1 = Hc(i$1, m$1, C$1, d$1.get("icon-text-fit-padding"), y$1, g$1)));
				const T$1 = h$1 ? p$1.line.getGranularityForZoomLevel(h$1.z) : 1, B$1 = (l$2, p$2) => {
					p$2.x < 0 || p$2.x >= P || p$2.y < 0 || p$2.y >= P || function(e$2, r$2, n$2, i$2, s$2, a$2, o$2, l$3, u$2, c$2, h$2, p$3, f$2, d$2, y$2, m$2, g$2, x$2, v$2, b$2, w$2, _$2, S$2, A$2, k$2) {
						const M$2 = e$2.addToLineVertexArray(r$2, n$2);
						let I$2, z$2, P$1, C$2, E$2 = 0, T$2 = 0, B$2 = 0, V$1 = 0, F$1 = -1, D$1 = -1;
						const $$1 = {};
						let L$1 = oo("");
						if (e$2.allowVerticalPlacement && i$2.vertical) {
							const t$1 = l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2) + 90;
							P$1 = new np(u$2, r$2, c$2, h$2, p$3, i$2.vertical, f$2, d$2, y$2, t$1), o$2 && (C$2 = new np(u$2, r$2, c$2, h$2, p$3, o$2, g$2, x$2, y$2, t$1));
						}
						if (s$2) {
							const n$3 = l$3.layout.get("icon-rotate").evaluate(w$2, {}), i$3 = "none" !== l$3.layout.get("icon-text-fit"), a$3 = Wh(s$2, n$3, S$2, i$3), f$3 = o$2 ? Wh(o$2, n$3, S$2, i$3) : void 0;
							z$2 = new np(u$2, r$2, c$2, h$2, p$3, s$2, g$2, x$2, !1, n$3), E$2 = 4 * a$3.length;
							const d$3 = e$2.iconSizeData;
							let y$3 = null;
							"source" === d$3.kind ? (y$3 = [Kc * l$3.layout.get("icon-size").evaluate(w$2, {})], y$3[0] > Jc && q(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d$3.kind && (y$3 = [Kc * _$2.compositeIconSizes[0].evaluate(w$2, {}, A$2), Kc * _$2.compositeIconSizes[1].evaluate(w$2, {}, A$2)], (y$3[0] > Jc || y$3[1] > Jc) && q(`${e$2.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e$2.addSymbols(e$2.icon, a$3, y$3, b$2, v$2, w$2, t.ao.none, r$2, M$2.lineStartIndex, M$2.lineLength, -1, A$2), F$1 = e$2.icon.placedSymbolArray.length - 1, f$3 && (T$2 = 4 * f$3.length, e$2.addSymbols(e$2.icon, f$3, y$3, b$2, v$2, w$2, t.ao.vertical, r$2, M$2.lineStartIndex, M$2.lineLength, -1, A$2), D$1 = e$2.icon.placedSymbolArray.length - 1);
						}
						const O$1 = Object.keys(i$2.horizontal);
						for (const n$3 of O$1) {
							const s$3 = i$2.horizontal[n$3];
							if (!I$2) {
								L$1 = oo(s$3.text);
								const t$1 = l$3.layout.get("text-rotate").evaluate(w$2, {}, A$2);
								I$2 = new np(u$2, r$2, c$2, h$2, p$3, s$3, f$2, d$2, y$2, t$1);
							}
							const o$3 = 1 === s$3.positionedLines.length;
							if (B$2 += dp(e$2, r$2, s$3, a$2, l$3, y$2, w$2, m$2, M$2, i$2.vertical ? t.ao.horizontal : t.ao.horizontalOnly, o$3 ? O$1 : [n$3], $$1, F$1, _$2, A$2), o$3) break;
						}
						i$2.vertical && (V$1 += dp(e$2, r$2, i$2.vertical, a$2, l$3, y$2, w$2, m$2, M$2, t.ao.vertical, ["vertical"], $$1, D$1, _$2, A$2));
						const R$1 = I$2 ? I$2.boxStartIndex : e$2.collisionBoxArray.length, U$1 = I$2 ? I$2.boxEndIndex : e$2.collisionBoxArray.length, j$1 = P$1 ? P$1.boxStartIndex : e$2.collisionBoxArray.length, N$1 = P$1 ? P$1.boxEndIndex : e$2.collisionBoxArray.length, G$1 = z$2 ? z$2.boxStartIndex : e$2.collisionBoxArray.length, X$1 = z$2 ? z$2.boxEndIndex : e$2.collisionBoxArray.length, Z$1 = C$2 ? C$2.boxStartIndex : e$2.collisionBoxArray.length, Y$1 = C$2 ? C$2.boxEndIndex : e$2.collisionBoxArray.length;
						let H$1 = -1;
						const K$1 = (t$1, e$3) => t$1 && t$1.circleDiameter ? Math.max(t$1.circleDiameter, e$3) : e$3;
						H$1 = K$1(I$2, H$1), H$1 = K$1(P$1, H$1), H$1 = K$1(z$2, H$1), H$1 = K$1(C$2, H$1);
						const J$1 = H$1 > -1 ? 1 : 0;
						J$1 && (H$1 *= k$2 / sc), e$2.glyphOffsetArray.length >= ah.MAX_GLYPHS && q("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w$2.sortKey && e$2.addToSortKeyRanges(e$2.symbolInstances.length, w$2.sortKey);
						const W$1 = hp(l$3, w$2, A$2), [Q$1, tt$1] = function(e$3, r$3) {
							const n$3 = e$3.length, i$3 = null == r$3 ? void 0 : r$3.values;
							if ((null == i$3 ? void 0 : i$3.length) > 0) for (let r$4 = 0; r$4 < i$3.length; r$4 += 2) {
								const n$4 = i$3[r$4 + 1];
								e$3.emplaceBack(t.aE[i$3[r$4]], n$4[0], n$4[1]);
							}
							return [n$3, e$3.length];
						}(e$2.textAnchorOffsets, W$1);
						e$2.symbolInstances.emplaceBack(r$2.x, r$2.y, $$1.right >= 0 ? $$1.right : -1, $$1.center >= 0 ? $$1.center : -1, $$1.left >= 0 ? $$1.left : -1, $$1.vertical || -1, F$1, D$1, L$1, R$1, U$1, j$1, N$1, G$1, X$1, Z$1, Y$1, c$2, B$2, V$1, E$2, T$2, J$1, 0, f$2, H$1, Q$1, tt$1);
					}(e$1, p$2, l$2, n$1, i$1, s$1, E$1, e$1.layers[0], e$1.collisionBoxArray, r$1.index, r$1.sourceLayerIndex, e$1.index, x$1, [
						_$1,
						_$1,
						_$1,
						_$1
					], k$1, u$1, b$1, S$1, M$1, y$1, r$1, a$1, c$1, h$1, o$1);
				};
				if ("line" === I$1) for (const t$1 of Nh(r$1.geometry, 0, 0, P, P)) {
					const r$2 = lu(t$1, T$1), s$2 = Kh(r$2, w$1, A$1, n$1.vertical || m$1, i$1, 24, v$1, e$1.overscaling, P);
					for (const t$2 of s$2) m$1 && mp(e$1, m$1.text, z$1, t$2) || B$1(r$2, t$2);
				}
				else if ("line-center" === I$1) {
					for (const t$1 of r$1.geometry) if (t$1.length > 1) {
						const e$2 = lu(t$1, T$1), r$2 = Hh(e$2, A$1, n$1.vertical || m$1, i$1, 24, v$1);
						r$2 && B$1(e$2, r$2);
					}
				} else if ("Polygon" === r$1.type) for (const t$1 of Qr(r$1.geometry, 0)) {
					const e$2 = sp(t$1, 16);
					B$1(lu(t$1[0], T$1, !0), new qh(e$2.x, e$2.y, 0));
				}
				else if ("LineString" === r$1.type) for (const t$1 of r$1.geometry) {
					const e$2 = lu(t$1, T$1);
					B$1(e$2, new qh(e$2[0].x, e$2[0].y, 0));
				}
				else if ("Point" === r$1.type) for (const t$1 of r$1.geometry) for (const e$2 of t$1) B$1([e$2], new qh(e$2.x, e$2.y, 0));
			}
			function dp(t$1, e$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1) {
				const m$1 = function(t$2, e$2, n$2, i$2, s$2, a$2, o$2, l$2) {
					const u$2 = i$2.layout.get("text-rotate").evaluate(a$2, {}) * Math.PI / 180, c$2 = [];
					for (const t$3 of e$2.positionedLines) for (const i$3 of t$3.positionedGlyphs) {
						if (!i$3.rect) continue;
						const a$3 = i$3.rect || {};
						let h$2 = 4, p$2 = !0, f$2 = 1, d$2 = 0;
						const y$2 = (s$2 || l$2) && i$3.vertical, m$2 = i$3.metrics.advance * i$3.scale / 2;
						if (l$2 && e$2.verticalizable && (d$2 = t$3.lineOffset / 2 - (i$3.imageName ? -(sc - i$3.metrics.width * i$3.scale) / 2 : (i$3.scale - 1) * sc)), i$3.imageName) {
							const t$4 = o$2[i$3.imageName];
							p$2 = t$4.sdf, f$2 = t$4.pixelRatio, h$2 = 1 / f$2;
						}
						const g$2 = s$2 ? [i$3.x + m$2, i$3.y] : [0, 0];
						let x$2 = s$2 ? [0, 0] : [i$3.x + m$2 + n$2[0], i$3.y + n$2[1] - d$2], v$1 = [0, 0];
						y$2 && (v$1 = x$2, x$2 = [0, 0]);
						const b$1 = i$3.metrics.isDoubleResolution ? 2 : 1, w$1 = (i$3.metrics.left - h$2) * i$3.scale - m$2 + x$2[0], _$1 = (-i$3.metrics.top - h$2) * i$3.scale + x$2[1], S$1 = w$1 + a$3.w / b$1 * i$3.scale / f$2, A$1 = _$1 + a$3.h / b$1 * i$3.scale / f$2, k$1 = new r(w$1, _$1), M$1 = new r(S$1, _$1), I$1 = new r(w$1, A$1), z$1 = new r(S$1, A$1);
						if (y$2) {
							const t$4 = new r(-m$2, m$2 - -17), e$3 = -Math.PI / 2, n$3 = 12 - m$2, s$3 = new r(22 - n$3, -(i$3.imageName ? n$3 : 0)), a$4 = new r(...v$1);
							k$1._rotateAround(e$3, t$4)._add(s$3)._add(a$4), M$1._rotateAround(e$3, t$4)._add(s$3)._add(a$4), I$1._rotateAround(e$3, t$4)._add(s$3)._add(a$4), z$1._rotateAround(e$3, t$4)._add(s$3)._add(a$4);
						}
						if (u$2) {
							const t$4 = Math.sin(u$2), e$3 = Math.cos(u$2), r$1 = [
								e$3,
								-t$4,
								t$4,
								e$3
							];
							k$1._matMult(r$1), M$1._matMult(r$1), I$1._matMult(r$1), z$1._matMult(r$1);
						}
						const P$1 = new r(0, 0), C$1 = new r(0, 0);
						c$2.push({
							tl: k$1,
							tr: M$1,
							bl: I$1,
							br: z$1,
							tex: a$3,
							writingMode: e$2.writingMode,
							glyphOffset: g$2,
							sectionIndex: i$3.sectionIndex,
							isSDF: p$2,
							pixelOffsetTL: P$1,
							pixelOffsetBR: C$1,
							minFontScaleX: 0,
							minFontScaleY: 0
						});
					}
					return c$2;
				}(0, n$1, l$1, s$1, a$1, o$1, i$1, t$1.allowVerticalPlacement), g$1 = t$1.textSizeData;
				let x$1 = null;
				"source" === g$1.kind ? (x$1 = [Kc * s$1.layout.get("text-size").evaluate(o$1, {})], x$1[0] > Jc && q(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g$1.kind && (x$1 = [Kc * d$1.compositeTextSizes[0].evaluate(o$1, {}, y$1), Kc * d$1.compositeTextSizes[1].evaluate(o$1, {}, y$1)], (x$1[0] > Jc || x$1[1] > Jc) && q(`${t$1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t$1.addSymbols(t$1.text, m$1, x$1, l$1, a$1, o$1, c$1, e$1, u$1.lineStartIndex, u$1.lineLength, f$1, y$1);
				for (const e$2 of h$1) p$1[e$2] = t$1.text.placedSymbolArray.length - 1;
				return 4 * m$1.length;
			}
			function yp(t$1) {
				for (const e$1 in t$1) return t$1[e$1];
				return null;
			}
			function mp(t$1, e$1, r$1, n$1) {
				const i$1 = t$1.compareText;
				if (e$1 in i$1) {
					const t$2 = i$1[e$1];
					for (let e$2 = t$2.length - 1; e$2 >= 0; e$2--) if (n$1.dist(t$2[e$2]) < r$1) return !0;
				} else i$1[e$1] = [];
				return i$1[e$1].push(n$1), !1;
			}
			const gp = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class xp {
				static from(t$1) {
					if (!(t$1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
					const [e$1, r$1] = new Uint8Array(t$1, 0, 2);
					if (219 !== e$1) throw new Error("Data does not appear to be in a KDBush format.");
					const n$1 = r$1 >> 4;
					if (1 !== n$1) throw new Error(`Got v${n$1} data when expected v1.`);
					const i$1 = gp[15 & r$1];
					if (!i$1) throw new Error("Unrecognized array type.");
					const [s$1] = new Uint16Array(t$1, 2, 1), [a$1] = new Uint32Array(t$1, 4, 1);
					return new xp(a$1, s$1, i$1, t$1);
				}
				constructor(t$1, e$1 = 64, r$1 = Float64Array, n$1) {
					if (isNaN(t$1) || t$1 < 0) throw new Error(`Unpexpected numItems value: ${t$1}.`);
					this.numItems = +t$1, this.nodeSize = Math.min(Math.max(+e$1, 2), 65535), this.ArrayType = r$1, this.IndexArrayType = t$1 < 65536 ? Uint16Array : Uint32Array;
					const i$1 = gp.indexOf(this.ArrayType), s$1 = 2 * t$1 * this.ArrayType.BYTES_PER_ELEMENT, a$1 = t$1 * this.IndexArrayType.BYTES_PER_ELEMENT, o$1 = (8 - a$1 % 8) % 8;
					if (i$1 < 0) throw new Error(`Unexpected typed array class: ${r$1}.`);
					n$1 && n$1 instanceof ArrayBuffer ? (this.data = n$1, this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a$1 + o$1, 2 * t$1), this._pos = 2 * t$1, this._finished = !0) : (this.data = new ArrayBuffer(8 + s$1 + a$1 + o$1), this.ids = new this.IndexArrayType(this.data, 8, t$1), this.coords = new this.ArrayType(this.data, 8 + a$1 + o$1, 2 * t$1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i$1]), new Uint16Array(this.data, 2, 1)[0] = e$1, new Uint32Array(this.data, 4, 1)[0] = t$1);
				}
				add(t$1, e$1) {
					const r$1 = this._pos >> 1;
					return this.ids[r$1] = r$1, this.coords[this._pos++] = t$1, this.coords[this._pos++] = e$1, r$1;
				}
				finish() {
					const t$1 = this._pos >> 1;
					if (t$1 !== this.numItems) throw new Error(`Added ${t$1} items when expected ${this.numItems}.`);
					return vp(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(t$1, e$1, r$1, n$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: i$1, coords: s$1, nodeSize: a$1 } = this, o$1 = [
						0,
						i$1.length - 1,
						0
					], l$1 = [];
					for (; o$1.length;) {
						const u$1 = o$1.pop() || 0, c$1 = o$1.pop() || 0, h$1 = o$1.pop() || 0;
						if (c$1 - h$1 <= a$1) {
							for (let a$2 = h$1; a$2 <= c$1; a$2++) {
								const o$2 = s$1[2 * a$2], u$2 = s$1[2 * a$2 + 1];
								o$2 >= t$1 && o$2 <= r$1 && u$2 >= e$1 && u$2 <= n$1 && l$1.push(i$1[a$2]);
							}
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = s$1[2 * p$1], d$1 = s$1[2 * p$1 + 1];
						f$1 >= t$1 && f$1 <= r$1 && d$1 >= e$1 && d$1 <= n$1 && l$1.push(i$1[p$1]), (0 === u$1 ? t$1 <= f$1 : e$1 <= d$1) && (o$1.push(h$1), o$1.push(p$1 - 1), o$1.push(1 - u$1)), (0 === u$1 ? r$1 >= f$1 : n$1 >= d$1) && (o$1.push(p$1 + 1), o$1.push(c$1), o$1.push(1 - u$1));
					}
					return l$1;
				}
				within(t$1, e$1, r$1) {
					if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
					const { ids: n$1, coords: i$1, nodeSize: s$1 } = this, a$1 = [
						0,
						n$1.length - 1,
						0
					], o$1 = [], l$1 = r$1 * r$1;
					for (; a$1.length;) {
						const u$1 = a$1.pop() || 0, c$1 = a$1.pop() || 0, h$1 = a$1.pop() || 0;
						if (c$1 - h$1 <= s$1) {
							for (let r$2 = h$1; r$2 <= c$1; r$2++) Sp(i$1[2 * r$2], i$1[2 * r$2 + 1], t$1, e$1) <= l$1 && o$1.push(n$1[r$2]);
							continue;
						}
						const p$1 = h$1 + c$1 >> 1, f$1 = i$1[2 * p$1], d$1 = i$1[2 * p$1 + 1];
						Sp(f$1, d$1, t$1, e$1) <= l$1 && o$1.push(n$1[p$1]), (0 === u$1 ? t$1 - r$1 <= f$1 : e$1 - r$1 <= d$1) && (a$1.push(h$1), a$1.push(p$1 - 1), a$1.push(1 - u$1)), (0 === u$1 ? t$1 + r$1 >= f$1 : e$1 + r$1 >= d$1) && (a$1.push(p$1 + 1), a$1.push(c$1), a$1.push(1 - u$1));
					}
					return o$1;
				}
			}
			function vp(t$1, e$1, r$1, n$1, i$1, s$1) {
				if (i$1 - n$1 <= r$1) return;
				const a$1 = n$1 + i$1 >> 1;
				bp(t$1, e$1, a$1, n$1, i$1, s$1), vp(t$1, e$1, r$1, n$1, a$1 - 1, 1 - s$1), vp(t$1, e$1, r$1, a$1 + 1, i$1, 1 - s$1);
			}
			function bp(t$1, e$1, r$1, n$1, i$1, s$1) {
				for (; i$1 > n$1;) {
					if (i$1 - n$1 > 600) {
						const a$2 = i$1 - n$1 + 1, o$2 = r$1 - n$1 + 1, l$2 = Math.log(a$2), u$1 = .5 * Math.exp(2 * l$2 / 3), c$1 = .5 * Math.sqrt(l$2 * u$1 * (a$2 - u$1) / a$2) * (o$2 - a$2 / 2 < 0 ? -1 : 1);
						bp(t$1, e$1, r$1, Math.max(n$1, Math.floor(r$1 - o$2 * u$1 / a$2 + c$1)), Math.min(i$1, Math.floor(r$1 + (a$2 - o$2) * u$1 / a$2 + c$1)), s$1);
					}
					const a$1 = e$1[2 * r$1 + s$1];
					let o$1 = n$1, l$1 = i$1;
					for (wp(t$1, e$1, n$1, r$1), e$1[2 * i$1 + s$1] > a$1 && wp(t$1, e$1, n$1, i$1); o$1 < l$1;) {
						for (wp(t$1, e$1, o$1, l$1), o$1++, l$1--; e$1[2 * o$1 + s$1] < a$1;) o$1++;
						for (; e$1[2 * l$1 + s$1] > a$1;) l$1--;
					}
					e$1[2 * n$1 + s$1] === a$1 ? wp(t$1, e$1, n$1, l$1) : (l$1++, wp(t$1, e$1, l$1, i$1)), l$1 <= r$1 && (n$1 = l$1 + 1), r$1 <= l$1 && (i$1 = l$1 - 1);
				}
			}
			function wp(t$1, e$1, r$1, n$1) {
				_p(t$1, r$1, n$1), _p(e$1, 2 * r$1, 2 * n$1), _p(e$1, 2 * r$1 + 1, 2 * n$1 + 1);
			}
			function _p(t$1, e$1, r$1) {
				const n$1 = t$1[e$1];
				t$1[e$1] = t$1[r$1], t$1[r$1] = n$1;
			}
			function Sp(t$1, e$1, r$1, n$1) {
				const i$1 = t$1 - r$1, s$1 = e$1 - n$1;
				return i$1 * i$1 + s$1 * s$1;
			}
			var Ap;
			t.cx = void 0, (Ap = t.cx || (t.cx = {})).create = "create", Ap.load = "load", Ap.fullLoad = "fullLoad";
			let kp = null, Mp = [];
			const Ip = 1e3 / 60, zp = "loadTime", Pp = "fullLoadTime";
			t.$ = P, t.A = f, t.B = function([t$1, e$1, r$1]) {
				return e$1 += 90, e$1 *= Math.PI / 180, r$1 *= Math.PI / 180, {
					x: t$1 * Math.cos(e$1) * Math.sin(r$1),
					y: t$1 * Math.sin(e$1) * Math.sin(r$1),
					z: t$1 * Math.cos(r$1)
				};
			}, t.C = dr, t.D = Ls, t.E = gt, t.F = zs, t.G = es, t.H = function(t$1) {
				if (null == Z) {
					const e$1 = t$1.navigator ? t$1.navigator.userAgent : null;
					Z = !!t$1.safari || !(!e$1 || !(/\b(iPad|iPhone|iPod)\b/.test(e$1) || e$1.match("Safari") && !e$1.match("Chrome")));
				}
				return Z;
			}, t.I = kc, t.J = class {
				constructor(t$1, e$1) {
					this.target = t$1, this.mapId = e$1, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new vh((() => this.process())), this.subscription = Q(this.target, "message", ((t$2) => this.receive(t$2)), !1), this.globalScope = X(self) ? t$1 : window;
				}
				registerMessageHandler(t$1, e$1) {
					this.messageHandlers[t$1] = e$1;
				}
				sendAsync(t$1, e$1) {
					return new Promise(((r$1, n$1) => {
						const i$1 = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10), s$1 = e$1 ? Q(e$1.signal, "abort", (() => {
							s$1?.unsubscribe(), delete this.resolveRejects[i$1];
							const e$2 = {
								id: i$1,
								type: "<cancel>",
								origin: location.origin,
								targetMapId: t$1.targetMapId,
								sourceMapId: this.mapId
							};
							this.target.postMessage(e$2);
						}), bh) : null;
						this.resolveRejects[i$1] = {
							resolve: (t$2) => {
								s$1?.unsubscribe(), r$1(t$2);
							},
							reject: (t$2) => {
								s$1?.unsubscribe(), n$1(t$2);
							}
						};
						const a$1 = [], o$1 = Object.assign(Object.assign({}, t$1), {
							id: i$1,
							sourceMapId: this.mapId,
							origin: location.origin,
							data: hs(t$1.data, a$1)
						});
						this.target.postMessage(o$1, { transfer: a$1 });
					}));
				}
				receive(t$1) {
					const e$1 = t$1.data, r$1 = e$1.id;
					if (!("file://" !== e$1.origin && "file://" !== location.origin && "resource://android" !== e$1.origin && "resource://android" !== location.origin && e$1.origin !== location.origin || e$1.targetMapId && this.mapId !== e$1.targetMapId)) {
						if ("<cancel>" === e$1.type) {
							delete this.tasks[r$1];
							const t$2 = this.abortControllers[r$1];
							delete this.abortControllers[r$1], t$2 && t$2.abort();
							return;
						}
						if (X(self) || e$1.mustQueue) return this.tasks[r$1] = e$1, this.taskQueue.push(r$1), void this.invoker.trigger();
						this.processTask(r$1, e$1);
					}
				}
				process() {
					if (0 === this.taskQueue.length) return;
					const t$1 = this.taskQueue.shift(), e$1 = this.tasks[t$1];
					delete this.tasks[t$1], this.taskQueue.length > 0 && this.invoker.trigger(), e$1 && this.processTask(t$1, e$1);
				}
				processTask(t$1, r$1) {
					return e(this, void 0, void 0, (function* () {
						if ("<response>" === r$1.type) {
							const e$2 = this.resolveRejects[t$1];
							if (delete this.resolveRejects[t$1], !e$2) return;
							r$1.error ? e$2.reject(ps(r$1.error)) : e$2.resolve(ps(r$1.data));
							return;
						}
						if (!this.messageHandlers[r$1.type]) return void this.completeTask(t$1, /* @__PURE__ */ new Error(`Could not find a registered handler for ${r$1.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
						const e$1 = ps(r$1.data), n$1 = new AbortController();
						this.abortControllers[t$1] = n$1;
						try {
							const i$1 = yield this.messageHandlers[r$1.type](r$1.sourceMapId, e$1, n$1);
							this.completeTask(t$1, null, i$1);
						} catch (e$2) {
							this.completeTask(t$1, e$2);
						}
					}));
				}
				completeTask(t$1, e$1, r$1) {
					const n$1 = [];
					delete this.abortControllers[t$1];
					const i$1 = {
						id: t$1,
						type: "<response>",
						sourceMapId: this.mapId,
						origin: location.origin,
						error: e$1 ? hs(e$1) : null,
						data: hs(r$1, n$1)
					};
					this.target.postMessage(i$1, { transfer: n$1 });
				}
				remove() {
					this.invoker.remove(), this.subscription.unsubscribe();
				}
			}, t.K = lt, t.L = function() {
				var t$1 = new f(16);
				return f != Float32Array && (t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0), t$1[0] = 1, t$1[5] = 1, t$1[10] = 1, t$1[15] = 1, t$1;
			}, t.M = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1, p$1, f$1, d$1, y$1 = r$1[0], m$1 = r$1[1], g$1 = r$1[2];
				return e$1 === t$1 ? (t$1[12] = e$1[0] * y$1 + e$1[4] * m$1 + e$1[8] * g$1 + e$1[12], t$1[13] = e$1[1] * y$1 + e$1[5] * m$1 + e$1[9] * g$1 + e$1[13], t$1[14] = e$1[2] * y$1 + e$1[6] * m$1 + e$1[10] * g$1 + e$1[14], t$1[15] = e$1[3] * y$1 + e$1[7] * m$1 + e$1[11] * g$1 + e$1[15]) : (i$1 = e$1[1], s$1 = e$1[2], a$1 = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], t$1[0] = n$1 = e$1[0], t$1[1] = i$1, t$1[2] = s$1, t$1[3] = a$1, t$1[4] = o$1, t$1[5] = l$1, t$1[6] = u$1, t$1[7] = c$1, t$1[8] = h$1, t$1[9] = p$1, t$1[10] = f$1, t$1[11] = d$1, t$1[12] = n$1 * y$1 + o$1 * m$1 + h$1 * g$1 + e$1[12], t$1[13] = i$1 * y$1 + l$1 * m$1 + p$1 * g$1 + e$1[13], t$1[14] = s$1 * y$1 + u$1 * m$1 + f$1 * g$1 + e$1[14], t$1[15] = a$1 * y$1 + c$1 * m$1 + d$1 * g$1 + e$1[15]), t$1;
			}, t.N = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2];
				return t$1[0] = e$1[0] * n$1, t$1[1] = e$1[1] * n$1, t$1[2] = e$1[2] * n$1, t$1[3] = e$1[3] * n$1, t$1[4] = e$1[4] * i$1, t$1[5] = e$1[5] * i$1, t$1[6] = e$1[6] * i$1, t$1[7] = e$1[7] * i$1, t$1[8] = e$1[8] * s$1, t$1[9] = e$1[9] * s$1, t$1[10] = e$1[10] * s$1, t$1[11] = e$1[11] * s$1, t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.O = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a$1 = e$1[3], o$1 = e$1[4], l$1 = e$1[5], u$1 = e$1[6], c$1 = e$1[7], h$1 = e$1[8], p$1 = e$1[9], f$1 = e$1[10], d$1 = e$1[11], y$1 = e$1[12], m$1 = e$1[13], g$1 = e$1[14], x$1 = e$1[15], v$1 = r$1[0], b$1 = r$1[1], w$1 = r$1[2], _$1 = r$1[3];
				return t$1[0] = v$1 * n$1 + b$1 * o$1 + w$1 * h$1 + _$1 * y$1, t$1[1] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[2] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[3] = v$1 * a$1 + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[4] = (v$1 = r$1[4]) * n$1 + (b$1 = r$1[5]) * o$1 + (w$1 = r$1[6]) * h$1 + (_$1 = r$1[7]) * y$1, t$1[5] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[6] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[7] = v$1 * a$1 + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[8] = (v$1 = r$1[8]) * n$1 + (b$1 = r$1[9]) * o$1 + (w$1 = r$1[10]) * h$1 + (_$1 = r$1[11]) * y$1, t$1[9] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[10] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[11] = v$1 * a$1 + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1[12] = (v$1 = r$1[12]) * n$1 + (b$1 = r$1[13]) * o$1 + (w$1 = r$1[14]) * h$1 + (_$1 = r$1[15]) * y$1, t$1[13] = v$1 * i$1 + b$1 * l$1 + w$1 * p$1 + _$1 * m$1, t$1[14] = v$1 * s$1 + b$1 * u$1 + w$1 * f$1 + _$1 * g$1, t$1[15] = v$1 * a$1 + b$1 * c$1 + w$1 * d$1 + _$1 * x$1, t$1;
			}, t.P = r, t.Q = function(t$1, e$1) {
				const r$1 = {};
				for (let n$1 = 0; n$1 < e$1.length; n$1++) {
					const i$1 = e$1[n$1];
					i$1 in t$1 && (r$1[i$1] = t$1[i$1]);
				}
				return r$1;
			}, t.R = dl, t.S = _h, t.T = Sl, t.U = Mh, t.V = kh, t.W = c, t.X = h, t.Y = K, t.Z = Vh, t._ = e, t.a = at, t.a$ = S, t.a0 = function(t$1, e$1) {
				var r$1, n$1, i$1, s$1, a$1;
				if (!t$1) return null != e$1 ? e$1 : {};
				if (!e$1) return t$1;
				let o$1 = Object.assign({}, t$1);
				if (e$1.removeAll && (o$1 = { removeAll: !0 }), e$1.remove) {
					const n$2 = new Set(e$1.remove);
					o$1.add && (o$1.add = o$1.add.filter(((t$2) => !n$2.has(t$2.id)))), o$1.update && (o$1.update = o$1.update.filter(((t$2) => !n$2.has(t$2.id))));
					const i$2 = new Set((null !== (r$1 = t$1.add) && void 0 !== r$1 ? r$1 : []).map(((t$2) => t$2.id)));
					e$1.remove = e$1.remove.filter(((t$2) => !i$2.has(t$2)));
				}
				if (e$1.remove) {
					const t$2 = new Set(o$1.remove ? o$1.remove.concat(e$1.remove) : e$1.remove);
					o$1.remove = Array.from(t$2.values());
				}
				if (e$1.add) {
					const t$2 = o$1.add ? o$1.add.concat(e$1.add) : e$1.add, r$2 = new Map(t$2.map(((t$3) => [t$3.id, t$3])));
					o$1.add = Array.from(r$2.values());
				}
				if (e$1.update) {
					const t$2 = new Map(null === (n$1 = o$1.update) || void 0 === n$1 ? void 0 : n$1.map(((t$3) => [t$3.id, t$3])));
					for (const r$2 of e$1.update) {
						const e$2 = null !== (i$1 = t$2.get(r$2.id)) && void 0 !== i$1 ? i$1 : { id: r$2.id };
						r$2.newGeometry && (e$2.newGeometry = r$2.newGeometry), r$2.addOrUpdateProperties && (e$2.addOrUpdateProperties = (null !== (s$1 = e$2.addOrUpdateProperties) && void 0 !== s$1 ? s$1 : []).concat(r$2.addOrUpdateProperties)), r$2.removeProperties && (e$2.removeProperties = (null !== (a$1 = e$2.removeProperties) && void 0 !== a$1 ? a$1 : []).concat(r$2.removeProperties)), r$2.removeAllProperties && (e$2.removeAllProperties = !0), t$2.set(r$2.id, e$2);
					}
					o$1.update = Array.from(t$2.values());
				}
				return o$1.remove && o$1.add && (o$1.remove = o$1.remove.filter(((t$2) => -1 === o$1.add.findIndex(((e$2) => e$2.id === t$2))))), o$1;
			}, t.a1 = Ch, t.a2 = $h, t.a3 = 25, t.a4 = Th, t.a5 = (t$1) => {
				const e$1 = window.document.createElement("video");
				return e$1.muted = !0, new Promise(((r$1) => {
					e$1.onloadstart = () => {
						r$1(e$1);
					};
					for (const r$2 of t$1) {
						const t$2 = window.document.createElement("source");
						pt(r$2) || (e$1.crossOrigin = "Anonymous"), t$2.src = r$2, e$1.appendChild(t$2);
					}
				}));
			}, t.a6 = Ct, t.a7 = function() {
				return O++;
			}, t.a8 = _a, t.a9 = ah, t.aA = function(t$1) {
				let e$1 = Infinity, r$1 = Infinity, n$1 = -Infinity, i$1 = -Infinity;
				for (const s$1 of t$1) e$1 = Math.min(e$1, s$1.x), r$1 = Math.min(r$1, s$1.y), n$1 = Math.max(n$1, s$1.x), i$1 = Math.max(i$1, s$1.y);
				return [
					e$1,
					r$1,
					n$1,
					i$1
				];
			}, t.aB = sc, t.aC = C, t.aD = function(t$1, e$1, r$1, n$1, i$1 = !1) {
				if (!r$1[0] && !r$1[1]) return [0, 0];
				const s$1 = i$1 ? "map" === n$1 ? -t$1.bearingInRadians : 0 : "viewport" === n$1 ? t$1.bearingInRadians : 0;
				if (s$1) {
					const t$2 = Math.sin(s$1), e$2 = Math.cos(s$1);
					r$1 = [r$1[0] * e$2 - r$1[1] * t$2, r$1[0] * t$2 + r$1[1] * e$2];
				}
				return [i$1 ? r$1[0] : C(e$1, r$1[0], t$1.zoom), i$1 ? r$1[1] : C(e$1, r$1[1], t$1.zoom)];
			}, t.aF = Qc, t.aG = pp, t.aH = Rc, t.aI = xp, t.aJ = Hs, t.aK = nu, t.aL = Ba, t.aM = Ka, t.aN = Xa, t.aO = $, t.aP = et, t.aQ = Ph, t.aR = b, t.aS = v, t.aT = function(t$1) {
				var e$1 = new f(3);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1;
			}, t.aU = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] - r$1[0], t$1[1] = e$1[1] - r$1[1], t$1[2] = e$1[2] - r$1[2], t$1;
			}, t.aV = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = r$1 * r$1 + n$1 * n$1 + i$1 * i$1;
				return s$1 > 0 && (s$1 = 1 / Math.sqrt(s$1)), t$1[0] = e$1[0] * s$1, t$1[1] = e$1[1] * s$1, t$1[2] = e$1[2] * s$1, t$1;
			}, t.aW = w, t.aX = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2];
			}, t.aY = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1[0], t$1[1] = e$1[1] * r$1[1], t$1[2] = e$1[2] * r$1[2], t$1[3] = e$1[3] * r$1[3], t$1;
			}, t.aZ = g, t.a_ = function(t$1, e$1, r$1) {
				const n$1 = e$1[0] * r$1[0] + e$1[1] * r$1[1] + e$1[2] * r$1[2];
				return 0 === n$1 ? null : (-(t$1[0] * r$1[0] + t$1[1] * r$1[1] + t$1[2] * r$1[2]) - r$1[3]) / n$1;
			}, t.aa = pi, t.ab = Bo, t.ac = Oh, t.ad = function(t$1) {
				const e$1 = {};
				if (t$1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t$2, r$1, n$1, i$1) => {
					const s$1 = n$1 || i$1;
					return e$1[r$1] = !s$1 || s$1.toLowerCase(), "";
				})), e$1["max-age"]) {
					const t$2 = parseInt(e$1["max-age"], 10);
					isNaN(t$2) ? delete e$1["max-age"] : e$1["max-age"] = t$2;
				}
				return e$1;
			}, t.ae = tt, t.af = function(t$1) {
				return Math.pow(2, t$1);
			}, t.ag = y, t.ah = D, t.ai = 85.051129, t.aj = Ih, t.ak = function(t$1) {
				return Math.log(t$1) / Math.LN2;
			}, t.al = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return e$1 * e$1 + r$1 * r$1;
			}, t.am = function(t$1, e$1) {
				const r$1 = [];
				for (const n$1 in t$1) n$1 in e$1 || r$1.push(n$1);
				return r$1;
			}, t.an = function(t$1, e$1) {
				let r$1 = 0, n$1 = 0;
				if ("constant" === t$1.kind) n$1 = t$1.layoutSize;
				else if ("source" !== t$1.kind) {
					const { interpolationType: i$1, minZoom: s$1, maxZoom: a$1 } = t$1, o$1 = i$1 ? D(pr.interpolationFactor(i$1, e$1, s$1, a$1), 0, 1) : 0;
					"camera" === t$1.kind ? n$1 = dr.number(t$1.minSize, t$1.maxSize, o$1) : r$1 = o$1;
				}
				return {
					uSizeT: r$1,
					uSize: n$1
				};
			}, t.ap = function(t$1, { uSize: e$1, uSizeT: r$1 }, { lowerSize: n$1, upperSize: i$1 }) {
				return "source" === t$1.kind ? n$1 / Kc : "composite" === t$1.kind ? dr.number(n$1 / Kc, i$1 / Kc, r$1) : e$1;
			}, t.aq = function(t$1, e$1) {
				var r$1 = e$1[0], n$1 = e$1[1], i$1 = e$1[2], s$1 = e$1[3], a$1 = e$1[4], o$1 = e$1[5], l$1 = e$1[6], u$1 = e$1[7], c$1 = e$1[8], h$1 = e$1[9], p$1 = e$1[10], f$1 = e$1[11], d$1 = e$1[12], y$1 = e$1[13], m$1 = e$1[14], g$1 = e$1[15], x$1 = r$1 * o$1 - n$1 * a$1, v$1 = r$1 * l$1 - i$1 * a$1, b$1 = r$1 * u$1 - s$1 * a$1, w$1 = n$1 * l$1 - i$1 * o$1, _$1 = n$1 * u$1 - s$1 * o$1, S$1 = i$1 * u$1 - s$1 * l$1, A$1 = c$1 * y$1 - h$1 * d$1, k$1 = c$1 * m$1 - p$1 * d$1, M$1 = c$1 * g$1 - f$1 * d$1, I$1 = h$1 * m$1 - p$1 * y$1, z$1 = h$1 * g$1 - f$1 * y$1, P$1 = p$1 * g$1 - f$1 * m$1, C$1 = x$1 * P$1 - v$1 * z$1 + b$1 * I$1 + w$1 * M$1 - _$1 * k$1 + S$1 * A$1;
				return C$1 ? (t$1[0] = (o$1 * P$1 - l$1 * z$1 + u$1 * I$1) * (C$1 = 1 / C$1), t$1[1] = (i$1 * z$1 - n$1 * P$1 - s$1 * I$1) * C$1, t$1[2] = (y$1 * S$1 - m$1 * _$1 + g$1 * w$1) * C$1, t$1[3] = (p$1 * _$1 - h$1 * S$1 - f$1 * w$1) * C$1, t$1[4] = (l$1 * M$1 - a$1 * P$1 - u$1 * k$1) * C$1, t$1[5] = (r$1 * P$1 - i$1 * M$1 + s$1 * k$1) * C$1, t$1[6] = (m$1 * b$1 - d$1 * S$1 - g$1 * v$1) * C$1, t$1[7] = (c$1 * S$1 - p$1 * b$1 + f$1 * v$1) * C$1, t$1[8] = (a$1 * z$1 - o$1 * M$1 + u$1 * A$1) * C$1, t$1[9] = (n$1 * M$1 - r$1 * z$1 - s$1 * A$1) * C$1, t$1[10] = (d$1 * _$1 - y$1 * b$1 + g$1 * x$1) * C$1, t$1[11] = (h$1 * b$1 - c$1 * _$1 - f$1 * x$1) * C$1, t$1[12] = (o$1 * k$1 - a$1 * I$1 - l$1 * A$1) * C$1, t$1[13] = (r$1 * I$1 - n$1 * k$1 + i$1 * A$1) * C$1, t$1[14] = (y$1 * v$1 - d$1 * w$1 - m$1 * x$1) * C$1, t$1[15] = (c$1 * w$1 - h$1 * v$1 + p$1 * x$1) * C$1, t$1) : null;
			}, t.ar = I, t.as = function(t$1) {
				var e$1 = t$1[0], r$1 = t$1[1];
				return Math.sqrt(e$1 * e$1 + r$1 * r$1);
			}, t.at = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1;
			}, t.au = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1;
			}, t.av = rh, t.aw = A, t.ax = function(t$1, e$1, n$1, i$1) {
				const s$1 = e$1.y - t$1.y, a$1 = e$1.x - t$1.x, o$1 = i$1.y - n$1.y, l$1 = i$1.x - n$1.x, u$1 = o$1 * a$1 - l$1 * s$1;
				if (0 === u$1) return null;
				const c$1 = (l$1 * (t$1.y - n$1.y) - o$1 * (t$1.x - n$1.x)) / u$1;
				return new r(t$1.x + c$1 * a$1, t$1.y + c$1 * s$1);
			}, t.ay = Nh, t.az = $o, t.b = Y, t.b$ = class extends ca {}, t.b0 = function(t$1, e$1, r$1) {
				return t$1[0] = e$1[0] * r$1, t$1[1] = e$1[1] * r$1, t$1[2] = e$1[2] * r$1, t$1[3] = e$1[3] * r$1, t$1;
			}, t.b1 = function(t$1, e$1) {
				return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3];
			}, t.b2 = Bh, t.b3 = Fh, t.b4 = function(t$1, e$1, r$1, n$1, i$1) {
				var s$1 = 1 / Math.tan(e$1 / 2);
				if (t$1[0] = s$1 / r$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = s$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[11] = -1, t$1[12] = 0, t$1[13] = 0, t$1[15] = 0, null != i$1 && i$1 !== Infinity) {
					var a$1 = 1 / (n$1 - i$1);
					t$1[10] = (i$1 + n$1) * a$1, t$1[14] = 2 * i$1 * n$1 * a$1;
				} else t$1[10] = -1, t$1[14] = -2 * n$1;
				return t$1;
			}, t.b5 = function(t$1) {
				var e$1 = new f(16);
				return e$1[0] = t$1[0], e$1[1] = t$1[1], e$1[2] = t$1[2], e$1[3] = t$1[3], e$1[4] = t$1[4], e$1[5] = t$1[5], e$1[6] = t$1[6], e$1[7] = t$1[7], e$1[8] = t$1[8], e$1[9] = t$1[9], e$1[10] = t$1[10], e$1[11] = t$1[11], e$1[12] = t$1[12], e$1[13] = t$1[13], e$1[14] = t$1[14], e$1[15] = t$1[15], e$1;
			}, t.b6 = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a$1 = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[4], c$1 = e$1[5], h$1 = e$1[6], p$1 = e$1[7];
				return e$1 !== t$1 && (t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 + u$1 * n$1, t$1[1] = a$1 * i$1 + c$1 * n$1, t$1[2] = o$1 * i$1 + h$1 * n$1, t$1[3] = l$1 * i$1 + p$1 * n$1, t$1[4] = u$1 * i$1 - s$1 * n$1, t$1[5] = c$1 * i$1 - a$1 * n$1, t$1[6] = h$1 * i$1 - o$1 * n$1, t$1[7] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.b7 = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[4], a$1 = e$1[5], o$1 = e$1[6], l$1 = e$1[7], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[4] = s$1 * i$1 + u$1 * n$1, t$1[5] = a$1 * i$1 + c$1 * n$1, t$1[6] = o$1 * i$1 + h$1 * n$1, t$1[7] = l$1 * i$1 + p$1 * n$1, t$1[8] = u$1 * i$1 - s$1 * n$1, t$1[9] = c$1 * i$1 - a$1 * n$1, t$1[10] = h$1 * i$1 - o$1 * n$1, t$1[11] = p$1 * i$1 - l$1 * n$1, t$1;
			}, t.b8 = function() {
				const t$1 = new Float32Array(16);
				return y(t$1), t$1;
			}, t.b9 = function() {
				const t$1 = new Float64Array(16);
				return y(t$1), t$1;
			}, t.bA = function(t$1, e$1) {
				const r$1 = E(t$1, 360), n$1 = E(e$1, 360), i$1 = n$1 - r$1, s$1 = n$1 > r$1 ? i$1 - 360 : i$1 + 360;
				return Math.abs(i$1) < Math.abs(s$1) ? i$1 : s$1;
			}, t.bB = function(t$1) {
				return t$1[0] = 0, t$1[1] = 0, t$1[2] = 0, t$1;
			}, t.bC = function(t$1, e$1, r$1, n$1) {
				const i$1 = Math.sqrt(t$1 * t$1 + e$1 * e$1), s$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1);
				t$1 /= i$1, e$1 /= i$1, r$1 /= s$1, n$1 /= s$1;
				const a$1 = Math.acos(t$1 * r$1 + e$1 * n$1);
				return -e$1 * r$1 + t$1 * n$1 > 0 ? a$1 : -a$1;
			}, t.bD = function(t$1, e$1) {
				const r$1 = E(t$1, 2 * Math.PI), n$1 = E(e$1, 2 * Math.PI);
				return Math.min(Math.abs(r$1 - n$1), Math.abs(r$1 - n$1 + 2 * Math.PI), Math.abs(r$1 - n$1 - 2 * Math.PI));
			}, t.bE = function() {
				const t$1 = {}, e$1 = xt.$version;
				for (const r$1 in xt.$root) {
					const n$1 = xt.$root[r$1];
					if (n$1.required) {
						let i$1 = null;
						i$1 = "version" === r$1 ? e$1 : "array" === n$1.type ? [] : {}, null != i$1 && (t$1[r$1] = i$1);
					}
				}
				return t$1;
			}, t.bF = fs, t.bG = ct, t.bH = function t$1(e$1, r$1) {
				if (Array.isArray(e$1)) {
					if (!Array.isArray(r$1) || e$1.length !== r$1.length) return !1;
					for (let n$1 = 0; n$1 < e$1.length; n$1++) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				if ("object" == typeof e$1 && null !== e$1 && null !== r$1) {
					if ("object" != typeof r$1) return !1;
					if (Object.keys(e$1).length !== Object.keys(r$1).length) return !1;
					for (const n$1 in e$1) if (!t$1(e$1[n$1], r$1[n$1])) return !1;
					return !0;
				}
				return e$1 === r$1;
			}, t.bI = function(t$1) {
				t$1 = t$1.slice();
				const e$1 = Object.create(null);
				for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[t$1[r$1].id] = t$1[r$1];
				for (let r$1 = 0; r$1 < t$1.length; r$1++) "ref" in t$1[r$1] && (t$1[r$1] = bt(t$1[r$1], e$1[t$1[r$1].ref]));
				return t$1;
			}, t.bJ = function(t$1, e$1) {
				if ("custom" === t$1.type) return new xh(t$1, e$1);
				switch (t$1.type) {
					case "background": return new dh(t$1, e$1);
					case "circle": return new al(t$1, e$1);
					case "color-relief": return new Ml(t$1, e$1);
					case "fill": return new mu(t$1, e$1);
					case "fill-extrusion": return new Fu(t$1, e$1);
					case "heatmap": return new gl(t$1, e$1);
					case "hillshade": return new bl(t$1, e$1);
					case "line": return new Ku(t$1, e$1);
					case "raster": return new gh(t$1, e$1);
					case "symbol": return new hh(t$1, e$1);
				}
			}, t.bK = j, t.bL = function(t$1, e$1) {
				if (!t$1) return [{
					command: "setStyle",
					args: [e$1]
				}];
				let r$1 = [];
				try {
					if (!wt(t$1.version, e$1.version)) return [{
						command: "setStyle",
						args: [e$1]
					}];
					wt(t$1.center, e$1.center) || r$1.push({
						command: "setCenter",
						args: [e$1.center]
					}), wt(t$1.state, e$1.state) || r$1.push({
						command: "setGlobalState",
						args: [e$1.state]
					}), wt(t$1.centerAltitude, e$1.centerAltitude) || r$1.push({
						command: "setCenterAltitude",
						args: [e$1.centerAltitude]
					}), wt(t$1.zoom, e$1.zoom) || r$1.push({
						command: "setZoom",
						args: [e$1.zoom]
					}), wt(t$1.bearing, e$1.bearing) || r$1.push({
						command: "setBearing",
						args: [e$1.bearing]
					}), wt(t$1.pitch, e$1.pitch) || r$1.push({
						command: "setPitch",
						args: [e$1.pitch]
					}), wt(t$1.roll, e$1.roll) || r$1.push({
						command: "setRoll",
						args: [e$1.roll]
					}), wt(t$1.sprite, e$1.sprite) || r$1.push({
						command: "setSprite",
						args: [e$1.sprite]
					}), wt(t$1.glyphs, e$1.glyphs) || r$1.push({
						command: "setGlyphs",
						args: [e$1.glyphs]
					}), wt(t$1.transition, e$1.transition) || r$1.push({
						command: "setTransition",
						args: [e$1.transition]
					}), wt(t$1.light, e$1.light) || r$1.push({
						command: "setLight",
						args: [e$1.light]
					}), wt(t$1.terrain, e$1.terrain) || r$1.push({
						command: "setTerrain",
						args: [e$1.terrain]
					}), wt(t$1.sky, e$1.sky) || r$1.push({
						command: "setSky",
						args: [e$1.sky]
					}), wt(t$1.projection, e$1.projection) || r$1.push({
						command: "setProjection",
						args: [e$1.projection]
					});
					const n$1 = {}, i$1 = [];
					(function(t$2, e$2, r$2, n$2) {
						let i$2;
						for (i$2 in e$2 = e$2 || {}, t$2 = t$2 || {}) Object.prototype.hasOwnProperty.call(t$2, i$2) && (Object.prototype.hasOwnProperty.call(e$2, i$2) || At(i$2, r$2, n$2));
						for (i$2 in e$2) Object.prototype.hasOwnProperty.call(e$2, i$2) && (Object.prototype.hasOwnProperty.call(t$2, i$2) ? wt(t$2[i$2], e$2[i$2]) || ("geojson" === t$2[i$2].type && "geojson" === e$2[i$2].type && Mt(t$2, e$2, i$2) ? _t(r$2, {
							command: "setGeoJSONSourceData",
							args: [i$2, e$2[i$2].data]
						}) : kt(i$2, e$2, r$2, n$2)) : St(i$2, e$2, r$2));
					})(t$1.sources, e$1.sources, i$1, n$1);
					const s$1 = [];
					t$1.layers && t$1.layers.forEach(((t$2) => {
						"source" in t$2 && n$1[t$2.source] ? r$1.push({
							command: "removeLayer",
							args: [t$2.id]
						}) : s$1.push(t$2);
					})), r$1 = r$1.concat(i$1), function(t$2, e$2, r$2) {
						e$2 = e$2 || [];
						const n$2 = (t$2 = t$2 || []).map(zt), i$2 = e$2.map(zt), s$2 = t$2.reduce(Pt, {}), a$1 = e$2.reduce(Pt, {}), o$1 = n$2.slice(), l$1 = Object.create(null);
						let u$1, c$1, h$1, p$1, f$1;
						for (let t$3 = 0, e$3 = 0; t$3 < n$2.length; t$3++) u$1 = n$2[t$3], Object.prototype.hasOwnProperty.call(a$1, u$1) ? e$3++ : (_t(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.indexOf(u$1, e$3), 1));
						for (let t$3 = 0, e$3 = 0; t$3 < i$2.length; t$3++) u$1 = i$2[i$2.length - 1 - t$3], o$1[o$1.length - 1 - t$3] !== u$1 && (Object.prototype.hasOwnProperty.call(s$2, u$1) ? (_t(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), o$1.splice(o$1.lastIndexOf(u$1, o$1.length - e$3), 1)) : e$3++, p$1 = o$1[o$1.length - t$3], _t(r$2, {
							command: "addLayer",
							args: [a$1[u$1], p$1]
						}), o$1.splice(o$1.length - t$3, 0, u$1), l$1[u$1] = !0);
						for (let t$3 = 0; t$3 < i$2.length; t$3++) if (u$1 = i$2[t$3], c$1 = s$2[u$1], h$1 = a$1[u$1], !l$1[u$1] && !wt(c$1, h$1)) if (wt(c$1.source, h$1.source) && wt(c$1["source-layer"], h$1["source-layer"]) && wt(c$1.type, h$1.type)) {
							for (f$1 in It(c$1.layout, h$1.layout, r$2, u$1, null, "setLayoutProperty"), It(c$1.paint, h$1.paint, r$2, u$1, null, "setPaintProperty"), wt(c$1.filter, h$1.filter) || _t(r$2, {
								command: "setFilter",
								args: [u$1, h$1.filter]
							}), wt(c$1.minzoom, h$1.minzoom) && wt(c$1.maxzoom, h$1.maxzoom) || _t(r$2, {
								command: "setLayerZoomRange",
								args: [
									u$1,
									h$1.minzoom,
									h$1.maxzoom
								]
							}), c$1) Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : wt(c$1[f$1], h$1[f$1]) || _t(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
							for (f$1 in h$1) Object.prototype.hasOwnProperty.call(h$1, f$1) && !Object.prototype.hasOwnProperty.call(c$1, f$1) && "layout" !== f$1 && "paint" !== f$1 && "filter" !== f$1 && "metadata" !== f$1 && "minzoom" !== f$1 && "maxzoom" !== f$1 && (0 === f$1.indexOf("paint.") ? It(c$1[f$1], h$1[f$1], r$2, u$1, f$1.slice(6), "setPaintProperty") : wt(c$1[f$1], h$1[f$1]) || _t(r$2, {
								command: "setLayerProperty",
								args: [
									u$1,
									f$1,
									h$1[f$1]
								]
							}));
						} else _t(r$2, {
							command: "removeLayer",
							args: [u$1]
						}), p$1 = o$1[o$1.lastIndexOf(u$1) + 1], _t(r$2, {
							command: "addLayer",
							args: [h$1, p$1]
						});
					}(s$1, e$1.layers, r$1);
				} catch (t$2) {
					console.warn("Unable to compute style diff:", t$2), r$1 = [{
						command: "setStyle",
						args: [e$1]
					}];
				}
				return r$1;
			}, t.bM = function(t$1) {
				const e$1 = [], r$1 = t$1.id;
				return void 0 === r$1 && e$1.push({ message: `layers.${r$1}: missing required property "id"` }), void 0 === t$1.render && e$1.push({ message: `layers.${r$1}: missing required method "render"` }), t$1.renderingMode && "2d" !== t$1.renderingMode && "3d" !== t$1.renderingMode && e$1.push({ message: `layers.${r$1}: property "renderingMode" must be either "2d" or "3d"` }), e$1;
			}, t.bN = R, t.bO = U, t.bP = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = 0;
				}
				set(t$1) {
					this.current !== t$1 && (this.current = t$1, this.gl.uniform1i(this.location, t$1));
				}
			}, t.bQ = mo, t.bR = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = go;
				}
				set(t$1) {
					if (t$1[12] !== this.current[12] || t$1[0] !== this.current[0]) return this.current = t$1, void this.gl.uniformMatrix4fv(this.location, !1, t$1);
					for (let e$1 = 1; e$1 < 16; e$1++) if (t$1[e$1] !== this.current[e$1]) {
						this.current = t$1, this.gl.uniformMatrix4fv(this.location, !1, t$1);
						break;
					}
				}
			}, t.bS = yo, t.bT = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [
						0,
						0,
						0
					];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] && t$1[2] === this.current[2] || (this.current = t$1, this.gl.uniform3f(this.location, t$1[0], t$1[1], t$1[2]));
				}
			}, t.bU = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = [0, 0];
				}
				set(t$1) {
					t$1[0] === this.current[0] && t$1[1] === this.current[1] || (this.current = t$1, this.gl.uniform2f(this.location, t$1[0], t$1[1]));
				}
			}, t.bV = d, t.bW = function(t$1, e$1) {
				var r$1 = Math.sin(e$1), n$1 = Math.cos(e$1);
				return t$1[0] = n$1, t$1[1] = r$1, t$1[2] = 0, t$1[3] = -r$1, t$1[4] = n$1, t$1[5] = 0, t$1[6] = 0, t$1[7] = 0, t$1[8] = 1, t$1;
			}, t.bX = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2];
				return t$1[0] = n$1 * r$1[0] + i$1 * r$1[3] + s$1 * r$1[6], t$1[1] = n$1 * r$1[1] + i$1 * r$1[4] + s$1 * r$1[7], t$1[2] = n$1 * r$1[2] + i$1 * r$1[5] + s$1 * r$1[8], t$1;
			}, t.bY = function(t$1, e$1, r$1, n$1, i$1, s$1, a$1) {
				var o$1 = 1 / (e$1 - r$1), l$1 = 1 / (n$1 - i$1), u$1 = 1 / (s$1 - a$1);
				return t$1[0] = -2 * o$1, t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = -2 * l$1, t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = 2 * u$1, t$1[11] = 0, t$1[12] = (e$1 + r$1) * o$1, t$1[13] = (i$1 + n$1) * l$1, t$1[14] = (a$1 + s$1) * u$1, t$1[15] = 1, t$1;
			}, t.bZ = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(4 * t$1.length);
						for (let r$1 = 0; r$1 < t$1.length; r$1++) e$1[4 * r$1] = t$1[r$1].r, e$1[4 * r$1 + 1] = t$1[r$1].g, e$1[4 * r$1 + 2] = t$1[r$1].b, e$1[4 * r$1 + 3] = t$1[r$1].a;
						this.gl.uniform4fv(this.location, e$1);
					}
				}
			}, t.b_ = class extends po {
				constructor(t$1, e$1) {
					super(t$1, e$1), this.current = new Array();
				}
				set(t$1) {
					if (t$1 != this.current) {
						this.current = t$1;
						const e$1 = new Float32Array(t$1);
						this.gl.uniform1fv(this.location, e$1);
					}
				}
			}, t.ba = function() {
				return new Float64Array(16);
			}, t.bb = function(t$1, e$1, r$1) {
				const n$1 = new Float64Array(4);
				return M(n$1, t$1, e$1 - 90, r$1), n$1;
			}, t.bc = function(t$1, e$1, r$1, n$1) {
				var i$1, s$1, a$1, o$1, l$1, u$1 = e$1[0], c$1 = e$1[1], h$1 = e$1[2], f$1 = e$1[3], d$1 = r$1[0], y$1 = r$1[1], m$1 = r$1[2], g$1 = r$1[3];
				return (s$1 = u$1 * d$1 + c$1 * y$1 + h$1 * m$1 + f$1 * g$1) < 0 && (s$1 = -s$1, d$1 = -d$1, y$1 = -y$1, m$1 = -m$1, g$1 = -g$1), 1 - s$1 > p ? (i$1 = Math.acos(s$1), a$1 = Math.sin(i$1), o$1 = Math.sin((1 - n$1) * i$1) / a$1, l$1 = Math.sin(n$1 * i$1) / a$1) : (o$1 = 1 - n$1, l$1 = n$1), t$1[0] = o$1 * u$1 + l$1 * d$1, t$1[1] = o$1 * c$1 + l$1 * y$1, t$1[2] = o$1 * h$1 + l$1 * m$1, t$1[3] = o$1 * f$1 + l$1 * g$1, t$1;
			}, t.bd = function(t$1) {
				const e$1 = new Float64Array(9);
				var r$1, n$1, i$1, s$1, a$1, o$1, l$1, u$1, c$1, h$1 = (i$1 = (n$1 = t$1)[0]) * (l$1 = i$1 + i$1), p$1 = (s$1 = n$1[1]) * l$1, f$1, d$1 = (a$1 = n$1[2]) * l$1, y$1 = a$1 * (u$1 = s$1 + s$1), m$1, g$1 = (o$1 = n$1[3]) * l$1, x$1 = o$1 * u$1, v$1 = o$1 * (c$1 = a$1 + a$1);
				(r$1 = e$1)[0] = 1 - (f$1 = s$1 * u$1) - (m$1 = a$1 * c$1), r$1[3] = p$1 - v$1, r$1[6] = d$1 + x$1, r$1[1] = p$1 + v$1, r$1[4] = 1 - h$1 - m$1, r$1[7] = y$1 - g$1, r$1[2] = d$1 - x$1, r$1[5] = y$1 + g$1, r$1[8] = 1 - h$1 - f$1;
				const b$1 = et(-Math.asin(D(e$1[2], -1, 1)));
				let w$1, _$1;
				return Math.hypot(e$1[5], e$1[8]) < .001 ? (w$1 = 0, _$1 = -et(Math.atan2(e$1[3], e$1[4]))) : (w$1 = et(0 === e$1[5] && 0 === e$1[8] ? 0 : Math.atan2(e$1[5], e$1[8])), _$1 = et(0 === e$1[1] && 0 === e$1[0] ? 0 : Math.atan2(e$1[1], e$1[0]))), {
					roll: w$1,
					pitch: b$1 + 90,
					bearing: _$1
				};
			}, t.be = function(t$1, e$1) {
				return t$1.roll == e$1.roll && t$1.pitch == e$1.pitch && t$1.bearing == e$1.bearing;
			}, t.bf = Me, t.bg = fo, t.bh = iu, t.bi = su, t.bj = ru, t.bk = T, t.bl = B, t.bm = Le, t.bn = function(t$1, e$1, r$1, n$1, i$1) {
				return T(n$1, i$1, D((t$1 - e$1) / (r$1 - e$1), 0, 1));
			}, t.bo = E, t.bp = function() {
				return new Float64Array(3);
			}, t.bq = function(t$1, e$1, r$1, n$1) {
				return t$1[0] = e$1[0] + r$1[0] * n$1, t$1[1] = e$1[1] + r$1[1] * n$1, t$1[2] = e$1[2] + r$1[2] * n$1, t$1;
			}, t.br = M, t.bs = function(t$1, e$1, r$1) {
				var n$1 = r$1[0], i$1 = r$1[1], s$1 = r$1[2], a$1 = r$1[3], o$1 = e$1[0], l$1 = e$1[1], u$1 = e$1[2], c$1 = i$1 * u$1 - s$1 * l$1, h$1 = s$1 * o$1 - n$1 * u$1, p$1 = n$1 * l$1 - i$1 * o$1;
				return t$1[0] = o$1 + a$1 * (c$1 += c$1) + i$1 * (p$1 += p$1) - s$1 * (h$1 += h$1), t$1[1] = l$1 + a$1 * h$1 + s$1 * c$1 - n$1 * p$1, t$1[2] = u$1 + a$1 * p$1 + n$1 * h$1 - i$1 * c$1, t$1;
			}, t.bt = function(t$1, e$1, r$1) {
				const n$1 = (i$1 = [
					t$1[0],
					t$1[1],
					t$1[2],
					e$1[0],
					e$1[1],
					e$1[2],
					r$1[0],
					r$1[1],
					r$1[2]
				])[0] * ((c$1 = i$1[8]) * (a$1 = i$1[4]) - (o$1 = i$1[5]) * (u$1 = i$1[7])) + i$1[1] * (-c$1 * (s$1 = i$1[3]) + o$1 * (l$1 = i$1[6])) + i$1[2] * (u$1 * s$1 - a$1 * l$1);
				var i$1, s$1, a$1, o$1, l$1, u$1, c$1;
				if (0 === n$1) return null;
				const h$1 = w([], [
					e$1[0],
					e$1[1],
					e$1[2]
				], [
					r$1[0],
					r$1[1],
					r$1[2]
				]), p$1 = w([], [
					r$1[0],
					r$1[1],
					r$1[2]
				], [
					t$1[0],
					t$1[1],
					t$1[2]
				]), f$1 = w([], [
					t$1[0],
					t$1[1],
					t$1[2]
				], [
					e$1[0],
					e$1[1],
					e$1[2]
				]), d$1 = b([], h$1, -t$1[3]);
				return v(d$1, d$1, b([], p$1, -e$1[3])), v(d$1, d$1, b([], f$1, -r$1[3])), b(d$1, d$1, 1 / n$1), d$1;
			}, t.bu = wh, t.bv = function() {
				return new Float64Array(4);
			}, t.bw = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0] * Math.cos(n$1) - i$1[1] * Math.sin(n$1), s$1[1] = i$1[0] * Math.sin(n$1) + i$1[1] * Math.cos(n$1), s$1[2] = i$1[2], t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bx = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[0], s$1[1] = i$1[1] * Math.cos(n$1) - i$1[2] * Math.sin(n$1), s$1[2] = i$1[1] * Math.sin(n$1) + i$1[2] * Math.cos(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.by = function(t$1, e$1, r$1, n$1) {
				var i$1 = [], s$1 = [];
				return i$1[0] = e$1[0] - r$1[0], i$1[1] = e$1[1] - r$1[1], i$1[2] = e$1[2] - r$1[2], s$1[0] = i$1[2] * Math.sin(n$1) + i$1[0] * Math.cos(n$1), s$1[1] = i$1[1], s$1[2] = i$1[2] * Math.cos(n$1) - i$1[0] * Math.sin(n$1), t$1[0] = s$1[0] + r$1[0], t$1[1] = s$1[1] + r$1[1], t$1[2] = s$1[2] + r$1[2], t$1;
			}, t.bz = function(t$1, e$1, r$1) {
				var n$1 = Math.sin(r$1), i$1 = Math.cos(r$1), s$1 = e$1[0], a$1 = e$1[1], o$1 = e$1[2], l$1 = e$1[3], u$1 = e$1[8], c$1 = e$1[9], h$1 = e$1[10], p$1 = e$1[11];
				return e$1 !== t$1 && (t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15]), t$1[0] = s$1 * i$1 - u$1 * n$1, t$1[1] = a$1 * i$1 - c$1 * n$1, t$1[2] = o$1 * i$1 - h$1 * n$1, t$1[3] = l$1 * i$1 - p$1 * n$1, t$1[8] = s$1 * n$1 + u$1 * i$1, t$1[9] = a$1 * n$1 + c$1 * i$1, t$1[10] = o$1 * n$1 + h$1 * i$1, t$1[11] = l$1 * n$1 + p$1 * i$1, t$1;
			}, t.c = st, t.c0 = rc, t.c1 = class extends pa {}, t.c2 = ml, t.c3 = function(t$1) {
				return t$1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t$1) / Math.LN2));
			}, t.c4 = yl, t.c5 = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1], s$1 = e$1[2], a$1 = r$1[3] * n$1 + r$1[7] * i$1 + r$1[11] * s$1 + r$1[15];
				return t$1[0] = (r$1[0] * n$1 + r$1[4] * i$1 + r$1[8] * s$1 + r$1[12]) / (a$1 = a$1 || 1), t$1[1] = (r$1[1] * n$1 + r$1[5] * i$1 + r$1[9] * s$1 + r$1[13]) / a$1, t$1[2] = (r$1[2] * n$1 + r$1[6] * i$1 + r$1[10] * s$1 + r$1[14]) / a$1, t$1;
			}, t.c6 = class extends Qs {}, t.c7 = class extends va {}, t.c8 = function(t$1, e$1) {
				return t$1[0] === e$1[0] && t$1[1] === e$1[1] && t$1[2] === e$1[2] && t$1[3] === e$1[3] && t$1[4] === e$1[4] && t$1[5] === e$1[5] && t$1[6] === e$1[6] && t$1[7] === e$1[7] && t$1[8] === e$1[8] && t$1[9] === e$1[9] && t$1[10] === e$1[10] && t$1[11] === e$1[11] && t$1[12] === e$1[12] && t$1[13] === e$1[13] && t$1[14] === e$1[14] && t$1[15] === e$1[15];
			}, t.c9 = function(t$1, e$1) {
				var r$1 = t$1[0], n$1 = t$1[1], i$1 = t$1[2], s$1 = t$1[3], a$1 = t$1[4], o$1 = t$1[5], l$1 = t$1[6], u$1 = t$1[7], c$1 = t$1[8], h$1 = t$1[9], f$1 = t$1[10], d$1 = t$1[11], y$1 = t$1[12], m$1 = t$1[13], g$1 = t$1[14], x$1 = t$1[15], v$1 = e$1[0], b$1 = e$1[1], w$1 = e$1[2], _$1 = e$1[3], S$1 = e$1[4], A$1 = e$1[5], k$1 = e$1[6], M$1 = e$1[7], I$1 = e$1[8], z$1 = e$1[9], P$1 = e$1[10], C$1 = e$1[11], E$1 = e$1[12], T$1 = e$1[13], B$1 = e$1[14], V$1 = e$1[15];
				return Math.abs(r$1 - v$1) <= p * Math.max(1, Math.abs(r$1), Math.abs(v$1)) && Math.abs(n$1 - b$1) <= p * Math.max(1, Math.abs(n$1), Math.abs(b$1)) && Math.abs(i$1 - w$1) <= p * Math.max(1, Math.abs(i$1), Math.abs(w$1)) && Math.abs(s$1 - _$1) <= p * Math.max(1, Math.abs(s$1), Math.abs(_$1)) && Math.abs(a$1 - S$1) <= p * Math.max(1, Math.abs(a$1), Math.abs(S$1)) && Math.abs(o$1 - A$1) <= p * Math.max(1, Math.abs(o$1), Math.abs(A$1)) && Math.abs(l$1 - k$1) <= p * Math.max(1, Math.abs(l$1), Math.abs(k$1)) && Math.abs(u$1 - M$1) <= p * Math.max(1, Math.abs(u$1), Math.abs(M$1)) && Math.abs(c$1 - I$1) <= p * Math.max(1, Math.abs(c$1), Math.abs(I$1)) && Math.abs(h$1 - z$1) <= p * Math.max(1, Math.abs(h$1), Math.abs(z$1)) && Math.abs(f$1 - P$1) <= p * Math.max(1, Math.abs(f$1), Math.abs(P$1)) && Math.abs(d$1 - C$1) <= p * Math.max(1, Math.abs(d$1), Math.abs(C$1)) && Math.abs(y$1 - E$1) <= p * Math.max(1, Math.abs(y$1), Math.abs(E$1)) && Math.abs(m$1 - T$1) <= p * Math.max(1, Math.abs(m$1), Math.abs(T$1)) && Math.abs(g$1 - B$1) <= p * Math.max(1, Math.abs(g$1), Math.abs(B$1)) && Math.abs(x$1 - V$1) <= p * Math.max(1, Math.abs(x$1), Math.abs(V$1));
			}, t.cA = function(t$1, e$1) {
				at.REGISTERED_PROTOCOLS[t$1] = e$1;
			}, t.cB = function(t$1) {
				delete at.REGISTERED_PROTOCOLS[t$1];
			}, t.cC = function(t$1, e$1) {
				const r$1 = {};
				for (let n$2 = 0; n$2 < t$1.length; n$2++) {
					const i$1 = e$1 && e$1[t$1[n$2].id] || wi(t$1[n$2]);
					e$1 && (e$1[t$1[n$2].id] = i$1);
					let s$1 = r$1[i$1];
					s$1 || (s$1 = r$1[i$1] = []), s$1.push(t$1[n$2]);
				}
				const n$1 = [];
				for (const t$2 in r$1) n$1.push(r$1[t$2]);
				return n$1;
			}, t.cD = os, t.cE = Lh, t.cF = Rh, t.cG = Mc, t.cH = function(e$1) {
				e$1.bucket.createArrays(), e$1.bucket.tilePixelRatio = P / (512 * e$1.bucket.overscaling), e$1.bucket.compareText = {}, e$1.bucket.iconsNeedLinear = !1;
				const r$1 = e$1.bucket.layers[0], n$1 = r$1.layout, i$1 = r$1._unevaluatedLayout._values, s$1 = {
					layoutIconSize: i$1["icon-size"].possiblyEvaluate(new zs(e$1.bucket.zoom + 1), e$1.canonical),
					layoutTextSize: i$1["text-size"].possiblyEvaluate(new zs(e$1.bucket.zoom + 1), e$1.canonical),
					textMaxSize: i$1["text-size"].possiblyEvaluate(new zs(18))
				};
				if ("composite" === e$1.bucket.textSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.textSizeData;
					s$1.compositeTextSizes = [i$1["text-size"].possiblyEvaluate(new zs(t$1), e$1.canonical), i$1["text-size"].possiblyEvaluate(new zs(r$2), e$1.canonical)];
				}
				if ("composite" === e$1.bucket.iconSizeData.kind) {
					const { minZoom: t$1, maxZoom: r$2 } = e$1.bucket.iconSizeData;
					s$1.compositeIconSizes = [i$1["icon-size"].possiblyEvaluate(new zs(t$1), e$1.canonical), i$1["icon-size"].possiblyEvaluate(new zs(r$2), e$1.canonical)];
				}
				const a$1 = n$1.get("text-line-height") * sc, o$1 = "viewport" !== n$1.get("text-rotation-alignment") && "point" !== n$1.get("symbol-placement"), l$1 = n$1.get("text-keep-upright"), u$1 = n$1.get("text-size");
				for (const i$2 of e$1.bucket.features) {
					const c$1 = n$1.get("text-font").evaluate(i$2, {}, e$1.canonical).join(","), h$1 = u$1.evaluate(i$2, {}, e$1.canonical), p$1 = s$1.layoutTextSize.evaluate(i$2, {}, e$1.canonical), f$1 = s$1.layoutIconSize.evaluate(i$2, {}, e$1.canonical), d$1 = {
						horizontal: {},
						vertical: void 0
					}, y$1 = i$2.text;
					let m$1, g$1 = [0, 0];
					if (y$1) {
						const s$2 = y$1.toString(), u$2 = n$1.get("text-letter-spacing").evaluate(i$2, {}, e$1.canonical) * sc, f$2 = ms(s$2) ? u$2 : 0, m$2 = n$1.get("text-anchor").evaluate(i$2, {}, e$1.canonical), x$2 = hp(r$1, i$2, e$1.canonical);
						if (!x$2) {
							const t$1 = n$1.get("text-radial-offset").evaluate(i$2, {}, e$1.canonical);
							g$1 = t$1 ? cp(m$2, [t$1 * sc, up]) : n$1.get("text-offset").evaluate(i$2, {}, e$1.canonical).map(((t$2) => t$2 * sc));
						}
						let v$2 = o$1 ? "center" : n$1.get("text-justify").evaluate(i$2, {}, e$1.canonical);
						const b$1 = "point" === n$1.get("symbol-placement") ? n$1.get("text-max-width").evaluate(i$2, {}, e$1.canonical) * sc : Infinity, w$1 = () => {
							e$1.bucket.allowVerticalPlacement && ys(s$2) && (d$1.vertical = Cc(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, a$1, m$2, "left", f$2, g$1, t.ao.vertical, !0, p$1, h$1));
						};
						if (!o$1 && x$2) {
							const r$2 = /* @__PURE__ */ new Set();
							if ("auto" === v$2) for (let t$1 = 0; t$1 < x$2.values.length; t$1 += 2) r$2.add(pp(x$2.values[t$1]));
							else r$2.add(v$2);
							let n$2 = !1;
							for (const i$3 of r$2) if (!d$1.horizontal[i$3]) if (n$2) d$1.horizontal[i$3] = d$1.horizontal[0];
							else {
								const r$3 = Cc(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, a$1, "center", i$3, f$2, g$1, t.ao.horizontal, !1, p$1, h$1);
								r$3 && (d$1.horizontal[i$3] = r$3, n$2 = 1 === r$3.positionedLines.length);
							}
							w$1();
						} else {
							"auto" === v$2 && (v$2 = pp(m$2));
							const r$2 = Cc(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, a$1, m$2, v$2, f$2, g$1, t.ao.horizontal, !1, p$1, h$1);
							r$2 && (d$1.horizontal[v$2] = r$2), w$1(), ys(s$2) && o$1 && l$1 && (d$1.vertical = Cc(y$1, e$1.glyphMap, e$1.glyphPositions, e$1.imagePositions, c$1, b$1, a$1, m$2, v$2, f$2, g$1, t.ao.vertical, !1, p$1, h$1));
						}
					}
					let x$1 = !1;
					if (i$2.icon && i$2.icon.name) {
						const t$1 = e$1.imageMap[i$2.icon.name];
						t$1 && (m$1 = Zc(e$1.imagePositions[i$2.icon.name], n$1.get("icon-offset").evaluate(i$2, {}, e$1.canonical), n$1.get("icon-anchor").evaluate(i$2, {}, e$1.canonical)), x$1 = !!t$1.sdf, void 0 === e$1.bucket.sdfIcons ? e$1.bucket.sdfIcons = x$1 : e$1.bucket.sdfIcons !== x$1 && q("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t$1.pixelRatio !== e$1.bucket.pixelRatio || 0 !== n$1.get("icon-rotate").constantOr(1)) && (e$1.bucket.iconsNeedLinear = !0));
					}
					const v$1 = yp(d$1.horizontal) || d$1.vertical;
					e$1.bucket.iconsInText = !!v$1 && v$1.iconsInText, (v$1 || m$1) && fp(e$1.bucket, i$2, d$1, m$1, e$1.imageMap, s$1, p$1, f$1, g$1, x$1, e$1.canonical, e$1.subdivisionGranularity);
				}
				e$1.showCollisionBoxes && e$1.bucket.generateCollisionDebugBuffers();
			}, t.cI = pu, t.cJ = Pu, t.cK = qu, t.cL = ku, t.cM = uc, t.cN = class {
				constructor(t$1) {
					this._marks = {
						start: [t$1.url, "start"].join("#"),
						end: [t$1.url, "end"].join("#"),
						measure: t$1.url.toString()
					}, performance.mark(this._marks.start);
				}
				finish() {
					performance.mark(this._marks.end);
					let t$1 = performance.getEntriesByName(this._marks.measure);
					return 0 === t$1.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t$1 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t$1;
				}
			}, t.cO = function(t$1, r$1, n$1, i$1, s$1) {
				return e(this, void 0, void 0, (function* () {
					if (h()) try {
						return yield K(t$1, r$1, n$1, i$1, s$1);
					} catch (t$2) {}
					return function(t$2, e$1, r$2, n$2, i$2) {
						const s$2 = t$2.width, a$1 = t$2.height;
						J && W || (J = new OffscreenCanvas(s$2, a$1), W = J.getContext("2d", { willReadFrequently: !0 })), J.width = s$2, J.height = a$1, W.drawImage(t$2, 0, 0, s$2, a$1);
						const o$1 = W.getImageData(e$1, r$2, n$2, i$2);
						return W.clearRect(0, 0, s$2, a$1), o$1.data;
					}(t$1, r$1, n$1, i$1, s$1);
				}));
			}, t.cP = Al, t.cQ = n, t.cR = Su, t.cS = bu, t.cT = ri, t.cU = function(t$1, e$1) {
				const r$1 = /* @__PURE__ */ new Map();
				if (null == t$1);
				else if ("Feature" === t$1.type) r$1.set(Dh(t$1, e$1), t$1);
				else for (const n$1 of t$1.features) r$1.set(Dh(n$1, e$1), n$1);
				return r$1;
			}, t.cV = function(t$1, e$1) {
				if (null == t$1) return !0;
				if ("Feature" === t$1.type) return null != Dh(t$1, e$1);
				if ("FeatureCollection" === t$1.type) {
					const r$1 = /* @__PURE__ */ new Set();
					for (const n$1 of t$1.features) {
						const t$2 = Dh(n$1, e$1);
						if (null == t$2) return !1;
						if (r$1.has(t$2)) return !1;
						r$1.add(t$2);
					}
					return !0;
				}
				return !1;
			}, t.cW = function(t$1, e$1, r$1) {
				var n$1, i$1, s$1, a$1;
				if (e$1.removeAll && t$1.clear(), e$1.remove) for (const r$2 of e$1.remove) t$1.delete(r$2);
				if (e$1.add) for (const n$2 of e$1.add) {
					const e$2 = Dh(n$2, r$1);
					null != e$2 && t$1.set(e$2, n$2);
				}
				if (e$1.update) for (const r$2 of e$1.update) {
					let e$2 = t$1.get(r$2.id);
					if (null == e$2) continue;
					const o$1 = !r$2.removeAllProperties && ((null === (n$1 = r$2.removeProperties) || void 0 === n$1 ? void 0 : n$1.length) > 0 || (null === (i$1 = r$2.addOrUpdateProperties) || void 0 === i$1 ? void 0 : i$1.length) > 0);
					if ((r$2.newGeometry || r$2.removeAllProperties || o$1) && (e$2 = Object.assign({}, e$2), t$1.set(r$2.id, e$2), o$1 && (e$2.properties = Object.assign({}, e$2.properties))), r$2.newGeometry && (e$2.geometry = r$2.newGeometry), r$2.removeAllProperties) e$2.properties = {};
					else if ((null === (s$1 = r$2.removeProperties) || void 0 === s$1 ? void 0 : s$1.length) > 0) for (const t$2 of r$2.removeProperties) Object.prototype.hasOwnProperty.call(e$2.properties, t$2) && delete e$2.properties[t$2];
					if ((null === (a$1 = r$2.addOrUpdateProperties) || void 0 === a$1 ? void 0 : a$1.length) > 0) for (const { key: t$2, value: n$2 } of r$2.addOrUpdateProperties) e$2.properties[t$2] = n$2;
				}
			}, t.cX = Is, t.ca = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = e$1[1], t$1[2] = e$1[2], t$1[3] = e$1[3], t$1[4] = e$1[4], t$1[5] = e$1[5], t$1[6] = e$1[6], t$1[7] = e$1[7], t$1[8] = e$1[8], t$1[9] = e$1[9], t$1[10] = e$1[10], t$1[11] = e$1[11], t$1[12] = e$1[12], t$1[13] = e$1[13], t$1[14] = e$1[14], t$1[15] = e$1[15], t$1;
			}, t.cb = (t$1) => "symbol" === t$1.type, t.cc = (t$1) => "circle" === t$1.type, t.cd = (t$1) => "heatmap" === t$1.type, t.ce = (t$1) => "line" === t$1.type, t.cf = (t$1) => "fill" === t$1.type, t.cg = (t$1) => "fill-extrusion" === t$1.type, t.ch = (t$1) => "hillshade" === t$1.type, t.ci = (t$1) => "color-relief" === t$1.type, t.cj = (t$1) => "raster" === t$1.type, t.ck = (t$1) => "background" === t$1.type, t.cl = (t$1) => "custom" === t$1.type, t.cm = V, t.cn = function(t$1, e$1, r$1) {
				const n$1 = z(e$1.x - r$1.x, e$1.y - r$1.y), i$1 = z(t$1.x - r$1.x, t$1.y - r$1.y);
				var s$1, a$1;
				return et(Math.atan2(n$1[0] * i$1[1] - n$1[1] * i$1[0], (s$1 = n$1)[0] * (a$1 = i$1)[0] + s$1[1] * a$1[1]));
			}, t.co = F, t.cp = function(t$1, e$1) {
				return nt[e$1] && (t$1 instanceof MouseEvent || t$1 instanceof WheelEvent);
			}, t.cq = function(t$1, e$1) {
				return rt[e$1] && "touches" in t$1;
			}, t.cr = function(t$1) {
				return rt[t$1] || nt[t$1];
			}, t.cs = function(t$1, e$1, r$1) {
				var n$1 = e$1[0], i$1 = e$1[1];
				return t$1[0] = r$1[0] * n$1 + r$1[4] * i$1 + r$1[12], t$1[1] = r$1[1] * n$1 + r$1[5] * i$1 + r$1[13], t$1;
			}, t.ct = function(t$1, e$1) {
				const { x: r$1, y: n$1 } = Ch.fromLngLat(e$1);
				return !(t$1 < 0 || t$1 > 25 || n$1 < 0 || n$1 >= 1 || r$1 < 0 || r$1 >= 1);
			}, t.cu = function(t$1, e$1) {
				return t$1[0] = e$1[0], t$1[1] = 0, t$1[2] = 0, t$1[3] = 0, t$1[4] = 0, t$1[5] = e$1[1], t$1[6] = 0, t$1[7] = 0, t$1[8] = 0, t$1[9] = 0, t$1[10] = e$1[2], t$1[11] = 0, t$1[12] = 0, t$1[13] = 0, t$1[14] = 0, t$1[15] = 1, t$1;
			}, t.cv = class extends Ws {}, t.cw = {
				mark(t$1) {
					performance.mark(t$1);
				},
				frame(t$1) {
					const e$1 = t$1;
					null != kp && Mp.push(e$1 - kp), kp = e$1;
				},
				clearMetrics() {
					kp = null, Mp = [], performance.clearMeasures(zp), performance.clearMeasures(Pp);
					for (const e$1 in t.cx) performance.clearMarks(t.cx[e$1]);
				},
				getPerformanceMetrics() {
					performance.measure(zp, t.cx.create, t.cx.load), performance.measure(Pp, t.cx.create, t.cx.fullLoad);
					const e$1 = performance.getEntriesByName(zp)[0].duration, r$1 = performance.getEntriesByName(Pp)[0].duration, n$1 = Mp.length, i$1 = 1 / (Mp.reduce(((t$1, e$2) => t$1 + e$2), 0) / n$1 / 1e3), s$1 = Mp.filter(((t$1) => t$1 > Ip)).reduce(((t$1, e$2) => t$1 + (e$2 - Ip) / Ip), 0);
					return {
						loadTime: e$1,
						fullLoadTime: r$1,
						fps: i$1,
						percentDroppedFrames: s$1 / (n$1 + s$1) * 100,
						totalFrames: n$1
					};
				}
			}, t.cy = function(t$1) {
				return t$1.message === it;
			}, t.cz = ut, t.d = pt, t.e = L, t.f = (t$1) => e(void 0, void 0, void 0, (function* () {
				if (0 === t$1.byteLength) return createImageBitmap(new ImageData(1, 1));
				const e$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				try {
					return createImageBitmap(e$1);
				} catch (t$2) {
					throw new Error(`Could not load image because of ${t$2.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
				}
			})), t.g = ot, t.h = (t$1) => new Promise(((e$1, r$1) => {
				const n$1 = new Image();
				n$1.onload = () => {
					e$1(n$1), URL.revokeObjectURL(n$1.src), n$1.onload = null, window.requestAnimationFrame((() => {
						n$1.src = H;
					}));
				}, n$1.onerror = () => r$1(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
				const i$1 = new Blob([new Uint8Array(t$1)], { type: "image/png" });
				n$1.src = t$1.byteLength ? URL.createObjectURL(i$1) : H;
			})), t.i = X, t.j = (t$1, e$1) => ht(L(t$1, { type: "json" }), e$1), t.k = mt, t.l = yt, t.m = ht, t.n = (t$1, e$1) => ht(L(t$1, { type: "arrayBuffer" }), e$1), t.o = function(t$1) {
				return new uc(t$1).readFields(wc, []);
			}, t.p = Ac, t.q = fl, t.r = Ns, t.s = Q, t.t = Ts, t.u = ds, t.v = xt, t.w = q, t.x = ts, t.y = is, t.z = Qi;
		}));
		define$1("worker", ["./shared"], (function(e) {
			class t {
				constructor(e$1, t$1) {
					this.keyCache = {}, e$1 && this.replace(e$1, t$1);
				}
				replace(e$1, t$1) {
					this._layerConfigs = {}, this._layers = {}, this.update(e$1, [], t$1);
				}
				update(t$1, i$1, o$1) {
					for (const i$2 of t$1) {
						this._layerConfigs[i$2.id] = i$2;
						const t$2 = this._layers[i$2.id] = e.bJ(i$2, o$1);
						t$2._featureFilter = e.aa(t$2.filter, o$1), this.keyCache[i$2.id] && delete this.keyCache[i$2.id];
					}
					for (const e$1 of i$1) delete this.keyCache[e$1], delete this._layerConfigs[e$1], delete this._layers[e$1];
					this.familiesBySource = {};
					const s$1 = e.cC(Object.values(this._layerConfigs), this.keyCache);
					for (const e$1 of s$1) {
						const t$2 = e$1.map(((e$2) => this._layers[e$2.id])), i$2 = t$2[0];
						if ("none" === i$2.visibility) continue;
						const o$2 = i$2.source || "";
						let s$2 = this.familiesBySource[o$2];
						s$2 || (s$2 = this.familiesBySource[o$2] = {});
						const n$1 = i$2.sourceLayer || "_geojsonTileLayer";
						let r$1 = s$2[n$1];
						r$1 || (r$1 = s$2[n$1] = []), r$1.push(t$2);
					}
				}
			}
			class i {
				constructor(t$1) {
					const i$1 = {}, o$1 = [];
					for (const e$1 in t$1) {
						const s$2 = t$1[e$1], n$2 = i$1[e$1] = {};
						for (const e$2 in s$2) {
							const t$2 = s$2[+e$2];
							if (!t$2 || 0 === t$2.bitmap.width || 0 === t$2.bitmap.height) continue;
							const i$2 = {
								x: 0,
								y: 0,
								w: t$2.bitmap.width + 2,
								h: t$2.bitmap.height + 2
							};
							o$1.push(i$2), n$2[e$2] = {
								rect: i$2,
								metrics: t$2.metrics
							};
						}
					}
					const { w: s$1, h: n$1 } = e.p(o$1), r$1 = new e.q({
						width: s$1 || 1,
						height: n$1 || 1
					});
					for (const o$2 in t$1) {
						const s$2 = t$1[o$2];
						for (const t$2 in s$2) {
							const n$2 = s$2[+t$2];
							if (!n$2 || 0 === n$2.bitmap.width || 0 === n$2.bitmap.height) continue;
							const a$1 = i$1[o$2][t$2].rect;
							e.q.copy(n$2.bitmap, r$1, {
								x: 0,
								y: 0
							}, {
								x: a$1.x + 1,
								y: a$1.y + 1
							}, n$2.bitmap);
						}
					}
					this.image = r$1, this.positions = i$1;
				}
			}
			e.cD("GlyphAtlas", i);
			class o {
				constructor(t$1) {
					this.tileID = new e.Z(t$1.tileID.overscaledZ, t$1.tileID.wrap, t$1.tileID.canonical.z, t$1.tileID.canonical.x, t$1.tileID.canonical.y), this.uid = t$1.uid, this.zoom = t$1.zoom, this.pixelRatio = t$1.pixelRatio, this.tileSize = t$1.tileSize, this.source = t$1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t$1.showCollisionBoxes, this.collectResourceTiming = !!t$1.collectResourceTiming, this.returnDependencies = !!t$1.returnDependencies, this.promoteId = t$1.promoteId, this.inFlightDependencies = [];
				}
				parse(t$1, o$1, n$1, r$1, a$1) {
					return e._(this, void 0, void 0, (function* () {
						this.status = "parsing", this.data = t$1, this.collisionBoxArray = new e.a8();
						const l$1 = new e.cE(Object.keys(t$1.layers).sort()), c$1 = new e.cF(this.tileID, this.promoteId);
						c$1.bucketLayerIDs = [];
						const h$1 = {}, u$1 = {
							featureIndex: c$1,
							iconDependencies: {},
							patternDependencies: {},
							glyphDependencies: {},
							dashDependencies: {},
							availableImages: n$1,
							subdivisionGranularity: a$1
						}, d$1 = o$1.familiesBySource[this.source];
						for (const i$1 in d$1) {
							const o$2 = t$1.layers[i$1];
							if (!o$2) continue;
							1 === o$2.version && e.w(`Vector tile source "${this.source}" layer "${i$1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
							const r$2 = l$1.encode(i$1), a$2 = [];
							for (let e$1 = 0; e$1 < o$2.length; e$1++) {
								const t$2 = o$2.feature(e$1), s$1 = c$1.getId(t$2, i$1);
								a$2.push({
									feature: t$2,
									id: s$1,
									index: e$1,
									sourceLayerIndex: r$2
								});
							}
							for (const t$2 of d$1[i$1]) {
								const i$2 = t$2[0];
								i$2.source !== this.source && e.w(`layer.source = ${i$2.source} does not equal this.source = ${this.source}`), i$2.minzoom && this.zoom < Math.floor(i$2.minzoom) || i$2.maxzoom && this.zoom >= i$2.maxzoom || "none" !== i$2.visibility && (s(t$2, this.zoom, n$1), (h$1[i$2.id] = i$2.createBucket({
									index: c$1.bucketLayerIDs.length,
									layers: t$2,
									zoom: this.zoom,
									pixelRatio: this.pixelRatio,
									overscaling: this.overscaling,
									collisionBoxArray: this.collisionBoxArray,
									sourceLayerIndex: r$2,
									sourceID: this.source
								})).populate(a$2, u$1, this.tileID.canonical), c$1.bucketLayerIDs.push(t$2.map(((e$1) => e$1.id))));
							}
						}
						const f$1 = e.bN(u$1.glyphDependencies, ((e$1) => Object.keys(e$1).map(Number)));
						this.inFlightDependencies.forEach(((e$1) => null == e$1 ? void 0 : e$1.abort())), this.inFlightDependencies = [];
						let g$1 = Promise.resolve({});
						if (Object.keys(f$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), g$1 = r$1.sendAsync({
								type: "GG",
								data: {
									stacks: f$1,
									source: this.source,
									tileID: this.tileID,
									type: "glyphs"
								}
							}, e$1);
						}
						const p$1 = Object.keys(u$1.iconDependencies);
						let m$1 = Promise.resolve({});
						if (p$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), m$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: p$1,
									source: this.source,
									tileID: this.tileID,
									type: "icons"
								}
							}, e$1);
						}
						const y$1 = Object.keys(u$1.patternDependencies);
						let v$1 = Promise.resolve({});
						if (y$1.length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), v$1 = r$1.sendAsync({
								type: "GI",
								data: {
									icons: y$1,
									source: this.source,
									tileID: this.tileID,
									type: "patterns"
								}
							}, e$1);
						}
						const w$1 = u$1.dashDependencies;
						let x$1 = Promise.resolve({});
						if (Object.keys(w$1).length) {
							const e$1 = new AbortController();
							this.inFlightDependencies.push(e$1), x$1 = r$1.sendAsync({
								type: "GDA",
								data: { dashes: w$1 }
							}, e$1);
						}
						const [b$1, S$1, _$1, M$1] = yield Promise.all([
							g$1,
							m$1,
							v$1,
							x$1
						]), I$1 = new i(b$1), k$1 = new e.cG(S$1, _$1);
						for (const t$2 in h$1) {
							const i$1 = h$1[t$2];
							i$1 instanceof e.a9 ? (s(i$1.layers, this.zoom, n$1), e.cH({
								bucket: i$1,
								glyphMap: b$1,
								glyphPositions: I$1.positions,
								imageMap: S$1,
								imagePositions: k$1.iconPositions,
								showCollisionBoxes: this.showCollisionBoxes,
								canonical: this.tileID.canonical,
								subdivisionGranularity: u$1.subdivisionGranularity
							})) : i$1.hasDependencies && (i$1 instanceof e.cI || i$1 instanceof e.cJ || i$1 instanceof e.cK) && (s(i$1.layers, this.zoom, n$1), i$1.addFeatures(u$1, this.tileID.canonical, k$1.patternPositions, M$1));
						}
						return this.status = "done", {
							buckets: Object.values(h$1).filter(((e$1) => !e$1.isEmpty())),
							featureIndex: c$1,
							collisionBoxArray: this.collisionBoxArray,
							glyphAtlasImage: I$1.image,
							imageAtlas: k$1,
							dashPositions: M$1,
							glyphMap: this.returnDependencies ? b$1 : null,
							iconMap: this.returnDependencies ? S$1 : null,
							glyphPositions: this.returnDependencies ? I$1.positions : null
						};
					}));
				}
			}
			function s(t$1, i$1, o$1) {
				const s$1 = new e.F(i$1);
				for (const e$1 of t$1) e$1.recalculate(s$1, o$1);
			}
			class n {
				constructor(e$1, t$1, i$1) {
					this.actor = e$1, this.layerIndex = t$1, this.availableImages = i$1, this.fetching = {}, this.loading = {}, this.loaded = {};
				}
				loadVectorTile(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const o$1 = yield e.n(t$1.request, i$1);
						try {
							return {
								vectorTile: new e.cL(new e.cM(o$1.data)),
								rawData: o$1.data,
								cacheControl: o$1.cacheControl,
								expires: o$1.expires
							};
						} catch (e$1) {
							const i$2 = new Uint8Array(o$1.data);
							let s$1 = `Unable to parse the tile at ${t$1.request.url}, `;
							throw s$1 += 31 === i$2[0] && 139 === i$2[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e$1.message}`, new Error(s$1);
						}
					}));
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = t$1.uid, s$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.cN(t$1.request), n$1 = new o(t$1);
						this.loading[i$1] = n$1;
						const r$1 = new AbortController();
						n$1.abort = r$1;
						try {
							const o$1 = yield this.loadVectorTile(t$1, r$1);
							if (delete this.loading[i$1], !o$1) return null;
							const a$1 = o$1.rawData, l$1 = {};
							o$1.expires && (l$1.expires = o$1.expires), o$1.cacheControl && (l$1.cacheControl = o$1.cacheControl);
							const c$1 = {};
							if (s$1) {
								const e$1 = s$1.finish();
								e$1 && (c$1.resourceTiming = JSON.parse(JSON.stringify(e$1)));
							}
							n$1.vectorTile = o$1.vectorTile;
							const h$1 = n$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							this.loaded[i$1] = n$1, this.fetching[i$1] = {
								rawTileData: a$1,
								cacheControl: l$1,
								resourceTiming: c$1
							};
							try {
								const t$2 = yield h$1;
								return e.e({ rawTileData: a$1.slice(0) }, t$2, l$1, c$1);
							} finally {
								delete this.fetching[i$1];
							}
						} catch (e$1) {
							throw delete this.loading[i$1], n$1.status = "done", this.loaded[i$1] = n$1, e$1;
						}
					}));
				}
				reloadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$1 = t$1.uid;
						if (!this.loaded || !this.loaded[i$1]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
						const o$1 = this.loaded[i$1];
						if (o$1.showCollisionBoxes = t$1.showCollisionBoxes, "parsing" === o$1.status) {
							const s$1 = yield o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
							let n$1;
							if (this.fetching[i$1]) {
								const { rawTileData: t$2, cacheControl: o$2, resourceTiming: r$1 } = this.fetching[i$1];
								delete this.fetching[i$1], n$1 = e.e({ rawTileData: t$2.slice(0) }, s$1, o$2, r$1);
							} else n$1 = s$1;
							return n$1;
						}
						if ("done" === o$1.status && o$1.vectorTile) return o$1.parse(o$1.vectorTile, this.layerIndex, this.availableImages, this.actor, t$1.subdivisionGranularity);
					}));
				}
				abortTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const e$1 = this.loading, i$1 = t$1.uid;
						e$1 && e$1[i$1] && e$1[i$1].abort && (e$1[i$1].abort.abort(), delete e$1[i$1]);
					}));
				}
				removeTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this.loaded && this.loaded[t$1.uid] && delete this.loaded[t$1.uid];
					}));
				}
			}
			class r {
				constructor() {
					this.loaded = {};
				}
				loadTile(t$1) {
					return e._(this, void 0, void 0, (function* () {
						const { uid: i$1, encoding: o$1, rawImageData: s$1, redFactor: n$1, greenFactor: r$1, blueFactor: a$1, baseShift: l$1 } = t$1, c$1 = s$1.width + 2, h$1 = s$1.height + 2, u$1 = e.b(s$1) ? new e.R({
							width: c$1,
							height: h$1
						}, yield e.cO(s$1, -1, -1, c$1, h$1)) : s$1, d$1 = new e.cP(i$1, u$1, o$1, n$1, r$1, a$1, l$1);
						return this.loaded = this.loaded || {}, this.loaded[i$1] = d$1, d$1;
					}));
				}
				removeTile(e$1) {
					const t$1 = this.loaded, i$1 = e$1.uid;
					t$1 && t$1[i$1] && delete t$1[i$1];
				}
			}
			var a, l, c = function() {
				if (l) return a;
				function e$1(e$2, i$1) {
					if (0 !== e$2.length) {
						t$1(e$2[0], i$1);
						for (var o$1 = 1; o$1 < e$2.length; o$1++) t$1(e$2[o$1], !i$1);
					}
				}
				function t$1(e$2, t$2) {
					for (var i$1 = 0, o$1 = 0, s$1 = 0, n$1 = e$2.length, r$1 = n$1 - 1; s$1 < n$1; r$1 = s$1++) {
						var a$1 = (e$2[s$1][0] - e$2[r$1][0]) * (e$2[r$1][1] + e$2[s$1][1]), l$1 = i$1 + a$1;
						o$1 += Math.abs(i$1) >= Math.abs(a$1) ? i$1 - l$1 + a$1 : a$1 - l$1 + i$1, i$1 = l$1;
					}
					i$1 + o$1 >= 0 != !!t$2 && e$2.reverse();
				}
				return l = 1, a = function t$2(i$1, o$1) {
					var s$1, n$1 = i$1 && i$1.type;
					if ("FeatureCollection" === n$1) for (s$1 = 0; s$1 < i$1.features.length; s$1++) t$2(i$1.features[s$1], o$1);
					else if ("GeometryCollection" === n$1) for (s$1 = 0; s$1 < i$1.geometries.length; s$1++) t$2(i$1.geometries[s$1], o$1);
					else if ("Feature" === n$1) t$2(i$1.geometry, o$1);
					else if ("Polygon" === n$1) e$1(i$1.coordinates, o$1);
					else if ("MultiPolygon" === n$1) for (s$1 = 0; s$1 < i$1.coordinates.length; s$1++) e$1(i$1.coordinates[s$1], o$1);
					return i$1;
				};
			}(), h = e.cQ(c);
			class u extends e.cS {
				constructor(t$1, i$1) {
					super(new e.cM(), 0, i$1, [], []), this.feature = t$1, this.type = t$1.type, this.properties = t$1.tags ? t$1.tags : {}, "id" in t$1 && ("string" == typeof t$1.id ? this.id = parseInt(t$1.id, 10) : "number" != typeof t$1.id || isNaN(t$1.id) || (this.id = t$1.id));
				}
				loadGeometry() {
					const t$1 = [], i$1 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
					for (const o$1 of i$1) {
						const i$2 = [];
						for (const t$2 of o$1) i$2.push(new e.P(t$2[0], t$2[1]));
						t$1.push(i$2);
					}
					return t$1;
				}
			}
			class d extends e.cR {
				constructor(t$1, i$1) {
					super(new e.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = i$1 ? i$1.version : 1, this.extent = i$1 ? i$1.extent : 4096, this.length = t$1.length, this.features = t$1;
				}
				feature(e$1) {
					return new u(this.features[e$1], this.extent);
				}
			}
			function f(e$1, t$1) {
				t$1.writeVarintField(15, e$1.version || 1), t$1.writeStringField(1, e$1.name || ""), t$1.writeVarintField(5, e$1.extent || 4096);
				const i$1 = {
					keys: [],
					values: [],
					keycache: {},
					valuecache: {}
				};
				for (let o$2 = 0; o$2 < e$1.length; o$2++) i$1.feature = e$1.feature(o$2), t$1.writeMessage(2, g, i$1);
				const o$1 = i$1.keys;
				for (const e$2 of o$1) t$1.writeStringField(3, e$2);
				const s$1 = i$1.values;
				for (const e$2 of s$1) t$1.writeMessage(4, w, e$2);
			}
			function g(e$1, t$1) {
				if (!e$1.feature) return;
				const i$1 = e$1.feature;
				void 0 !== i$1.id && t$1.writeVarintField(1, i$1.id), t$1.writeMessage(2, p, e$1), t$1.writeVarintField(3, i$1.type), t$1.writeMessage(4, v, i$1);
			}
			function p(e$1, t$1) {
				for (const i$1 in e$1.feature?.properties) {
					let o$1 = e$1.feature.properties[i$1], s$1 = e$1.keycache[i$1];
					if (null === o$1) continue;
					void 0 === s$1 && (e$1.keys.push(i$1), s$1 = e$1.keys.length - 1, e$1.keycache[i$1] = s$1), t$1.writeVarint(s$1), "string" != typeof o$1 && "boolean" != typeof o$1 && "number" != typeof o$1 && (o$1 = JSON.stringify(o$1));
					const n$1 = typeof o$1 + ":" + o$1;
					let r$1 = e$1.valuecache[n$1];
					void 0 === r$1 && (e$1.values.push(o$1), r$1 = e$1.values.length - 1, e$1.valuecache[n$1] = r$1), t$1.writeVarint(r$1);
				}
			}
			function m(e$1, t$1) {
				return (t$1 << 3) + (7 & e$1);
			}
			function y(e$1) {
				return e$1 << 1 ^ e$1 >> 31;
			}
			function v(e$1, t$1) {
				const i$1 = e$1.loadGeometry(), o$1 = e$1.type;
				let s$1 = 0, n$1 = 0;
				for (const r$1 of i$1) {
					let i$2 = 1;
					1 === o$1 && (i$2 = r$1.length), t$1.writeVarint(m(1, i$2));
					const a$1 = 3 === o$1 ? r$1.length - 1 : r$1.length;
					for (let e$2 = 0; e$2 < a$1; e$2++) {
						1 === e$2 && 1 !== o$1 && t$1.writeVarint(m(2, a$1 - 1));
						const i$3 = r$1[e$2].x - s$1, l$1 = r$1[e$2].y - n$1;
						t$1.writeVarint(y(i$3)), t$1.writeVarint(y(l$1)), s$1 += i$3, n$1 += l$1;
					}
					3 === e$1.type && t$1.writeVarint(m(7, 1));
				}
			}
			function w(e$1, t$1) {
				const i$1 = typeof e$1;
				"string" === i$1 ? t$1.writeStringField(1, e$1) : "boolean" === i$1 ? t$1.writeBooleanField(7, e$1) : "number" === i$1 && (e$1 % 1 != 0 ? t$1.writeDoubleField(3, e$1) : e$1 < 0 ? t$1.writeSVarintField(6, e$1) : t$1.writeVarintField(5, e$1));
			}
			const x = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e$1) => e$1
			}, b = Math.fround || (S = new Float32Array(1), (e$1) => (S[0] = +e$1, S[0]));
			var S;
			class _ {
				constructor(e$1) {
					this.options = Object.assign(Object.create(x), e$1), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e$1) {
					const { log: t$1, minZoom: i$1, maxZoom: o$1 } = this.options;
					t$1 && console.time("total time");
					const s$1 = `prepare ${e$1.length} points`;
					t$1 && console.time(s$1), this.points = e$1;
					const n$1 = [];
					for (let t$2 = 0; t$2 < e$1.length; t$2++) {
						const i$2 = e$1[t$2];
						if (!i$2.geometry) continue;
						const [o$2, s$2] = i$2.geometry.coordinates, r$2 = b(k(o$2)), a$1 = b(P(s$2));
						n$1.push(r$2, a$1, Infinity, t$2, -1, 1), this.options.reduce && n$1.push(0);
					}
					let r$1 = this.trees[o$1 + 1] = this._createTree(n$1);
					t$1 && console.timeEnd(s$1);
					for (let e$2 = o$1; e$2 >= i$1; e$2--) {
						const i$2 = +Date.now();
						r$1 = this.trees[e$2] = this._createTree(this._cluster(r$1, e$2)), t$1 && console.log("z%d: %d clusters in %dms", e$2, r$1.numItems, +Date.now() - i$2);
					}
					return t$1 && console.timeEnd("total time"), this;
				}
				getClusters(e$1, t$1) {
					let i$1 = ((e$1[0] + 180) % 360 + 360) % 360 - 180;
					const o$1 = Math.max(-90, Math.min(90, e$1[1]));
					let s$1 = 180 === e$1[2] ? 180 : ((e$1[2] + 180) % 360 + 360) % 360 - 180;
					const n$1 = Math.max(-90, Math.min(90, e$1[3]));
					if (e$1[2] - e$1[0] >= 360) i$1 = -180, s$1 = 180;
					else if (i$1 > s$1) {
						const e$2 = this.getClusters([
							i$1,
							o$1,
							180,
							n$1
						], t$1), r$2 = this.getClusters([
							-180,
							o$1,
							s$1,
							n$1
						], t$1);
						return e$2.concat(r$2);
					}
					const r$1 = this.trees[this._limitZoom(t$1)], a$1 = r$1.range(k(i$1), P(n$1), k(s$1), P(o$1)), l$1 = r$1.data, c$1 = [];
					for (const e$2 of a$1) {
						const t$2 = this.stride * e$2;
						c$1.push(l$1[t$2 + 5] > 1 ? M(l$1, t$2, this.clusterProps) : this.points[l$1[t$2 + 3]]);
					}
					return c$1;
				}
				getChildren(e$1) {
					const t$1 = this._getOriginId(e$1), i$1 = this._getOriginZoom(e$1), o$1 = "No cluster with the specified id.", s$1 = this.trees[i$1];
					if (!s$1) throw new Error(o$1);
					const n$1 = s$1.data;
					if (t$1 * this.stride >= n$1.length) throw new Error(o$1);
					const r$1 = this.options.radius / (this.options.extent * Math.pow(2, i$1 - 1)), a$1 = s$1.within(n$1[t$1 * this.stride], n$1[t$1 * this.stride + 1], r$1), l$1 = [];
					for (const t$2 of a$1) {
						const i$2 = t$2 * this.stride;
						n$1[i$2 + 4] === e$1 && l$1.push(n$1[i$2 + 5] > 1 ? M(n$1, i$2, this.clusterProps) : this.points[n$1[i$2 + 3]]);
					}
					if (0 === l$1.length) throw new Error(o$1);
					return l$1;
				}
				getLeaves(e$1, t$1, i$1) {
					const o$1 = [];
					return this._appendLeaves(o$1, e$1, t$1 = t$1 || 10, i$1 = i$1 || 0, 0), o$1;
				}
				getTile(e$1, t$1, i$1) {
					const o$1 = this.trees[this._limitZoom(e$1)], s$1 = Math.pow(2, e$1), { extent: n$1, radius: r$1 } = this.options, a$1 = r$1 / n$1, l$1 = (i$1 - a$1) / s$1, c$1 = (i$1 + 1 + a$1) / s$1, h$1 = { features: [] };
					return this._addTileFeatures(o$1.range((t$1 - a$1) / s$1, l$1, (t$1 + 1 + a$1) / s$1, c$1), o$1.data, t$1, i$1, s$1, h$1), 0 === t$1 && this._addTileFeatures(o$1.range(1 - a$1 / s$1, l$1, 1, c$1), o$1.data, s$1, i$1, s$1, h$1), t$1 === s$1 - 1 && this._addTileFeatures(o$1.range(0, l$1, a$1 / s$1, c$1), o$1.data, -1, i$1, s$1, h$1), h$1.features.length ? h$1 : null;
				}
				getClusterExpansionZoom(e$1) {
					let t$1 = this._getOriginZoom(e$1) - 1;
					for (; t$1 <= this.options.maxZoom;) {
						const i$1 = this.getChildren(e$1);
						if (t$1++, 1 !== i$1.length) break;
						e$1 = i$1[0].properties.cluster_id;
					}
					return t$1;
				}
				_appendLeaves(e$1, t$1, i$1, o$1, s$1) {
					const n$1 = this.getChildren(t$1);
					for (const t$2 of n$1) {
						const n$2 = t$2.properties;
						if (n$2 && n$2.cluster ? s$1 + n$2.point_count <= o$1 ? s$1 += n$2.point_count : s$1 = this._appendLeaves(e$1, n$2.cluster_id, i$1, o$1, s$1) : s$1 < o$1 ? s$1++ : e$1.push(t$2), e$1.length === i$1) break;
					}
					return s$1;
				}
				_createTree(t$1) {
					const i$1 = new e.aI(t$1.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e$1 = 0; e$1 < t$1.length; e$1 += this.stride) i$1.add(t$1[e$1], t$1[e$1 + 1]);
					return i$1.finish(), i$1.data = t$1, i$1;
				}
				_addTileFeatures(e$1, t$1, i$1, o$1, s$1, n$1) {
					for (const r$1 of e$1) {
						const e$2 = r$1 * this.stride, a$1 = t$1[e$2 + 5] > 1;
						let l$1, c$1, h$1;
						if (a$1) l$1 = I(t$1, e$2, this.clusterProps), c$1 = t$1[e$2], h$1 = t$1[e$2 + 1];
						else {
							const i$2 = this.points[t$1[e$2 + 3]];
							l$1 = i$2.properties;
							const [o$2, s$2] = i$2.geometry.coordinates;
							c$1 = k(o$2), h$1 = P(s$2);
						}
						const u$1 = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (c$1 * s$1 - i$1)), Math.round(this.options.extent * (h$1 * s$1 - o$1))]],
							tags: l$1
						};
						let d$1;
						d$1 = a$1 || this.options.generateId ? t$1[e$2 + 3] : this.points[t$1[e$2 + 3]].id, void 0 !== d$1 && (u$1.id = d$1), n$1.features.push(u$1);
					}
				}
				_limitZoom(e$1) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e$1), this.options.maxZoom + 1));
				}
				_cluster(e$1, t$1) {
					const { radius: i$1, extent: o$1, reduce: s$1, minPoints: n$1 } = this.options, r$1 = i$1 / (o$1 * Math.pow(2, t$1)), a$1 = e$1.data, l$1 = [], c$1 = this.stride;
					for (let i$2 = 0; i$2 < a$1.length; i$2 += c$1) {
						if (a$1[i$2 + 2] <= t$1) continue;
						a$1[i$2 + 2] = t$1;
						const o$2 = a$1[i$2], h$1 = a$1[i$2 + 1], u$1 = e$1.within(a$1[i$2], a$1[i$2 + 1], r$1), d$1 = a$1[i$2 + 5];
						let f$1 = d$1;
						for (const e$2 of u$1) {
							const i$3 = e$2 * c$1;
							a$1[i$3 + 2] > t$1 && (f$1 += a$1[i$3 + 5]);
						}
						if (f$1 > d$1 && f$1 >= n$1) {
							let e$2, n$2 = o$2 * d$1, r$2 = h$1 * d$1, g$1 = -1;
							const p$1 = (i$2 / c$1 << 5) + (t$1 + 1) + this.points.length;
							for (const o$3 of u$1) {
								const l$2 = o$3 * c$1;
								if (a$1[l$2 + 2] <= t$1) continue;
								a$1[l$2 + 2] = t$1;
								const h$2 = a$1[l$2 + 5];
								n$2 += a$1[l$2] * h$2, r$2 += a$1[l$2 + 1] * h$2, a$1[l$2 + 4] = p$1, s$1 && (e$2 || (e$2 = this._map(a$1, i$2, !0), g$1 = this.clusterProps.length, this.clusterProps.push(e$2)), s$1(e$2, this._map(a$1, l$2)));
							}
							a$1[i$2 + 4] = p$1, l$1.push(n$2 / f$1, r$2 / f$1, Infinity, p$1, -1, f$1), s$1 && l$1.push(g$1);
						} else {
							for (let e$2 = 0; e$2 < c$1; e$2++) l$1.push(a$1[i$2 + e$2]);
							if (f$1 > 1) for (const e$2 of u$1) {
								const i$3 = e$2 * c$1;
								if (!(a$1[i$3 + 2] <= t$1)) {
									a$1[i$3 + 2] = t$1;
									for (let e$3 = 0; e$3 < c$1; e$3++) l$1.push(a$1[i$3 + e$3]);
								}
							}
						}
					}
					return l$1;
				}
				_getOriginId(e$1) {
					return e$1 - this.points.length >> 5;
				}
				_getOriginZoom(e$1) {
					return (e$1 - this.points.length) % 32;
				}
				_map(e$1, t$1, i$1) {
					if (e$1[t$1 + 5] > 1) {
						const o$2 = this.clusterProps[e$1[t$1 + 6]];
						return i$1 ? Object.assign({}, o$2) : o$2;
					}
					const o$1 = this.points[e$1[t$1 + 3]].properties, s$1 = this.options.map(o$1);
					return i$1 && s$1 === o$1 ? Object.assign({}, s$1) : s$1;
				}
			}
			function M(e$1, t$1, i$1) {
				return {
					type: "Feature",
					id: e$1[t$1 + 3],
					properties: I(e$1, t$1, i$1),
					geometry: {
						type: "Point",
						coordinates: [(o$1 = e$1[t$1], 360 * (o$1 - .5)), D(e$1[t$1 + 1])]
					}
				};
				var o$1;
			}
			function I(e$1, t$1, i$1) {
				const o$1 = e$1[t$1 + 5], s$1 = o$1 >= 1e4 ? `${Math.round(o$1 / 1e3)}k` : o$1 >= 1e3 ? Math.round(o$1 / 100) / 10 + "k" : o$1, n$1 = e$1[t$1 + 6], r$1 = -1 === n$1 ? {} : Object.assign({}, i$1[n$1]);
				return Object.assign(r$1, {
					cluster: !0,
					cluster_id: e$1[t$1 + 3],
					point_count: o$1,
					point_count_abbreviated: s$1
				});
			}
			function k(e$1) {
				return e$1 / 360 + .5;
			}
			function P(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), i$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return i$1 < 0 ? 0 : i$1 > 1 ? 1 : i$1;
			}
			function D(e$1) {
				const t$1 = (180 - 360 * e$1) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t$1)) / Math.PI - 90;
			}
			function T(e$1, t$1, i$1, o$1) {
				let s$1 = o$1;
				const n$1 = t$1 + (i$1 - t$1 >> 1);
				let r$1, a$1 = i$1 - t$1;
				const l$1 = e$1[t$1], c$1 = e$1[t$1 + 1], h$1 = e$1[i$1], u$1 = e$1[i$1 + 1];
				for (let o$2 = t$1 + 3; o$2 < i$1; o$2 += 3) {
					const t$2 = C(e$1[o$2], e$1[o$2 + 1], l$1, c$1, h$1, u$1);
					if (t$2 > s$1) r$1 = o$2, s$1 = t$2;
					else if (t$2 === s$1) {
						const e$2 = Math.abs(o$2 - n$1);
						e$2 < a$1 && (r$1 = o$2, a$1 = e$2);
					}
				}
				s$1 > o$1 && (r$1 - t$1 > 3 && T(e$1, t$1, r$1, o$1), e$1[r$1 + 2] = s$1, i$1 - r$1 > 3 && T(e$1, r$1, i$1, o$1));
			}
			function C(e$1, t$1, i$1, o$1, s$1, n$1) {
				let r$1 = s$1 - i$1, a$1 = n$1 - o$1;
				if (0 !== r$1 || 0 !== a$1) {
					const l$1 = ((e$1 - i$1) * r$1 + (t$1 - o$1) * a$1) / (r$1 * r$1 + a$1 * a$1);
					l$1 > 1 ? (i$1 = s$1, o$1 = n$1) : l$1 > 0 && (i$1 += r$1 * l$1, o$1 += a$1 * l$1);
				}
				return r$1 = e$1 - i$1, a$1 = t$1 - o$1, r$1 * r$1 + a$1 * a$1;
			}
			function L(e$1, t$1, i$1, o$1) {
				const s$1 = {
					id: null == e$1 ? null : e$1,
					type: t$1,
					geometry: i$1,
					tags: o$1,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				if ("Point" === t$1 || "MultiPoint" === t$1 || "LineString" === t$1) O(s$1, i$1);
				else if ("Polygon" === t$1) O(s$1, i$1[0]);
				else if ("MultiLineString" === t$1) for (const e$2 of i$1) O(s$1, e$2);
				else if ("MultiPolygon" === t$1) for (const e$2 of i$1) O(s$1, e$2[0]);
				return s$1;
			}
			function O(e$1, t$1) {
				for (let i$1 = 0; i$1 < t$1.length; i$1 += 3) e$1.minX = Math.min(e$1.minX, t$1[i$1]), e$1.minY = Math.min(e$1.minY, t$1[i$1 + 1]), e$1.maxX = Math.max(e$1.maxX, t$1[i$1]), e$1.maxY = Math.max(e$1.maxY, t$1[i$1 + 1]);
			}
			function F(e$1, t$1, i$1, o$1) {
				if (!t$1.geometry) return;
				const s$1 = t$1.geometry.coordinates;
				if (s$1 && 0 === s$1.length) return;
				const n$1 = t$1.geometry.type, r$1 = Math.pow(i$1.tolerance / ((1 << i$1.maxZoom) * i$1.extent), 2);
				let a$1 = [], l$1 = t$1.id;
				if (i$1.promoteId ? l$1 = t$1.properties[i$1.promoteId] : i$1.generateId && (l$1 = o$1 || 0), "Point" === n$1) z(s$1, a$1);
				else if ("MultiPoint" === n$1) for (const e$2 of s$1) z(e$2, a$1);
				else if ("LineString" === n$1) A(s$1, a$1, r$1, !1);
				else if ("MultiLineString" === n$1) {
					if (i$1.lineMetrics) {
						for (const i$2 of s$1) a$1 = [], A(i$2, a$1, r$1, !1), e$1.push(L(l$1, "LineString", a$1, t$1.properties));
						return;
					}
					G(s$1, a$1, r$1, !1);
				} else if ("Polygon" === n$1) G(s$1, a$1, r$1, !0);
				else {
					if ("MultiPolygon" !== n$1) {
						if ("GeometryCollection" === n$1) {
							for (const s$2 of t$1.geometry.geometries) F(e$1, {
								id: l$1,
								geometry: s$2,
								properties: t$1.properties
							}, i$1, o$1);
							return;
						}
						throw new Error("Input data is not a valid GeoJSON object.");
					}
					for (const e$2 of s$1) {
						const t$2 = [];
						G(e$2, t$2, r$1, !0), a$1.push(t$2);
					}
				}
				e$1.push(L(l$1, n$1, a$1, t$1.properties));
			}
			function z(e$1, t$1) {
				t$1.push(E(e$1[0]), Z(e$1[1]), 0);
			}
			function A(e$1, t$1, i$1, o$1) {
				let s$1, n$1, r$1 = 0;
				for (let i$2 = 0; i$2 < e$1.length; i$2++) {
					const a$2 = E(e$1[i$2][0]), l$1 = Z(e$1[i$2][1]);
					t$1.push(a$2, l$1, 0), i$2 > 0 && (r$1 += o$1 ? (s$1 * l$1 - a$2 * n$1) / 2 : Math.sqrt(Math.pow(a$2 - s$1, 2) + Math.pow(l$1 - n$1, 2))), s$1 = a$2, n$1 = l$1;
				}
				const a$1 = t$1.length - 3;
				t$1[2] = 1, T(t$1, 0, a$1, i$1), t$1[a$1 + 2] = 1, t$1.size = Math.abs(r$1), t$1.start = 0, t$1.end = t$1.size;
			}
			function G(e$1, t$1, i$1, o$1) {
				for (let s$1 = 0; s$1 < e$1.length; s$1++) {
					const n$1 = [];
					A(e$1[s$1], n$1, i$1, o$1), t$1.push(n$1);
				}
			}
			function E(e$1) {
				return e$1 / 360 + .5;
			}
			function Z(e$1) {
				const t$1 = Math.sin(e$1 * Math.PI / 180), i$1 = .5 - .25 * Math.log((1 + t$1) / (1 - t$1)) / Math.PI;
				return i$1 < 0 ? 0 : i$1 > 1 ? 1 : i$1;
			}
			function j(e$1, t$1, i$1, o$1, s$1, n$1, r$1, a$1) {
				if (o$1 /= t$1, n$1 >= (i$1 /= t$1) && r$1 < o$1) return e$1;
				if (r$1 < i$1 || n$1 >= o$1) return null;
				const l$1 = [];
				for (const t$2 of e$1) {
					const e$2 = t$2.geometry;
					let n$2 = t$2.type;
					const r$2 = 0 === s$1 ? t$2.minX : t$2.minY, c$1 = 0 === s$1 ? t$2.maxX : t$2.maxY;
					if (r$2 >= i$1 && c$1 < o$1) {
						l$1.push(t$2);
						continue;
					}
					if (c$1 < i$1 || r$2 >= o$1) continue;
					let h$1 = [];
					if ("Point" === n$2 || "MultiPoint" === n$2) N(e$2, h$1, i$1, o$1, s$1);
					else if ("LineString" === n$2) R(e$2, h$1, i$1, o$1, s$1, !1, a$1.lineMetrics);
					else if ("MultiLineString" === n$2) J(e$2, h$1, i$1, o$1, s$1, !1);
					else if ("Polygon" === n$2) J(e$2, h$1, i$1, o$1, s$1, !0);
					else if ("MultiPolygon" === n$2) for (const t$3 of e$2) {
						const e$3 = [];
						J(t$3, e$3, i$1, o$1, s$1, !0), e$3.length && h$1.push(e$3);
					}
					if (h$1.length) {
						if (a$1.lineMetrics && "LineString" === n$2) {
							for (const e$3 of h$1) l$1.push(L(t$2.id, n$2, e$3, t$2.tags));
							continue;
						}
						"LineString" !== n$2 && "MultiLineString" !== n$2 || (1 === h$1.length ? (n$2 = "LineString", h$1 = h$1[0]) : n$2 = "MultiLineString"), "Point" !== n$2 && "MultiPoint" !== n$2 || (n$2 = 3 === h$1.length ? "Point" : "MultiPoint"), l$1.push(L(t$2.id, n$2, h$1, t$2.tags));
					}
				}
				return l$1.length ? l$1 : null;
			}
			function N(e$1, t$1, i$1, o$1, s$1) {
				for (let n$1 = 0; n$1 < e$1.length; n$1 += 3) {
					const r$1 = e$1[n$1 + s$1];
					r$1 >= i$1 && r$1 <= o$1 && Y(t$1, e$1[n$1], e$1[n$1 + 1], e$1[n$1 + 2]);
				}
			}
			function R(e$1, t$1, i$1, o$1, s$1, n$1, r$1) {
				let a$1 = W(e$1);
				const l$1 = 0 === s$1 ? q : X;
				let c$1, h$1, u$1 = e$1.start;
				for (let d$2 = 0; d$2 < e$1.length - 3; d$2 += 3) {
					const f$2 = e$1[d$2], g$2 = e$1[d$2 + 1], p$2 = e$1[d$2 + 2], m$1 = e$1[d$2 + 3], y$1 = e$1[d$2 + 4], v$1 = 0 === s$1 ? f$2 : g$2, w$1 = 0 === s$1 ? m$1 : y$1;
					let x$1 = !1;
					r$1 && (c$1 = Math.sqrt(Math.pow(f$2 - m$1, 2) + Math.pow(g$2 - y$1, 2))), v$1 < i$1 ? w$1 > i$1 && (h$1 = l$1(a$1, f$2, g$2, m$1, y$1, i$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : v$1 > o$1 ? w$1 < o$1 && (h$1 = l$1(a$1, f$2, g$2, m$1, y$1, o$1), r$1 && (a$1.start = u$1 + c$1 * h$1)) : Y(a$1, f$2, g$2, p$2), w$1 < i$1 && v$1 >= i$1 && (h$1 = l$1(a$1, f$2, g$2, m$1, y$1, i$1), x$1 = !0), w$1 > o$1 && v$1 <= o$1 && (h$1 = l$1(a$1, f$2, g$2, m$1, y$1, o$1), x$1 = !0), !n$1 && x$1 && (r$1 && (a$1.end = u$1 + c$1 * h$1), t$1.push(a$1), a$1 = W(e$1)), r$1 && (u$1 += c$1);
				}
				let d$1 = e$1.length - 3;
				const f$1 = e$1[d$1], g$1 = e$1[d$1 + 1], p$1 = 0 === s$1 ? f$1 : g$1;
				p$1 >= i$1 && p$1 <= o$1 && Y(a$1, f$1, g$1, e$1[d$1 + 2]), d$1 = a$1.length - 3, n$1 && d$1 >= 3 && (a$1[d$1] !== a$1[0] || a$1[d$1 + 1] !== a$1[1]) && Y(a$1, a$1[0], a$1[1], a$1[2]), a$1.length && t$1.push(a$1);
			}
			function W(e$1) {
				const t$1 = [];
				return t$1.size = e$1.size, t$1.start = e$1.start, t$1.end = e$1.end, t$1;
			}
			function J(e$1, t$1, i$1, o$1, s$1, n$1) {
				for (const r$1 of e$1) R(r$1, t$1, i$1, o$1, s$1, n$1, !1);
			}
			function Y(e$1, t$1, i$1, o$1) {
				e$1.push(t$1, i$1, o$1);
			}
			function q(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = (n$1 - t$1) / (o$1 - t$1);
				return Y(e$1, n$1, i$1 + (s$1 - i$1) * r$1, 1), r$1;
			}
			function X(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = (n$1 - i$1) / (s$1 - i$1);
				return Y(e$1, t$1 + (o$1 - t$1) * r$1, n$1, 1), r$1;
			}
			function H(e$1, t$1) {
				const i$1 = [];
				for (let o$1 = 0; o$1 < e$1.length; o$1++) {
					const s$1 = e$1[o$1], n$1 = s$1.type;
					let r$1;
					if ("Point" === n$1 || "MultiPoint" === n$1 || "LineString" === n$1) r$1 = V(s$1.geometry, t$1);
					else if ("MultiLineString" === n$1 || "Polygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) r$1.push(V(e$2, t$1));
					} else if ("MultiPolygon" === n$1) {
						r$1 = [];
						for (const e$2 of s$1.geometry) {
							const i$2 = [];
							for (const o$2 of e$2) i$2.push(V(o$2, t$1));
							r$1.push(i$2);
						}
					}
					i$1.push(L(s$1.id, n$1, r$1, s$1.tags));
				}
				return i$1;
			}
			function V(e$1, t$1) {
				const i$1 = [];
				i$1.size = e$1.size, void 0 !== e$1.start && (i$1.start = e$1.start, i$1.end = e$1.end);
				for (let o$1 = 0; o$1 < e$1.length; o$1 += 3) i$1.push(e$1[o$1] + t$1, e$1[o$1 + 1], e$1[o$1 + 2]);
				return i$1;
			}
			function B(e$1, t$1) {
				if (e$1.transformed) return e$1;
				const i$1 = 1 << e$1.z, o$1 = e$1.x, s$1 = e$1.y;
				for (const n$1 of e$1.features) {
					const e$2 = n$1.geometry, r$1 = n$1.type;
					if (n$1.geometry = [], 1 === r$1) for (let r$2 = 0; r$2 < e$2.length; r$2 += 2) n$1.geometry.push($(e$2[r$2], e$2[r$2 + 1], t$1, i$1, o$1, s$1));
					else for (let r$2 = 0; r$2 < e$2.length; r$2++) {
						const a$1 = [];
						for (let n$2 = 0; n$2 < e$2[r$2].length; n$2 += 2) a$1.push($(e$2[r$2][n$2], e$2[r$2][n$2 + 1], t$1, i$1, o$1, s$1));
						n$1.geometry.push(a$1);
					}
				}
				return e$1.transformed = !0, e$1;
			}
			function $(e$1, t$1, i$1, o$1, s$1, n$1) {
				return [Math.round(i$1 * (e$1 * o$1 - s$1)), Math.round(i$1 * (t$1 * o$1 - n$1))];
			}
			function U(e$1, t$1, i$1, o$1, s$1) {
				const n$1 = t$1 === s$1.maxZoom ? 0 : s$1.tolerance / ((1 << t$1) * s$1.extent), r$1 = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e$1.length,
					source: null,
					x: i$1,
					y: o$1,
					z: t$1,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (const t$2 of e$1) K(r$1, t$2, n$1, s$1);
				return r$1;
			}
			function K(e$1, t$1, i$1, o$1) {
				const s$1 = t$1.geometry, n$1 = t$1.type, r$1 = [];
				if (e$1.minX = Math.min(e$1.minX, t$1.minX), e$1.minY = Math.min(e$1.minY, t$1.minY), e$1.maxX = Math.max(e$1.maxX, t$1.maxX), e$1.maxY = Math.max(e$1.maxY, t$1.maxY), "Point" === n$1 || "MultiPoint" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2 += 3) r$1.push(s$1[t$2], s$1[t$2 + 1]), e$1.numPoints++, e$1.numSimplified++;
				else if ("LineString" === n$1) Q(r$1, s$1, e$1, i$1, !1, !1);
				else if ("MultiLineString" === n$1 || "Polygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) Q(r$1, s$1[t$2], e$1, i$1, "Polygon" === n$1, 0 === t$2);
				else if ("MultiPolygon" === n$1) for (let t$2 = 0; t$2 < s$1.length; t$2++) {
					const o$2 = s$1[t$2];
					for (let t$3 = 0; t$3 < o$2.length; t$3++) Q(r$1, o$2[t$3], e$1, i$1, !0, 0 === t$3);
				}
				if (r$1.length) {
					let i$2 = t$1.tags || null;
					if ("LineString" === n$1 && o$1.lineMetrics) {
						i$2 = {};
						for (const e$2 in t$1.tags) i$2[e$2] = t$1.tags[e$2];
						i$2.mapbox_clip_start = s$1.start / s$1.size, i$2.mapbox_clip_end = s$1.end / s$1.size;
					}
					const a$1 = {
						geometry: r$1,
						type: "Polygon" === n$1 || "MultiPolygon" === n$1 ? 3 : "LineString" === n$1 || "MultiLineString" === n$1 ? 2 : 1,
						tags: i$2
					};
					null !== t$1.id && (a$1.id = t$1.id), e$1.features.push(a$1);
				}
			}
			function Q(e$1, t$1, i$1, o$1, s$1, n$1) {
				const r$1 = o$1 * o$1;
				if (o$1 > 0 && t$1.size < (s$1 ? r$1 : o$1)) return void (i$1.numPoints += t$1.length / 3);
				const a$1 = [];
				for (let e$2 = 0; e$2 < t$1.length; e$2 += 3) (0 === o$1 || t$1[e$2 + 2] > r$1) && (i$1.numSimplified++, a$1.push(t$1[e$2], t$1[e$2 + 1])), i$1.numPoints++;
				s$1 && function(e$2, t$2) {
					let i$2 = 0;
					for (let t$3 = 0, o$2 = e$2.length, s$2 = o$2 - 2; t$3 < o$2; s$2 = t$3, t$3 += 2) i$2 += (e$2[t$3] - e$2[s$2]) * (e$2[t$3 + 1] + e$2[s$2 + 1]);
					if (i$2 > 0 === t$2) for (let t$3 = 0, i$3 = e$2.length; t$3 < i$3 / 2; t$3 += 2) {
						const o$2 = e$2[t$3], s$2 = e$2[t$3 + 1];
						e$2[t$3] = e$2[i$3 - 2 - t$3], e$2[t$3 + 1] = e$2[i$3 - 1 - t$3], e$2[i$3 - 2 - t$3] = o$2, e$2[i$3 - 1 - t$3] = s$2;
					}
				}(a$1, n$1), e$1.push(a$1);
			}
			const ee = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				debug: 0
			};
			class te {
				constructor(e$1, t$1) {
					const i$1 = (t$1 = this.options = function(e$2, t$2) {
						for (const i$2 in t$2) e$2[i$2] = t$2[i$2];
						return e$2;
					}(Object.create(ee), t$1)).debug;
					if (i$1 && console.time("preprocess data"), t$1.maxZoom < 0 || t$1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
					if (t$1.promoteId && t$1.generateId) throw new Error("promoteId and generateId cannot be used together.");
					let o$1 = function(e$2, t$2) {
						const i$2 = [];
						if ("FeatureCollection" === e$2.type) for (let o$2 = 0; o$2 < e$2.features.length; o$2++) F(i$2, e$2.features[o$2], t$2, o$2);
						else F(i$2, "Feature" === e$2.type ? e$2 : { geometry: e$2 }, t$2);
						return i$2;
					}(e$1, t$1);
					this.tiles = {}, this.tileCoords = [], i$1 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t$1.indexMaxZoom, t$1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o$1 = function(e$2, t$2) {
						const i$2 = t$2.buffer / t$2.extent;
						let o$2 = e$2;
						const s$1 = j(e$2, 1, -1 - i$2, i$2, 0, -1, 2, t$2), n$1 = j(e$2, 1, 1 - i$2, 2 + i$2, 0, -1, 2, t$2);
						return (s$1 || n$1) && (o$2 = j(e$2, 1, -i$2, 1 + i$2, 0, -1, 2, t$2) || [], s$1 && (o$2 = H(s$1, 1).concat(o$2)), n$1 && (o$2 = o$2.concat(H(n$1, -1)))), o$2;
					}(o$1, t$1), o$1.length && this.splitTile(o$1, 0, 0, 0), i$1 && (o$1.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e$1, t$1, i$1, o$1, s$1, n$1, r$1) {
					const a$1 = [
						e$1,
						t$1,
						i$1,
						o$1
					], l$1 = this.options, c$1 = l$1.debug;
					for (; a$1.length;) {
						o$1 = a$1.pop(), i$1 = a$1.pop(), t$1 = a$1.pop(), e$1 = a$1.pop();
						const h$1 = 1 << t$1, u$1 = ie(t$1, i$1, o$1);
						let d$1 = this.tiles[u$1];
						if (!d$1 && (c$1 > 1 && console.time("creation"), d$1 = this.tiles[u$1] = U(e$1, t$1, i$1, o$1, l$1), this.tileCoords.push({
							z: t$1,
							x: i$1,
							y: o$1
						}), c$1)) {
							c$1 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t$1, i$1, o$1, d$1.numFeatures, d$1.numPoints, d$1.numSimplified), console.timeEnd("creation"));
							const e$2 = `z${t$1}`;
							this.stats[e$2] = (this.stats[e$2] || 0) + 1, this.total++;
						}
						if (d$1.source = e$1, null == s$1) {
							if (t$1 === l$1.indexMaxZoom || d$1.numPoints <= l$1.indexMaxPoints) continue;
						} else {
							if (t$1 === l$1.maxZoom || t$1 === s$1) continue;
							if (null != s$1) {
								const e$2 = s$1 - t$1;
								if (i$1 !== n$1 >> e$2 || o$1 !== r$1 >> e$2) continue;
							}
						}
						if (d$1.source = null, 0 === e$1.length) continue;
						c$1 > 1 && console.time("clipping");
						const f$1 = .5 * l$1.buffer / l$1.extent, g$1 = .5 - f$1, p$1 = .5 + f$1, m$1 = 1 + f$1;
						let y$1 = null, v$1 = null, w$1 = null, x$1 = null, b$1 = j(e$1, h$1, i$1 - f$1, i$1 + p$1, 0, d$1.minX, d$1.maxX, l$1), S$1 = j(e$1, h$1, i$1 + g$1, i$1 + m$1, 0, d$1.minX, d$1.maxX, l$1);
						e$1 = null, b$1 && (y$1 = j(b$1, h$1, o$1 - f$1, o$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), v$1 = j(b$1, h$1, o$1 + g$1, o$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), b$1 = null), S$1 && (w$1 = j(S$1, h$1, o$1 - f$1, o$1 + p$1, 1, d$1.minY, d$1.maxY, l$1), x$1 = j(S$1, h$1, o$1 + g$1, o$1 + m$1, 1, d$1.minY, d$1.maxY, l$1), S$1 = null), c$1 > 1 && console.timeEnd("clipping"), a$1.push(y$1 || [], t$1 + 1, 2 * i$1, 2 * o$1), a$1.push(v$1 || [], t$1 + 1, 2 * i$1, 2 * o$1 + 1), a$1.push(w$1 || [], t$1 + 1, 2 * i$1 + 1, 2 * o$1), a$1.push(x$1 || [], t$1 + 1, 2 * i$1 + 1, 2 * o$1 + 1);
					}
				}
				getTile(e$1, t$1, i$1) {
					e$1 = +e$1, t$1 = +t$1, i$1 = +i$1;
					const { extent: s$1, debug: n$1 } = this.options;
					if (e$1 < 0 || e$1 > 24) return null;
					const r$1 = 1 << e$1, a$1 = ie(e$1, t$1 = t$1 + r$1 & r$1 - 1, i$1);
					if (this.tiles[a$1]) return B(this.tiles[a$1], s$1);
					n$1 > 1 && console.log("drilling down to z%d-%d-%d", e$1, t$1, i$1);
					let l$1, c$1 = e$1, h$1 = t$1, u$1 = i$1;
					for (; !l$1 && c$1 > 0;) c$1--, h$1 >>= 1, u$1 >>= 1, l$1 = this.tiles[ie(c$1, h$1, u$1)];
					return l$1 && l$1.source ? (n$1 > 1 && (console.log("found parent tile z%d-%d-%d", c$1, h$1, u$1), console.time("drilling down")), this.splitTile(l$1.source, c$1, h$1, u$1, e$1, t$1, i$1), n$1 > 1 && console.timeEnd("drilling down"), this.tiles[a$1] ? B(this.tiles[a$1], s$1) : null) : null;
				}
			}
			function ie(e$1, t$1, i$1) {
				return 32 * ((1 << e$1) * i$1 + t$1) + e$1;
			}
			class oe extends n {
				constructor() {
					super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
				}
				loadVectorTile(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const i$2 = t$1.tileID.canonical;
						if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
						const o$1 = this._geoJSONIndex.getTile(i$2.z, i$2.x, i$2.y);
						if (!o$1) return null;
						const s$1 = new d(o$1.features, {
							version: 2,
							extent: e.$
						});
						let n$1 = function(t$2) {
							const i$3 = new e.cM();
							return function(e$1, t$3) {
								for (const i$4 in e$1.layers) t$3.writeMessage(3, f, e$1.layers[i$4]);
							}(t$2, i$3), i$3.finish();
						}(s$1);
						return 0 === n$1.byteOffset && n$1.byteLength === n$1.buffer.byteLength || (n$1 = new Uint8Array(n$1)), {
							vectorTile: s$1,
							rawData: n$1.buffer
						};
					}));
				}
				loadData(t$1) {
					return e._(this, void 0, void 0, (function* () {
						var i$1;
						null === (i$1 = this._pendingRequest) || void 0 === i$1 || i$1.abort();
						const o$1 = !!(t$1 && t$1.request && t$1.request.collectResourceTiming) && new e.cN(t$1.request);
						this._pendingRequest = new AbortController();
						try {
							this._pendingData = this.loadAndProcessGeoJSON(t$1, this._pendingRequest);
							const i$2 = yield this._pendingData;
							this._geoJSONIndex = t$1.cluster ? new _(function({ superclusterOptions: t$2, clusterProperties: i$3 }) {
								if (!i$3 || !t$2) return t$2;
								const o$2 = {}, s$2 = {}, n$1 = {
									accumulated: null,
									zoom: 0
								}, r$1 = { properties: null }, a$1 = Object.keys(i$3);
								for (const t$3 of a$1) {
									const [n$2, r$2] = i$3[t$3], a$2 = e.cT(r$2), l$1 = e.cT("string" == typeof n$2 ? [
										n$2,
										["accumulated"],
										["get", t$3]
									] : n$2);
									o$2[t$3] = a$2.value, s$2[t$3] = l$1.value;
								}
								return t$2.map = (e$1) => {
									r$1.properties = e$1;
									const t$3 = {};
									for (const e$2 of a$1) t$3[e$2] = o$2[e$2].evaluate(n$1, r$1);
									return t$3;
								}, t$2.reduce = (e$1, t$3) => {
									r$1.properties = t$3;
									for (const t$4 of a$1) n$1.accumulated = e$1[t$4], e$1[t$4] = s$2[t$4].evaluate(n$1, r$1);
								}, t$2;
							}(t$1)).load(i$2.features) : function(e$1, t$2) {
								return new te(e$1, t$2);
							}(i$2, t$1.geojsonVtOptions), this.loaded = {};
							const s$1 = { data: i$2 };
							if (o$1) {
								const e$1 = o$1.finish();
								e$1 && (s$1.resourceTiming = {}, s$1.resourceTiming[t$1.source] = JSON.parse(JSON.stringify(e$1)));
							}
							return s$1;
						} catch (t$2) {
							if (delete this._pendingRequest, e.cy(t$2)) return { abandoned: !0 };
							throw t$2;
						}
					}));
				}
				getData() {
					return e._(this, void 0, void 0, (function* () {
						return this._pendingData;
					}));
				}
				reloadTile(e$1) {
					const t$1 = this.loaded;
					return t$1 && t$1[e$1.uid] ? super.reloadTile(e$1) : this.loadTile(e$1);
				}
				loadAndProcessGeoJSON(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						let o$1 = yield this.loadGeoJSON(t$1, i$1);
						if (delete this._pendingRequest, "object" != typeof o$1) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						if (h(o$1, !0), t$1.filter) {
							const i$2 = e.cT(t$1.filter, {
								type: "boolean",
								"property-type": "data-driven",
								overridable: !1,
								transition: !1
							});
							if ("error" === i$2.result) throw new Error(i$2.value.map(((e$1) => `${e$1.key}: ${e$1.message}`)).join(", "));
							o$1 = {
								type: "FeatureCollection",
								features: o$1.features.filter(((e$1) => i$2.value.evaluate({ zoom: 0 }, e$1)))
							};
						}
						return o$1;
					}));
				}
				loadGeoJSON(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						const { promoteId: o$1 } = t$1;
						if (t$1.request) {
							const s$1 = yield e.j(t$1.request, i$1);
							return this._dataUpdateable = e.cV(s$1.data, o$1) ? e.cU(s$1.data, o$1) : void 0, s$1.data;
						}
						if ("string" == typeof t$1.data) try {
							const i$2 = JSON.parse(t$1.data);
							return this._dataUpdateable = e.cV(i$2, o$1) ? e.cU(i$2, o$1) : void 0, i$2;
						} catch (e$1) {
							throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						}
						if (!t$1.dataDiff) throw new Error(`Input data given to '${t$1.source}' is not a valid GeoJSON object.`);
						if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t$1.source}`);
						return e.cW(this._dataUpdateable, t$1.dataDiff, o$1), {
							type: "FeatureCollection",
							features: Array.from(this._dataUpdateable.values())
						};
					}));
				}
				removeSource(t$1) {
					return e._(this, void 0, void 0, (function* () {
						this._pendingRequest && this._pendingRequest.abort();
					}));
				}
				getClusterExpansionZoom(e$1) {
					return this._geoJSONIndex.getClusterExpansionZoom(e$1.clusterId);
				}
				getClusterChildren(e$1) {
					return this._geoJSONIndex.getChildren(e$1.clusterId);
				}
				getClusterLeaves(e$1) {
					return this._geoJSONIndex.getLeaves(e$1.clusterId, e$1.limit, e$1.offset);
				}
			}
			class se {
				constructor(t$1) {
					this.self = t$1, this.actor = new e.J(t$1), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e$1, t$2) => {
						if (this.externalWorkerSourceTypes[e$1]) throw new Error(`Worker source with name "${e$1}" already registered.`);
						this.externalWorkerSourceTypes[e$1] = t$2;
					}, this.self.addProtocol = e.cA, this.self.removeProtocol = e.cB, this.self.registerRTLTextPlugin = (t$2) => {
						e.cX.setMethods(t$2);
					}, this.actor.registerMessageHandler("LDT", ((e$1, t$2) => this._getDEMWorkerSource(e$1, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RDT", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getDEMWorkerSource(t$2, i$1.source).removeTile(i$1);
					})))), this.actor.registerMessageHandler("GCEZ", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterExpansionZoom(i$1);
					})))), this.actor.registerMessageHandler("GCC", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterChildren(i$1);
					})))), this.actor.registerMessageHandler("GCL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t$2, i$1.type, i$1.source).getClusterLeaves(i$1);
					})))), this.actor.registerMessageHandler("LD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadData(t$2))), this.actor.registerMessageHandler("GD", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).getData())), this.actor.registerMessageHandler("LT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).loadTile(t$2))), this.actor.registerMessageHandler("RT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).reloadTile(t$2))), this.actor.registerMessageHandler("AT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).abortTile(t$2))), this.actor.registerMessageHandler("RMT", ((e$1, t$2) => this._getWorkerSource(e$1, t$2.type, t$2.source).removeTile(t$2))), this.actor.registerMessageHandler("RS", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						if (!this.workerSources[t$2] || !this.workerSources[t$2][i$1.type] || !this.workerSources[t$2][i$1.type][i$1.source]) return;
						const e$1 = this.workerSources[t$2][i$1.type][i$1.source];
						delete this.workerSources[t$2][i$1.type][i$1.source], void 0 !== e$1.removeSource && e$1.removeSource(i$1);
					})))), this.actor.registerMessageHandler("RM", ((t$2) => e._(this, void 0, void 0, (function* () {
						delete this.layerIndexes[t$2], delete this.availableImages[t$2], delete this.workerSources[t$2], delete this.demWorkerSources[t$2], this.globalStates.delete(t$2);
					})))), this.actor.registerMessageHandler("SR", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this.referrer = i$1;
					})))), this.actor.registerMessageHandler("SRPS", ((e$1, t$2) => this._syncRTLPluginState(e$1, t$2))), this.actor.registerMessageHandler("IS", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this.self.importScripts(i$1);
					})))), this.actor.registerMessageHandler("SI", ((e$1, t$2) => this._setImages(e$1, t$2))), this.actor.registerMessageHandler("UL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).update(i$1.layers, i$1.removedIds, this._getGlobalState(t$2));
					})))), this.actor.registerMessageHandler("UGS", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						const e$1 = this._getGlobalState(t$2);
						for (const t$3 in i$1) e$1[t$3] = i$1[t$3];
					})))), this.actor.registerMessageHandler("SL", ((t$2, i$1) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t$2).replace(i$1, this._getGlobalState(t$2));
					}))));
				}
				_getGlobalState(e$1) {
					let t$1 = this.globalStates.get(e$1);
					return t$1 || (t$1 = {}, this.globalStates.set(e$1, t$1)), t$1;
				}
				_setImages(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						this.availableImages[t$1] = i$1;
						for (const e$1 in this.workerSources[t$1]) {
							const o$1 = this.workerSources[t$1][e$1];
							for (const e$2 in o$1) o$1[e$2].availableImages = i$1;
						}
					}));
				}
				_syncRTLPluginState(t$1, i$1) {
					return e._(this, void 0, void 0, (function* () {
						return yield e.cX.syncState(i$1, this.self.importScripts);
					}));
				}
				_getAvailableImages(e$1) {
					let t$1 = this.availableImages[e$1];
					return t$1 || (t$1 = []), t$1;
				}
				_getLayerIndex(e$1) {
					let i$1 = this.layerIndexes[e$1];
					return i$1 || (i$1 = this.layerIndexes[e$1] = new t()), i$1;
				}
				_getWorkerSource(e$1, t$1, i$1) {
					if (this.workerSources[e$1] || (this.workerSources[e$1] = {}), this.workerSources[e$1][t$1] || (this.workerSources[e$1][t$1] = {}), !this.workerSources[e$1][t$1][i$1]) {
						const o$1 = { sendAsync: (t$2, i$2) => (t$2.targetMapId = e$1, this.actor.sendAsync(t$2, i$2)) };
						switch (t$1) {
							case "vector":
								this.workerSources[e$1][t$1][i$1] = new n(o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							case "geojson":
								this.workerSources[e$1][t$1][i$1] = new oe(o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
								break;
							default: this.workerSources[e$1][t$1][i$1] = new this.externalWorkerSourceTypes[t$1](o$1, this._getLayerIndex(e$1), this._getAvailableImages(e$1));
						}
					}
					return this.workerSources[e$1][t$1][i$1];
				}
				_getDEMWorkerSource(e$1, t$1) {
					return this.demWorkerSources[e$1] || (this.demWorkerSources[e$1] = {}), this.demWorkerSources[e$1][t$1] || (this.demWorkerSources[e$1][t$1] = new r()), this.demWorkerSources[e$1][t$1];
				}
			}
			return e.i(self) && (self.worker = new se(self)), se;
		}));
		define$1("index", ["exports", "./shared"], (function(e, t) {
			var i = "5.8.0";
			function o() {
				var e$1 = new t.A(4);
				return t.A != Float32Array && (e$1[1] = 0, e$1[2] = 0), e$1[0] = 1, e$1[3] = 1, e$1;
			}
			let r, a;
			const s = {
				now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
				frame(e$1, i$1, o$1) {
					const r$1 = requestAnimationFrame(((e$2) => {
						a$1(), i$1(e$2);
					})), { unsubscribe: a$1 } = t.s(e$1.signal, "abort", (() => {
						a$1(), cancelAnimationFrame(r$1), o$1(t.c());
					}), !1);
				},
				frameAsync(e$1) {
					return new Promise(((t$1, i$1) => {
						this.frame(e$1, t$1, i$1);
					}));
				},
				getImageData(e$1, t$1 = 0) {
					return this.getImageCanvasContext(e$1).getImageData(-t$1, -t$1, e$1.width + 2 * t$1, e$1.height + 2 * t$1);
				},
				getImageCanvasContext(e$1) {
					const t$1 = window.document.createElement("canvas"), i$1 = t$1.getContext("2d", { willReadFrequently: !0 });
					if (!i$1) throw new Error("failed to create canvas 2d context");
					return t$1.width = e$1.width, t$1.height = e$1.height, i$1.drawImage(e$1, 0, 0, e$1.width, e$1.height), i$1;
				},
				resolveURL: (e$1) => (r || (r = document.createElement("a")), r.href = e$1, r.href),
				hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4,
				get prefersReducedMotion() {
					return !!matchMedia && (a ??= matchMedia("(prefers-reduced-motion: reduce)"), a.matches);
				}
			};
			class n {
				static testProp(e$1) {
					if (!n.docStyle) return e$1[0];
					for (let t$1 = 0; t$1 < e$1.length; t$1++) if (e$1[t$1] in n.docStyle) return e$1[t$1];
					return e$1[0];
				}
				static create(e$1, t$1, i$1) {
					const o$1 = window.document.createElement(e$1);
					return void 0 !== t$1 && (o$1.className = t$1), i$1 && i$1.appendChild(o$1), o$1;
				}
				static createNS(e$1, t$1) {
					return window.document.createElementNS(e$1, t$1);
				}
				static disableDrag() {
					n.docStyle && n.selectProp && (n.userSelect = n.docStyle[n.selectProp], n.docStyle[n.selectProp] = "none");
				}
				static enableDrag() {
					n.docStyle && n.selectProp && (n.docStyle[n.selectProp] = n.userSelect);
				}
				static setTransform(e$1, t$1) {
					e$1.style[n.transformProp] = t$1;
				}
				static addEventListener(e$1, t$1, i$1, o$1 = {}) {
					e$1.addEventListener(t$1, i$1, "passive" in o$1 ? o$1 : o$1.capture);
				}
				static removeEventListener(e$1, t$1, i$1, o$1 = {}) {
					e$1.removeEventListener(t$1, i$1, "passive" in o$1 ? o$1 : o$1.capture);
				}
				static suppressClickInternal(e$1) {
					e$1.preventDefault(), e$1.stopPropagation(), window.removeEventListener("click", n.suppressClickInternal, !0);
				}
				static suppressClick() {
					window.addEventListener("click", n.suppressClickInternal, !0), window.setTimeout((() => {
						window.removeEventListener("click", n.suppressClickInternal, !0);
					}), 0);
				}
				static getScale(e$1) {
					const t$1 = e$1.getBoundingClientRect();
					return {
						x: t$1.width / e$1.offsetWidth || 1,
						y: t$1.height / e$1.offsetHeight || 1,
						boundingClientRect: t$1
					};
				}
				static getPoint(e$1, i$1, o$1) {
					const r$1 = i$1.boundingClientRect;
					return new t.P((o$1.clientX - r$1.left) / i$1.x - e$1.clientLeft, (o$1.clientY - r$1.top) / i$1.y - e$1.clientTop);
				}
				static mousePos(e$1, t$1) {
					const i$1 = n.getScale(e$1);
					return n.getPoint(e$1, i$1, t$1);
				}
				static touchPos(e$1, t$1) {
					const i$1 = [], o$1 = n.getScale(e$1);
					for (let r$1 = 0; r$1 < t$1.length; r$1++) i$1.push(n.getPoint(e$1, o$1, t$1[r$1]));
					return i$1;
				}
				static mouseButton(e$1) {
					return e$1.button;
				}
				static remove(e$1) {
					e$1.parentNode && e$1.parentNode.removeChild(e$1);
				}
				static sanitize(e$1) {
					const t$1 = new DOMParser().parseFromString(e$1, "text/html").body || document.createElement("body"), i$1 = t$1.querySelectorAll("script");
					for (const e$2 of i$1) e$2.remove();
					return n.clean(t$1), t$1.innerHTML;
				}
				static isPossiblyDangerous(e$1, t$1) {
					const i$1 = t$1.replace(/\s+/g, "").toLowerCase();
					return !(![
						"src",
						"href",
						"xlink:href"
					].includes(e$1) || !i$1.includes("javascript:") && !i$1.includes("data:")) || !!e$1.startsWith("on") || void 0;
				}
				static clean(e$1) {
					const t$1 = e$1.children;
					for (const e$2 of t$1) n.removeAttributes(e$2), n.clean(e$2);
				}
				static removeAttributes(e$1) {
					for (const { name: t$1, value: i$1 } of e$1.attributes) n.isPossiblyDangerous(t$1, i$1) && e$1.removeAttribute(t$1);
				}
			}
			n.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n.selectProp = n.testProp([
				"userSelect",
				"MozUserSelect",
				"WebkitUserSelect",
				"msUserSelect"
			]), n.transformProp = n.testProp(["transform", "WebkitTransform"]);
			const l = {
				supported: !1,
				testSupport: function(e$1) {
					!u && h && (d ? _(e$1) : c = e$1);
				}
			};
			let c, h, u = !1, d = !1;
			function _(e$1) {
				const t$1 = e$1.createTexture();
				e$1.bindTexture(e$1.TEXTURE_2D, t$1);
				try {
					if (e$1.texImage2D(e$1.TEXTURE_2D, 0, e$1.RGBA, e$1.RGBA, e$1.UNSIGNED_BYTE, h), e$1.isContextLost()) return;
					l.supported = !0;
				} catch (e$2) {}
				e$1.deleteTexture(t$1), u = !0;
			}
			var p;
			"undefined" != typeof document && (h = document.createElement("img"), h.onload = () => {
				c && _(c), c = null, d = !0;
			}, h.onerror = () => {
				u = !0, c = null;
			}, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e$1) {
				let i$1, o$1, r$1, a$1;
				e$1.resetRequestQueue = () => {
					i$1 = [], o$1 = 0, r$1 = 0, a$1 = {};
				}, e$1.addThrottleControl = (e$2) => {
					const t$1 = r$1++;
					return a$1[t$1] = e$2, t$1;
				}, e$1.removeThrottleControl = (e$2) => {
					delete a$1[e$2], n$1();
				}, e$1.getImage = (e$2, o$2, r$2 = !0) => new Promise(((a$2, s$2) => {
					l.supported && (e$2.headers || (e$2.headers = {}), e$2.headers.accept = "image/webp,*/*"), t.e(e$2, { type: "image" }), i$1.push({
						abortController: o$2,
						requestParameters: e$2,
						supportImageRefresh: r$2,
						state: "queued",
						onError: (e$3) => {
							s$2(e$3);
						},
						onSuccess: (e$3) => {
							a$2(e$3);
						}
					}), n$1();
				}));
				const s$1 = (e$2) => t._(this, void 0, void 0, (function* () {
					e$2.state = "running";
					const { requestParameters: i$2, supportImageRefresh: r$2, onError: a$2, onSuccess: s$2, abortController: l$1 } = e$2, h$1 = !1 === r$2 && !t.i(self) && !t.g(i$2.url) && (!i$2.headers || Object.keys(i$2.headers).reduce(((e$3, t$1) => e$3 && "accept" === t$1), !0));
					o$1++;
					const u$1 = h$1 ? c$1(i$2, l$1) : t.m(i$2, l$1);
					try {
						const i$3 = yield u$1;
						delete e$2.abortController, e$2.state = "completed", i$3.data instanceof HTMLImageElement || t.b(i$3.data) ? s$2(i$3) : i$3.data && s$2({
							data: yield (d$1 = i$3.data, "function" == typeof createImageBitmap ? t.f(d$1) : t.h(d$1)),
							cacheControl: i$3.cacheControl,
							expires: i$3.expires
						});
					} catch (t$1) {
						delete e$2.abortController, a$2(t$1);
					} finally {
						o$1--, n$1();
					}
					var d$1;
				})), n$1 = () => {
					const e$2 = (() => {
						for (const e$3 of Object.keys(a$1)) if (a$1[e$3]()) return !0;
						return !1;
					})() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
					for (let t$1 = o$1; t$1 < e$2 && i$1.length > 0; t$1++) {
						const e$3 = i$1.shift();
						e$3.abortController.signal.aborted ? t$1-- : s$1(e$3);
					}
				}, c$1 = (e$2, i$2) => new Promise(((o$2, r$2) => {
					const a$2 = new Image(), s$2 = e$2.url, n$2 = e$2.credentials;
					n$2 && "include" === n$2 ? a$2.crossOrigin = "use-credentials" : (n$2 && "same-origin" === n$2 || !t.d(s$2)) && (a$2.crossOrigin = "anonymous"), i$2.signal.addEventListener("abort", (() => {
						a$2.src = "", r$2(t.c());
					})), a$2.fetchPriority = "high", a$2.onload = () => {
						a$2.onerror = a$2.onload = null, o$2({ data: a$2 });
					}, a$2.onerror = () => {
						a$2.onerror = a$2.onload = null, i$2.signal.aborted || r$2(/* @__PURE__ */ new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
					}, a$2.src = s$2;
				}));
			}(p || (p = {})), p.resetRequestQueue();
			class m {
				constructor(e$1) {
					this._transformRequestFn = null != e$1 ? e$1 : null;
				}
				transformRequest(e$1, t$1) {
					return this._transformRequestFn && this._transformRequestFn(e$1, t$1) || { url: e$1 };
				}
				setTransformRequest(e$1) {
					this._transformRequestFn = e$1;
				}
			}
			function f(e$1) {
				const t$1 = [];
				if ("string" == typeof e$1) t$1.push({
					id: "default",
					url: e$1
				});
				else if (e$1 && e$1.length > 0) {
					const i$1 = [];
					for (const { id: o$1, url: r$1 } of e$1) {
						const e$2 = `${o$1}${r$1}`;
						-1 === i$1.indexOf(e$2) && (i$1.push(e$2), t$1.push({
							id: o$1,
							url: r$1
						}));
					}
				}
				return t$1;
			}
			function g(e$1, t$1, i$1) {
				try {
					const o$1 = new URL(e$1);
					return o$1.pathname += `${t$1}${i$1}`, o$1.toString();
				} catch (t$2) {
					throw new Error(`Invalid sprite URL "${e$1}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
				}
			}
			function v(e$1) {
				const { userImage: t$1 } = e$1;
				return !!(t$1 && t$1.render && t$1.render()) && (e$1.data.replace(new Uint8Array(t$1.data.buffer)), !0);
			}
			class b extends t.E {
				constructor() {
					super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				isLoaded() {
					return this.loaded;
				}
				setLoaded(e$1) {
					if (this.loaded !== e$1 && (this.loaded = e$1, e$1)) {
						for (const { ids: e$2, promiseResolve: t$1 } of this.requestors) t$1(this._getImagesForIds(e$2));
						this.requestors = [];
					}
				}
				getImage(e$1) {
					const i$1 = this.images[e$1];
					if (i$1 && !i$1.data && i$1.spriteData) {
						const e$2 = i$1.spriteData;
						i$1.data = new t.R({
							width: e$2.width,
							height: e$2.height
						}, e$2.context.getImageData(e$2.x, e$2.y, e$2.width, e$2.height).data), i$1.spriteData = null;
					}
					return i$1;
				}
				addImage(e$1, t$1) {
					if (this.images[e$1]) throw new Error(`Image id ${e$1} already exist, use updateImage instead`);
					this._validate(e$1, t$1) && (this.images[e$1] = t$1);
				}
				_validate(e$1, i$1) {
					let o$1 = !0;
					const r$1 = i$1.data || i$1.spriteData;
					return this._validateStretch(i$1.stretchX, r$1 && r$1.width) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchX" value`))), o$1 = !1), this._validateStretch(i$1.stretchY, r$1 && r$1.height) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "stretchY" value`))), o$1 = !1), this._validateContent(i$1.content, i$1) || (this.fire(new t.k(/* @__PURE__ */ new Error(`Image "${e$1}" has invalid "content" value`))), o$1 = !1), o$1;
				}
				_validateStretch(e$1, t$1) {
					if (!e$1) return !0;
					let i$1 = 0;
					for (const o$1 of e$1) {
						if (o$1[0] < i$1 || o$1[1] < o$1[0] || t$1 < o$1[1]) return !1;
						i$1 = o$1[1];
					}
					return !0;
				}
				_validateContent(e$1, t$1) {
					if (!e$1) return !0;
					if (4 !== e$1.length) return !1;
					const i$1 = t$1.spriteData, o$1 = i$1 && i$1.width || t$1.data.width, r$1 = i$1 && i$1.height || t$1.data.height;
					return !(e$1[0] < 0 || o$1 < e$1[0] || e$1[1] < 0 || r$1 < e$1[1] || e$1[2] < 0 || o$1 < e$1[2] || e$1[3] < 0 || r$1 < e$1[3] || e$1[2] < e$1[0] || e$1[3] < e$1[1]);
				}
				updateImage(e$1, t$1, i$1 = !0) {
					const o$1 = this.getImage(e$1);
					if (i$1 && (o$1.data.width !== t$1.data.width || o$1.data.height !== t$1.data.height)) throw new Error(`size mismatch between old image (${o$1.data.width}x${o$1.data.height}) and new image (${t$1.data.width}x${t$1.data.height}).`);
					t$1.version = o$1.version + 1, this.images[e$1] = t$1, this.updatedImages[e$1] = !0;
				}
				removeImage(e$1) {
					const t$1 = this.images[e$1];
					delete this.images[e$1], delete this.patterns[e$1], t$1.userImage && t$1.userImage.onRemove && t$1.userImage.onRemove();
				}
				listImages() {
					return Object.keys(this.images);
				}
				getImages(e$1) {
					return new Promise(((t$1, i$1) => {
						let o$1 = !0;
						if (!this.isLoaded()) for (const t$2 of e$1) this.images[t$2] || (o$1 = !1);
						this.isLoaded() || o$1 ? t$1(this._getImagesForIds(e$1)) : this.requestors.push({
							ids: e$1,
							promiseResolve: t$1
						});
					}));
				}
				_getImagesForIds(e$1) {
					const i$1 = {};
					for (const o$1 of e$1) {
						let e$2 = this.getImage(o$1);
						e$2 || (this.fire(new t.l("styleimagemissing", { id: o$1 })), e$2 = this.getImage(o$1)), e$2 ? i$1[o$1] = {
							data: e$2.data.clone(),
							pixelRatio: e$2.pixelRatio,
							sdf: e$2.sdf,
							version: e$2.version,
							stretchX: e$2.stretchX,
							stretchY: e$2.stretchY,
							content: e$2.content,
							textFitWidth: e$2.textFitWidth,
							textFitHeight: e$2.textFitHeight,
							hasRenderCallback: Boolean(e$2.userImage && e$2.userImage.render)
						} : t.w(`Image "${o$1}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
					}
					return i$1;
				}
				getPixelSize() {
					const { width: e$1, height: t$1 } = this.atlasImage;
					return {
						width: e$1,
						height: t$1
					};
				}
				getPattern(e$1) {
					const i$1 = this.patterns[e$1], o$1 = this.getImage(e$1);
					if (!o$1) return null;
					if (i$1 && i$1.position.version === o$1.version) return i$1.position;
					if (i$1) i$1.position.version = o$1.version;
					else {
						const i$2 = {
							w: o$1.data.width + 2,
							h: o$1.data.height + 2,
							x: 0,
							y: 0
						}, r$1 = new t.I(i$2, o$1);
						this.patterns[e$1] = {
							bin: i$2,
							position: r$1
						};
					}
					return this._updatePatternAtlas(), this.patterns[e$1].position;
				}
				bind(e$1) {
					const i$1 = e$1.gl;
					this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.T(e$1, this.atlasImage, i$1.RGBA), this.atlasTexture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas() {
					const e$1 = [];
					for (const t$1 in this.patterns) e$1.push(this.patterns[t$1].bin);
					const { w: i$1, h: o$1 } = t.p(e$1), r$1 = this.atlasImage;
					r$1.resize({
						width: i$1 || 1,
						height: o$1 || 1
					});
					for (const e$2 in this.patterns) {
						const { bin: i$2 } = this.patterns[e$2], o$2 = i$2.x + 1, a$1 = i$2.y + 1, s$1 = this.getImage(e$2).data, n$1 = s$1.width, l$1 = s$1.height;
						t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2,
							y: a$1
						}, {
							width: n$1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: l$1 - 1
						}, {
							x: o$2,
							y: a$1 - 1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2,
							y: a$1 + l$1
						}, {
							width: n$1,
							height: 1
						}), t.R.copy(s$1, r$1, {
							x: n$1 - 1,
							y: 0
						}, {
							x: o$2 - 1,
							y: a$1
						}, {
							width: 1,
							height: l$1
						}), t.R.copy(s$1, r$1, {
							x: 0,
							y: 0
						}, {
							x: o$2 + n$1,
							y: a$1
						}, {
							width: 1,
							height: l$1
						});
					}
					this.dirty = !0;
				}
				beginFrame() {
					this.callbackDispatchedThisFrame = {};
				}
				dispatchRenderCallbacks(e$1) {
					for (const i$1 of e$1) {
						if (this.callbackDispatchedThisFrame[i$1]) continue;
						this.callbackDispatchedThisFrame[i$1] = !0;
						const e$2 = this.getImage(i$1);
						e$2 || t.w(`Image with ID: "${i$1}" was not found`), v(e$2) && this.updateImage(i$1, e$2);
					}
				}
			}
			const x = 0x56bc75e2d63100000;
			function y(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				for (let c$1 = t$1; c$1 < t$1 + o$1; c$1++) w(e$1, i$1 * a$1 + c$1, a$1, r$1, s$1, n$1, l$1);
				for (let c$1 = i$1; c$1 < i$1 + r$1; c$1++) w(e$1, c$1 * a$1 + t$1, 1, o$1, s$1, n$1, l$1);
			}
			function w(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
				a$1[0] = 0, s$1[0] = -x, s$1[1] = x, r$1[0] = e$1[t$1];
				for (let n$1 = 1, l$1 = 0, c$1 = 0; n$1 < o$1; n$1++) {
					r$1[n$1] = e$1[t$1 + n$1 * i$1];
					const o$2 = n$1 * n$1;
					do {
						const e$2 = a$1[l$1];
						c$1 = (r$1[n$1] - r$1[e$2] + o$2 - e$2 * e$2) / (n$1 - e$2) / 2;
					} while (c$1 <= s$1[l$1] && --l$1 > -1);
					l$1++, a$1[l$1] = n$1, s$1[l$1] = c$1, s$1[l$1 + 1] = x;
				}
				for (let n$1 = 0, l$1 = 0; n$1 < o$1; n$1++) {
					for (; s$1[l$1 + 1] < n$1;) l$1++;
					const o$2 = a$1[l$1], c$1 = n$1 - o$2;
					e$1[t$1 + n$1 * i$1] = r$1[o$2] + c$1 * c$1;
				}
			}
			class T {
				constructor(e$1, t$1, i$1) {
					this.requestManager = e$1, this.localIdeographFontFamily = t$1, this.entries = {}, this.lang = i$1;
				}
				setURL(e$1) {
					this.url = e$1;
				}
				getGlyphs(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = [];
						for (const i$2 in e$1) for (const o$2 of e$1[i$2]) t$1.push(this._getAndCacheGlyphsPromise(i$2, o$2));
						const i$1 = yield Promise.all(t$1), o$1 = {};
						for (const { stack: e$2, id: t$2, glyph: r$1 } of i$1) o$1[e$2] || (o$1[e$2] = {}), o$1[e$2][t$2] = r$1 && {
							id: r$1.id,
							bitmap: r$1.bitmap.clone(),
							metrics: r$1.metrics
						};
						return o$1;
					}));
				}
				_getAndCacheGlyphsPromise(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						let t$1 = this.entries[e$1];
						t$1 || (t$1 = this.entries[e$1] = {
							glyphs: {},
							requests: {},
							ranges: {}
						});
						let o$1 = t$1.glyphs[i$1];
						if (void 0 !== o$1) return {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						if (o$1 = this._tinySDF(t$1, e$1, i$1), o$1) return t$1.glyphs[i$1] = o$1, {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						const r$1 = Math.floor(i$1 / 256);
						if (256 * r$1 > 65535) throw new Error("glyphs > 65535 not supported");
						if (t$1.ranges[r$1]) return {
							stack: e$1,
							id: i$1,
							glyph: o$1
						};
						if (!this.url) throw new Error("glyphsUrl is not set");
						if (!t$1.requests[r$1]) {
							const i$2 = T.loadGlyphRange(e$1, r$1, this.url, this.requestManager);
							t$1.requests[r$1] = i$2;
						}
						const a$1 = yield t$1.requests[r$1];
						for (const e$2 in a$1) this._doesCharSupportLocalGlyph(+e$2) || (t$1.glyphs[+e$2] = a$1[+e$2]);
						return t$1.ranges[r$1] = !0, {
							stack: e$1,
							id: i$1,
							glyph: a$1[i$1] || null
						};
					}));
				}
				_doesCharSupportLocalGlyph(e$1) {
					return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e$1)) || t.u["CJK Unified Ideographs"](e$1) || t.u["Hangul Syllables"](e$1) || t.u.Hiragana(e$1) || t.u.Katakana(e$1) || t.u["CJK Symbols and Punctuation"](e$1) || t.u["Halfwidth and Fullwidth Forms"](e$1));
				}
				_tinySDF(e$1, i$1, o$1) {
					const r$1 = this.localIdeographFontFamily;
					if (!r$1) return;
					if (!this._doesCharSupportLocalGlyph(o$1)) return;
					let a$1 = e$1.tinySDF;
					if (!a$1) {
						let t$1 = "400";
						/bold/i.test(i$1) ? t$1 = "900" : /medium/i.test(i$1) ? t$1 = "500" : /light/i.test(i$1) && (t$1 = "200"), a$1 = e$1.tinySDF = new T.TinySDF({
							fontSize: 48,
							buffer: 6,
							radius: 16,
							cutoff: .25,
							lang: this.lang,
							fontFamily: r$1,
							fontWeight: t$1
						});
					}
					const s$1 = a$1.draw(String.fromCharCode(o$1));
					return {
						id: o$1,
						bitmap: new t.q({
							width: s$1.width || 60,
							height: s$1.height || 60
						}, s$1.data),
						metrics: {
							width: s$1.glyphWidth / 2 || 24,
							height: s$1.glyphHeight / 2 || 24,
							left: s$1.glyphLeft / 2 + .5 || 0,
							top: s$1.glyphTop / 2 - 27.5 || -8,
							advance: s$1.glyphAdvance / 2 || 24,
							isDoubleResolution: !0
						}
					};
				}
			}
			T.loadGlyphRange = function(e$1, i$1, o$1, r$1) {
				return t._(this, void 0, void 0, (function* () {
					const a$1 = 256 * i$1, s$1 = a$1 + 255, n$1 = r$1.transformRequest(o$1.replace("{fontstack}", e$1).replace("{range}", `${a$1}-${s$1}`), "Glyphs"), l$1 = yield t.n(n$1, new AbortController());
					if (!l$1 || !l$1.data) throw new Error(`Could not load glyph range. range: ${i$1}, ${a$1}-${s$1}`);
					const c$1 = {};
					for (const e$2 of t.o(l$1.data)) c$1[e$2.id] = e$2;
					return c$1;
				}));
			}, T.TinySDF = class {
				constructor({ fontSize: e$1 = 24, buffer: t$1 = 3, radius: i$1 = 8, cutoff: o$1 = .25, fontFamily: r$1 = "sans-serif", fontWeight: a$1 = "normal", fontStyle: s$1 = "normal", lang: n$1 = null } = {}) {
					this.buffer = t$1, this.cutoff = o$1, this.radius = i$1, this.lang = n$1;
					const l$1 = this.size = e$1 + 4 * t$1, h$1 = this.ctx = this._createCanvas(l$1).getContext("2d", { willReadFrequently: !0 });
					h$1.font = `${s$1} ${a$1} ${e$1}px ${r$1}`, h$1.textBaseline = "alphabetic", h$1.textAlign = "left", h$1.fillStyle = "black", this.gridOuter = new Float64Array(l$1 * l$1), this.gridInner = new Float64Array(l$1 * l$1), this.f = new Float64Array(l$1), this.z = new Float64Array(l$1 + 1), this.v = new Uint16Array(l$1);
				}
				_createCanvas(e$1) {
					const t$1 = document.createElement("canvas");
					return t$1.width = t$1.height = e$1, t$1;
				}
				draw(e$1) {
					const { width: t$1, actualBoundingBoxAscent: i$1, actualBoundingBoxDescent: o$1, actualBoundingBoxLeft: r$1, actualBoundingBoxRight: a$1 } = this.ctx.measureText(e$1), s$1 = Math.ceil(i$1), n$1 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a$1 - r$1))), l$1 = Math.min(this.size - this.buffer, s$1 + Math.ceil(o$1)), c$1 = n$1 + 2 * this.buffer, h$1 = l$1 + 2 * this.buffer, u$1 = Math.max(c$1 * h$1, 0), d$1 = new Uint8ClampedArray(u$1), _$1 = {
						data: d$1,
						width: c$1,
						height: h$1,
						glyphWidth: n$1,
						glyphHeight: l$1,
						glyphTop: s$1,
						glyphLeft: 0,
						glyphAdvance: t$1
					};
					if (0 === n$1 || 0 === l$1) return _$1;
					const { ctx: p$1, buffer: m$1, gridInner: f$1, gridOuter: g$1 } = this;
					this.lang && (p$1.lang = this.lang), p$1.clearRect(m$1, m$1, n$1, l$1), p$1.fillText(e$1, m$1, m$1 + s$1);
					const v$1 = p$1.getImageData(m$1, m$1, n$1, l$1);
					g$1.fill(x, 0, u$1), f$1.fill(0, 0, u$1);
					for (let e$2 = 0; e$2 < l$1; e$2++) for (let t$2 = 0; t$2 < n$1; t$2++) {
						const i$2 = v$1.data[4 * (e$2 * n$1 + t$2) + 3] / 255;
						if (0 === i$2) continue;
						const o$2 = (e$2 + m$1) * c$1 + t$2 + m$1;
						if (1 === i$2) g$1[o$2] = 0, f$1[o$2] = x;
						else {
							const e$3 = .5 - i$2;
							g$1[o$2] = e$3 > 0 ? e$3 * e$3 : 0, f$1[o$2] = e$3 < 0 ? e$3 * e$3 : 0;
						}
					}
					y(g$1, 0, 0, c$1, h$1, c$1, this.f, this.v, this.z), y(f$1, m$1, m$1, n$1, l$1, c$1, this.f, this.v, this.z);
					for (let e$2 = 0; e$2 < u$1; e$2++) {
						const t$2 = Math.sqrt(g$1[e$2]) - Math.sqrt(f$1[e$2]);
						d$1[e$2] = Math.round(255 - 255 * (t$2 / this.radius + this.cutoff));
					}
					return _$1;
				}
			};
			class P {
				constructor() {
					this.specification = t.v.light.position;
				}
				possiblyEvaluate(e$1, i$1) {
					return t.B(e$1.expression.evaluate(i$1));
				}
				interpolate(e$1, i$1, o$1) {
					return {
						x: t.C.number(e$1.x, i$1.x, o$1),
						y: t.C.number(e$1.y, i$1.y, o$1),
						z: t.C.number(e$1.z, i$1.z, o$1)
					};
				}
			}
			let C;
			class I extends t.E {
				constructor(e$1) {
					super(), C = C || new t.r({
						anchor: new t.D(t.v.light.anchor),
						position: new P(),
						color: new t.D(t.v.light.color),
						intensity: new t.D(t.v.light.intensity)
					}), this._transitionable = new t.t(C, void 0), this.setLight(e$1), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e$1, i$1 = {}) {
					if (!this._validate(t.x, e$1, i$1)) for (const t$1 in e$1) {
						const i$2 = e$1[t$1];
						t$1.endsWith("-transition") ? this._transitionable.setTransition(t$1.slice(0, -11), i$2) : this._transitionable.setValue(t$1, i$2);
					}
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, o$1) {
					return (!o$1 || !1 !== o$1.validate) && t.y(this, e$1.call(t.z, {
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					}));
				}
			}
			const M = new t.r({
				"sky-color": new t.D(t.v.sky["sky-color"]),
				"horizon-color": new t.D(t.v.sky["horizon-color"]),
				"fog-color": new t.D(t.v.sky["fog-color"]),
				"fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]),
				"horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]),
				"sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]),
				"atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"])
			});
			class S extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.t(M, void 0), this.setSky(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0));
				}
				setSky(e$1, i$1 = {}) {
					if (!this._validate(t.G, e$1, i$1)) {
						e$1 || (e$1 = {
							"sky-color": "transparent",
							"horizon-color": "transparent",
							"fog-color": "transparent",
							"fog-ground-blend": 1,
							"atmosphere-blend": 0
						});
						for (const t$1 in e$1) {
							const i$2 = e$1[t$1];
							t$1.endsWith("-transition") ? this._transitionable.setTransition(t$1.slice(0, -11), i$2) : this._transitionable.setValue(t$1, i$2);
						}
					}
				}
				getSky() {
					return this._transitionable.serialize();
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				_validate(e$1, i$1, o$1 = {}) {
					return !1 !== (null == o$1 ? void 0 : o$1.validate) && t.y(this, e$1.call(t.z, t.e({
						value: i$1,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					})));
				}
				calculateFogBlendOpacity(e$1) {
					return e$1 < 60 ? 0 : e$1 < 70 ? (e$1 - 60) / 10 : 1;
				}
			}
			class E {
				constructor(e$1, t$1) {
					this.width = e$1, this.height = t$1, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
				}
				getDash(e$1, t$1) {
					const i$1 = e$1.join(",") + String(t$1);
					return this.dashEntry[i$1] || (this.dashEntry[i$1] = this.addDash(e$1, t$1)), this.dashEntry[i$1];
				}
				getDashRanges(e$1, t$1, i$1) {
					const o$1 = [];
					let r$1 = e$1.length % 2 == 1 ? -e$1[e$1.length - 1] * i$1 : 0, a$1 = e$1[0] * i$1, s$1 = !0;
					o$1.push({
						left: r$1,
						right: a$1,
						isDash: s$1,
						zeroLength: 0 === e$1[0]
					});
					let n$1 = e$1[0];
					for (let t$2 = 1; t$2 < e$1.length; t$2++) {
						s$1 = !s$1;
						const l$1 = e$1[t$2];
						r$1 = n$1 * i$1, n$1 += l$1, a$1 = n$1 * i$1, o$1.push({
							left: r$1,
							right: a$1,
							isDash: s$1,
							zeroLength: 0 === l$1
						});
					}
					return o$1;
				}
				addRoundDash(e$1, t$1, i$1) {
					const o$1 = t$1 / 2;
					for (let t$2 = -i$1; t$2 <= i$1; t$2++) {
						const r$1 = this.width * (this.nextRow + i$1 + t$2);
						let a$1 = 0, s$1 = e$1[a$1];
						for (let n$1 = 0; n$1 < this.width; n$1++) {
							n$1 / s$1.right > 1 && (s$1 = e$1[++a$1]);
							const l$1 = Math.abs(n$1 - s$1.left), c$1 = Math.abs(n$1 - s$1.right), h$1 = Math.min(l$1, c$1);
							let u$1;
							const d$1 = t$2 / i$1 * (o$1 + 1);
							if (s$1.isDash) {
								const e$2 = o$1 - Math.abs(d$1);
								u$1 = Math.sqrt(h$1 * h$1 + e$2 * e$2);
							} else u$1 = o$1 - Math.sqrt(h$1 * h$1 + d$1 * d$1);
							this.data[r$1 + n$1] = Math.max(0, Math.min(255, u$1 + 128));
						}
					}
				}
				addRegularDash(e$1) {
					for (let t$2 = e$1.length - 1; t$2 >= 0; --t$2) {
						const i$2 = e$1[t$2], o$2 = e$1[t$2 + 1];
						i$2.zeroLength ? e$1.splice(t$2, 1) : o$2 && o$2.isDash === i$2.isDash && (o$2.left = i$2.left, e$1.splice(t$2, 1));
					}
					const t$1 = e$1[0], i$1 = e$1[e$1.length - 1];
					t$1.isDash === i$1.isDash && (t$1.left = i$1.left - this.width, i$1.right = t$1.right + this.width);
					const o$1 = this.width * this.nextRow;
					let r$1 = 0, a$1 = e$1[r$1];
					for (let t$2 = 0; t$2 < this.width; t$2++) {
						t$2 / a$1.right > 1 && (a$1 = e$1[++r$1]);
						const i$2 = Math.abs(t$2 - a$1.left), s$1 = Math.abs(t$2 - a$1.right), n$1 = Math.min(i$2, s$1);
						this.data[o$1 + t$2] = Math.max(0, Math.min(255, (a$1.isDash ? n$1 : -n$1) + 128));
					}
				}
				addDash(e$1, i$1) {
					const o$1 = i$1 ? 7 : 0, r$1 = 2 * o$1 + 1;
					if (this.nextRow + r$1 > this.height) return t.w("LineAtlas out of space"), null;
					let a$1 = 0;
					for (let t$1 = 0; t$1 < e$1.length; t$1++) a$1 += e$1[t$1];
					if (0 !== a$1) {
						const t$1 = this.width / a$1, r$2 = this.getDashRanges(e$1, this.width, t$1);
						i$1 ? this.addRoundDash(r$2, t$1, o$1) : this.addRegularDash(r$2);
					}
					const s$1 = {
						y: this.nextRow + o$1,
						height: 2 * o$1,
						width: a$1
					};
					return this.nextRow += r$1, this.dirty = !0, s$1;
				}
				bind(e$1) {
					const t$1 = e$1.gl;
					this.texture ? (t$1.bindTexture(t$1.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t$1.texSubImage2D(t$1.TEXTURE_2D, 0, 0, 0, this.width, this.height, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data))) : (this.texture = t$1.createTexture(), t$1.bindTexture(t$1.TEXTURE_2D, this.texture), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_S, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_WRAP_T, t$1.REPEAT), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MIN_FILTER, t$1.LINEAR), t$1.texParameteri(t$1.TEXTURE_2D, t$1.TEXTURE_MAG_FILTER, t$1.LINEAR), t$1.texImage2D(t$1.TEXTURE_2D, 0, t$1.ALPHA, this.width, this.height, 0, t$1.ALPHA, t$1.UNSIGNED_BYTE, this.data));
				}
			}
			const R = "maplibre_preloaded_worker_pool";
			class z {
				constructor() {
					this.active = {};
				}
				acquire(e$1) {
					if (!this.workers) for (this.workers = []; this.workers.length < z.workerCount;) this.workers.push(new Worker(t.a.WORKER_URL));
					return this.active[e$1] = !0, this.workers.slice();
				}
				release(e$1) {
					delete this.active[e$1], 0 === this.numActive() && (this.workers.forEach(((e$2) => {
						e$2.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[R];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			const D = Math.floor(s.hardwareConcurrency / 2);
			let A, L;
			function k() {
				return A || (A = new z()), A;
			}
			z.workerCount = t.H(globalThis) ? Math.max(Math.min(D, 3), 1) : 1;
			class F {
				constructor(e$1, i$1) {
					this.workerPool = e$1, this.actors = [], this.currentActor = 0, this.id = i$1;
					const o$1 = this.workerPool.acquire(i$1);
					for (let e$2 = 0; e$2 < o$1.length; e$2++) {
						const r$1 = new t.J(o$1[e$2], i$1);
						r$1.name = `Worker ${e$2}`, this.actors.push(r$1);
					}
					if (!this.actors.length) throw new Error("No actors found");
				}
				broadcast(e$1, t$1) {
					const i$1 = [];
					for (const o$1 of this.actors) i$1.push(o$1.sendAsync({
						type: e$1,
						data: t$1
					}));
					return Promise.all(i$1);
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove(e$1 = !0) {
					this.actors.forEach(((e$2) => {
						e$2.remove();
					})), this.actors = [], e$1 && this.workerPool.release(this.id);
				}
				registerMessageHandler(e$1, t$1) {
					for (const i$1 of this.actors) i$1.registerMessageHandler(e$1, t$1);
				}
			}
			function B() {
				return L || (L = new F(k(), t.K), L.registerMessageHandler("GR", ((e$1, i$1, o$1) => t.m(i$1, o$1)))), L;
			}
			function O(e$1, i$1) {
				const o$1 = t.L();
				return t.M(o$1, o$1, [
					1,
					1,
					0
				]), t.N(o$1, o$1, [
					.5 * e$1.width,
					.5 * e$1.height,
					1
				]), e$1.calculatePosMatrix ? t.O(o$1, o$1, e$1.calculatePosMatrix(i$1.toUnwrapped())) : o$1;
			}
			function j(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
				var n$1;
				const l$1 = function(e$2, t$2, i$2) {
					if (e$2) for (const o$2 of e$2) {
						const e$3 = t$2[o$2];
						if (e$3 && e$3.source === i$2 && "fill-extrusion" === e$3.type) return !0;
					}
					else for (const e$3 in t$2) {
						const o$2 = t$2[e$3];
						if (o$2.source === i$2 && "fill-extrusion" === o$2.type) return !0;
					}
					return !1;
				}(null !== (n$1 = null == r$1 ? void 0 : r$1.layers) && void 0 !== n$1 ? n$1 : null, t$1, e$1.id), c$1 = a$1.maxPitchScaleFactor(), h$1 = e$1.tilesIn(o$1, c$1, l$1);
				h$1.sort(N);
				const u$1 = [];
				for (const o$2 of h$1) u$1.push({
					wrappedTileID: o$2.tileID.wrapped().key,
					queryResults: o$2.tile.queryRenderedFeatures(t$1, i$1, e$1._state, o$2.queryGeometry, o$2.cameraQueryGeometry, o$2.scale, r$1, a$1, c$1, O(e$1.transform, o$2.tileID), s$1 ? (e$2, t$2) => s$1(o$2.tileID, e$2, t$2) : void 0)
				});
				return function(e$2, t$2) {
					for (const i$2 in e$2) for (const o$2 of e$2[i$2]) U(o$2, t$2);
					return e$2;
				}(function(e$2) {
					const t$2 = {}, i$2 = {};
					for (const o$2 of e$2) {
						const e$3 = o$2.queryResults, r$2 = o$2.wrappedTileID, a$2 = i$2[r$2] = i$2[r$2] || {};
						for (const i$3 in e$3) {
							const o$3 = e$3[i$3], r$3 = a$2[i$3] = a$2[i$3] || {}, s$2 = t$2[i$3] = t$2[i$3] || [];
							for (const e$4 of o$3) r$3[e$4.featureIndex] || (r$3[e$4.featureIndex] = !0, s$2.push(e$4));
						}
					}
					return t$2;
				}(u$1), e$1);
			}
			function N(e$1, t$1) {
				const i$1 = e$1.tileID, o$1 = t$1.tileID;
				return i$1.overscaledZ - o$1.overscaledZ || i$1.canonical.y - o$1.canonical.y || i$1.wrap - o$1.wrap || i$1.canonical.x - o$1.canonical.x;
			}
			function U(e$1, t$1) {
				const i$1 = e$1.feature, o$1 = t$1.getFeatureState(i$1.layer["source-layer"], i$1.id);
				i$1.source = i$1.layer.source, i$1.layer["source-layer"] && (i$1.sourceLayer = i$1.layer["source-layer"]), i$1.state = o$1;
			}
			function Z(e$1, i$1, o$1) {
				return t._(this, void 0, void 0, (function* () {
					let r$1 = e$1;
					if (e$1.url ? r$1 = (yield t.j(i$1.transformRequest(e$1.url, "Source"), o$1)).data : yield s.frameAsync(o$1), !r$1) return null;
					const a$1 = t.Q(t.e(r$1, e$1), [
						"tiles",
						"minzoom",
						"maxzoom",
						"attribution",
						"bounds",
						"scheme",
						"tileSize",
						"encoding"
					]);
					return "vector_layers" in r$1 && r$1.vector_layers && (a$1.vectorLayerIds = r$1.vector_layers.map(((e$2) => e$2.id))), a$1;
				}));
			}
			class G {
				constructor(e$1, t$1) {
					e$1 && (t$1 ? this.setSouthWest(e$1).setNorthEast(t$1) : Array.isArray(e$1) && (4 === e$1.length ? this.setSouthWest([e$1[0], e$1[1]]).setNorthEast([e$1[2], e$1[3]]) : this.setSouthWest(e$1[0]).setNorthEast(e$1[1])));
				}
				setNorthEast(e$1) {
					return this._ne = e$1 instanceof t.S ? new t.S(e$1.lng, e$1.lat) : t.S.convert(e$1), this;
				}
				setSouthWest(e$1) {
					return this._sw = e$1 instanceof t.S ? new t.S(e$1.lng, e$1.lat) : t.S.convert(e$1), this;
				}
				extend(e$1) {
					const i$1 = this._sw, o$1 = this._ne;
					let r$1, a$1;
					if (e$1 instanceof t.S) r$1 = e$1, a$1 = e$1;
					else {
						if (!(e$1 instanceof G)) return Array.isArray(e$1) ? 4 === e$1.length || e$1.every(Array.isArray) ? this.extend(G.convert(e$1)) : this.extend(t.S.convert(e$1)) : e$1 && ("lng" in e$1 || "lon" in e$1) && "lat" in e$1 ? this.extend(t.S.convert(e$1)) : this;
						if (r$1 = e$1._sw, a$1 = e$1._ne, !r$1 || !a$1) return this;
					}
					return i$1 || o$1 ? (i$1.lng = Math.min(r$1.lng, i$1.lng), i$1.lat = Math.min(r$1.lat, i$1.lat), o$1.lng = Math.max(a$1.lng, o$1.lng), o$1.lat = Math.max(a$1.lat, o$1.lat)) : (this._sw = new t.S(r$1.lng, r$1.lat), this._ne = new t.S(a$1.lng, a$1.lat)), this;
				}
				getCenter() {
					return new t.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new t.S(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new t.S(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(e$1) {
					const { lng: i$1, lat: o$1 } = t.S.convert(e$1);
					let r$1 = this._sw.lng <= i$1 && i$1 <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (r$1 = this._sw.lng >= i$1 && i$1 >= this._ne.lng), this._sw.lat <= o$1 && o$1 <= this._ne.lat && r$1;
				}
				static convert(e$1) {
					return e$1 instanceof G ? e$1 : e$1 ? new G(e$1) : e$1;
				}
				static fromLngLat(e$1, i$1 = 0) {
					const o$1 = 360 * i$1 / 40075017, r$1 = o$1 / Math.cos(Math.PI / 180 * e$1.lat);
					return new G(new t.S(e$1.lng - r$1, e$1.lat - o$1), new t.S(e$1.lng + r$1, e$1.lat + o$1));
				}
				adjustAntiMeridian() {
					const e$1 = new t.S(this._sw.lng, this._sw.lat), i$1 = new t.S(this._ne.lng, this._ne.lat);
					return new G(e$1, e$1.lng > i$1.lng ? new t.S(i$1.lng + 360, i$1.lat) : i$1);
				}
			}
			class V {
				constructor(e$1, t$1, i$1) {
					this.bounds = G.convert(this.validateBounds(e$1)), this.minzoom = t$1 || 0, this.maxzoom = i$1 || 24;
				}
				validateBounds(e$1) {
					return Array.isArray(e$1) && 4 === e$1.length ? [
						Math.max(-180, e$1[0]),
						Math.max(-90, e$1[1]),
						Math.min(180, e$1[2]),
						Math.min(90, e$1[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				contains(e$1) {
					const i$1 = Math.pow(2, e$1.z), o$1 = Math.floor(t.V(this.bounds.getWest()) * i$1), r$1 = Math.floor(t.U(this.bounds.getNorth()) * i$1), a$1 = Math.ceil(t.V(this.bounds.getEast()) * i$1), s$1 = Math.ceil(t.U(this.bounds.getSouth()) * i$1);
					return e$1.x >= o$1 && e$1.x < a$1 && e$1.y >= r$1 && e$1.y < s$1;
				}
			}
			class $ extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					if (super(), this.id = e$1, this.dispatcher = o$1, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.Q(i$1, [
						"url",
						"scheme",
						"tileSize",
						"promoteId"
					])), this._options = t.e({ type: "vector" }, i$1), this._collectResourceTiming = i$1.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(r$1);
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const e$1 = yield Z(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e$1 && (t.e(this, e$1), e$1.bounds && (this.tileBounds = new V(e$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content"
							})));
						} catch (e$1) {
							this._tileJSONRequest = null, this._loaded = !0, this.fire(new t.k(e$1));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && this._tileJSONRequest.abort(), e$1(), this.load();
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				serialize() {
					return t.e({}, this._options);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i$1 = {
							request: this.map._requestManager.transformRequest(t$1, "Tile"),
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							tileSize: this.tileSize * e$1.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						i$1.request.collectResourceTiming = this._collectResourceTiming;
						let o$1 = "RT";
						if (e$1.actor && "expired" !== e$1.state) {
							if ("loading" === e$1.state) return new Promise(((t$2, i$2) => {
								e$1.reloadPromise = {
									resolve: t$2,
									reject: i$2
								};
							}));
						} else e$1.actor = this.dispatcher.getActor(), o$1 = "LT";
						e$1.abortController = new AbortController();
						try {
							const t$2 = yield e$1.actor.sendAsync({
								type: o$1,
								data: i$1
							}, e$1.abortController);
							if (delete e$1.abortController, e$1.aborted) return;
							this._afterTileLoadWorkerResponse(e$1, t$2);
						} catch (t$2) {
							if (delete e$1.abortController, e$1.aborted) return;
							if (t$2 && 404 !== t$2.status) throw t$2;
							this._afterTileLoadWorkerResponse(e$1, null);
						}
					}));
				}
				_afterTileLoadWorkerResponse(e$1, t$1) {
					if (t$1 && t$1.resourceTiming && (e$1.resourceTiming = t$1.resourceTiming), t$1 && this.map._refreshExpiredTiles && e$1.setExpiryData(t$1), e$1.loadVectorData(t$1, this.map.painter), e$1.reloadPromise) {
						const t$2 = e$1.reloadPromise;
						e$1.reloadPromise = null, this.loadTile(e$1).then(t$2.resolve).catch(t$2.reject);
					}
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.actor && (yield e$1.actor.sendAsync({
							type: "AT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), e$1.actor && (yield e$1.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class q extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					super(), this.id = e$1, this.dispatcher = o$1, this.setEventedParent(r$1), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, i$1), t.e(this, t.Q(i$1, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load() {
					return t._(this, arguments, void 0, (function* (e$1 = !1) {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							const i$1 = yield Z(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, i$1 && (t.e(this, i$1), i$1.bounds && (this.tileBounds = new V(i$1.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content",
								sourceDataChanged: e$1
							})));
						} catch (e$2) {
							this._tileJSONRequest = null, this._loaded = !0, this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
				}
				setSourceProperty(e$1) {
					this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e$1(), this.load(!0);
				}
				setTiles(e$1) {
					return this.setSourceProperty((() => {
						this._options.tiles = e$1;
					})), this;
				}
				setUrl(e$1) {
					return this.setSourceProperty((() => {
						this.url = e$1, this._options.url = e$1;
					})), this;
				}
				serialize() {
					return t.e({}, this._options);
				}
				hasTile(e$1) {
					return !this.tileBounds || this.tileBounds.contains(e$1.canonical);
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
						e$1.abortController = new AbortController();
						try {
							const o$1 = yield p.getImage(this.map._requestManager.transformRequest(i$1, "Tile"), e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (o$1 && o$1.data) {
								this.map._refreshExpiredTiles && (o$1.cacheControl || o$1.expires) && e$1.setExpiryData({
									cacheControl: o$1.cacheControl,
									expires: o$1.expires
								});
								const i$2 = this.map.painter.context, r$1 = i$2.gl, a$1 = o$1.data;
								e$1.texture = this.map.painter.getTileTexture(a$1.width), e$1.texture ? e$1.texture.update(a$1, { useMipmap: !0 }) : (e$1.texture = new t.T(i$2, a$1, r$1.RGBA, { useMipmap: !0 }), e$1.texture.bind(r$1.LINEAR, r$1.CLAMP_TO_EDGE, r$1.LINEAR_MIPMAP_NEAREST)), e$1.state = "loaded";
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController);
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.texture && this.map.painter.saveTileTexture(e$1.texture);
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class W extends q {
				constructor(e$1, i$1, o$1, r$1) {
					super(e$1, i$1, o$1, r$1), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i$1), this.encoding = i$1.encoding || "mapbox", this.redFactor = i$1.redFactor, this.greenFactor = i$1.greenFactor, this.blueFactor = i$1.blueFactor, this.baseShift = i$1.baseShift;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const i$1 = e$1.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o$1 = this.map._requestManager.transformRequest(i$1, "Tile");
						e$1.neighboringTiles = this._getNeighboringTiles(e$1.tileID), e$1.abortController = new AbortController();
						try {
							const i$2 = yield p.getImage(o$1, e$1.abortController, this.map._refreshExpiredTiles);
							if (delete e$1.abortController, e$1.aborted) return void (e$1.state = "unloaded");
							if (i$2 && i$2.data) {
								const o$2 = i$2.data;
								this.map._refreshExpiredTiles && (i$2.cacheControl || i$2.expires) && e$1.setExpiryData({
									cacheControl: i$2.cacheControl,
									expires: i$2.expires
								});
								const r$1 = t.b(o$2) && t.W() ? o$2 : yield this.readImageNow(o$2), a$1 = {
									type: this.type,
									uid: e$1.uid,
									source: this.id,
									rawImageData: r$1,
									encoding: this.encoding,
									redFactor: this.redFactor,
									greenFactor: this.greenFactor,
									blueFactor: this.blueFactor,
									baseShift: this.baseShift
								};
								if (!e$1.actor || "expired" === e$1.state) {
									e$1.actor = this.dispatcher.getActor();
									e$1.dem = yield e$1.actor.sendAsync({
										type: "LDT",
										data: a$1
									}), e$1.needsHillshadePrepare = !0, e$1.needsTerrainPrepare = !0, e$1.state = "loaded";
								}
							}
						} catch (t$1) {
							if (delete e$1.abortController, e$1.aborted) e$1.state = "unloaded";
							else if (t$1) throw e$1.state = "errored", t$1;
						}
					}));
				}
				readImageNow(e$1) {
					return t._(this, void 0, void 0, (function* () {
						if ("undefined" != typeof VideoFrame && t.X()) {
							const i$1 = e$1.width + 2, o$1 = e$1.height + 2;
							try {
								return new t.R({
									width: i$1,
									height: o$1
								}, yield t.Y(e$1, -1, -1, i$1, o$1));
							} catch (e$2) {}
						}
						return s.getImageData(e$1, 1);
					}));
				}
				_getNeighboringTiles(e$1) {
					const i$1 = e$1.canonical, o$1 = Math.pow(2, i$1.z), r$1 = (i$1.x - 1 + o$1) % o$1, a$1 = 0 === i$1.x ? e$1.wrap - 1 : e$1.wrap, s$1 = (i$1.x + 1 + o$1) % o$1, n$1 = i$1.x + 1 === o$1 ? e$1.wrap + 1 : e$1.wrap, l$1 = {};
					return l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y).key] = { backfilled: !1 }, i$1.y > 0 && (l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y - 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y - 1).key] = { backfilled: !1 }), i$1.y + 1 < o$1 && (l$1[new t.Z(e$1.overscaledZ, a$1, i$1.z, r$1, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, e$1.wrap, i$1.z, i$1.x, i$1.y + 1).key] = { backfilled: !1 }, l$1[new t.Z(e$1.overscaledZ, n$1, i$1.z, s$1, i$1.y + 1).key] = { backfilled: !1 }), l$1;
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.demTexture && this.map.painter.saveTileTexture(e$1.demTexture), e$1.fbo && (e$1.fbo.destroy(), delete e$1.fbo), e$1.dem && delete e$1.dem, delete e$1.neighboringTiles, e$1.state = "unloaded", e$1.actor && (yield e$1.actor.sendAsync({
							type: "RDT",
							data: {
								type: this.type,
								uid: e$1.uid,
								source: this.id
							}
						}));
					}));
				}
			}
			class H extends t.E {
				constructor(e$1, i$1, o$1, r$1) {
					super(), this.id = e$1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: i$1.data }, this.actor = o$1.getActor(), this.setEventedParent(r$1), this._data = i$1.data, this._options = t.e({}, i$1), this._collectResourceTiming = i$1.collectResourceTiming, void 0 !== i$1.maxzoom && (this.maxzoom = i$1.maxzoom), i$1.type && (this.type = i$1.type), i$1.attribution && (this.attribution = i$1.attribution), this.promoteId = i$1.promoteId, void 0 !== i$1.clusterMaxZoom && this.maxzoom <= i$1.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i$1.clusterMaxZoom}".`), this.workerOptions = t.e({
						source: this.id,
						cluster: i$1.cluster || !1,
						geojsonVtOptions: {
							buffer: this._pixelsToTileUnits(void 0 !== i$1.buffer ? i$1.buffer : 128),
							tolerance: this._pixelsToTileUnits(void 0 !== i$1.tolerance ? i$1.tolerance : .375),
							extent: t.$,
							maxZoom: this.maxzoom,
							lineMetrics: i$1.lineMetrics || !1,
							generateId: i$1.generateId || !1
						},
						superclusterOptions: {
							maxZoom: this._getClusterMaxZoom(i$1.clusterMaxZoom),
							minPoints: Math.max(2, i$1.clusterMinPoints || 2),
							extent: t.$,
							radius: this._pixelsToTileUnits(i$1.clusterRadius || 50),
							log: !1,
							generateId: i$1.generateId || !1
						},
						clusterProperties: i$1.clusterProperties,
						filter: i$1.filter
					}, i$1.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
				}
				_pixelsToTileUnits(e$1) {
					return e$1 * (t.$ / this.tileSize);
				}
				_getClusterMaxZoom(e$1) {
					const i$1 = e$1 ? Math.round(e$1) : this.maxzoom - 1;
					return Number.isInteger(e$1) || void 0 === e$1 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e$1}" rounded to "${i$1}"`), i$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						yield this._updateWorkerData();
					}));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				setData(e$1) {
					return this._data = e$1, this._pendingWorkerUpdate = { data: e$1 }, this._updateWorkerData(), this;
				}
				updateData(e$1) {
					return this._pendingWorkerUpdate.diff = t.a0(this._pendingWorkerUpdate.diff, e$1), this._updateWorkerData(), this;
				}
				getData() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = t.e({ type: this.type }, this.workerOptions);
						return this.actor.sendAsync({
							type: "GD",
							data: e$1
						});
					}));
				}
				getCoordinatesFromGeometry(e$1) {
					return "GeometryCollection" === e$1.type ? e$1.geometries.map(((e$2) => e$2.coordinates)).flat(Infinity) : e$1.coordinates.flat(Infinity);
				}
				getBounds() {
					return t._(this, void 0, void 0, (function* () {
						const e$1 = new G(), t$1 = yield this.getData();
						let i$1;
						switch (t$1.type) {
							case "FeatureCollection":
								i$1 = t$1.features.map(((e$2) => this.getCoordinatesFromGeometry(e$2.geometry))).flat(Infinity);
								break;
							case "Feature":
								i$1 = this.getCoordinatesFromGeometry(t$1.geometry);
								break;
							default: i$1 = this.getCoordinatesFromGeometry(t$1);
						}
						if (0 == i$1.length) return e$1;
						for (let t$2 = 0; t$2 < i$1.length - 1; t$2 += 2) e$1.extend([i$1[t$2], i$1[t$2 + 1]]);
						return e$1;
					}));
				}
				setClusterOptions(e$1) {
					return this.workerOptions.cluster = e$1.cluster, e$1 && (void 0 !== e$1.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e$1.clusterRadius)), void 0 !== e$1.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e$1.clusterMaxZoom))), this._updateWorkerData(), this;
				}
				getClusterExpansionZoom(e$1) {
					return this.actor.sendAsync({
						type: "GCEZ",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterChildren(e$1) {
					return this.actor.sendAsync({
						type: "GCC",
						data: {
							type: this.type,
							clusterId: e$1,
							source: this.id
						}
					});
				}
				getClusterLeaves(e$1, t$1, i$1) {
					return this.actor.sendAsync({
						type: "GCL",
						data: {
							type: this.type,
							source: this.id,
							clusterId: e$1,
							limit: t$1,
							offset: i$1
						}
					});
				}
				_updateWorkerData() {
					return t._(this, void 0, void 0, (function* () {
						if (this._isUpdatingWorker) return;
						const { data: e$1, diff: i$1 } = this._pendingWorkerUpdate;
						if (!e$1 && !i$1) return void t.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
						const o$1 = t.e({ type: this.type }, this.workerOptions);
						e$1 ? ("string" == typeof e$1 ? (o$1.request = this.map._requestManager.transformRequest(s.resolveURL(e$1), "Source"), o$1.request.collectResourceTiming = this._collectResourceTiming) : o$1.data = JSON.stringify(e$1), this._pendingWorkerUpdate.data = void 0) : i$1 && (o$1.dataDiff = i$1, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = !0, this.fire(new t.l("dataloading", { dataType: "source" }));
						try {
							const e$2 = yield this.actor.sendAsync({
								type: "LD",
								data: o$1
							});
							if (this._isUpdatingWorker = !1, this._removed || e$2.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this._data = e$2.data;
							let i$2 = null;
							e$2.resourceTiming && e$2.resourceTiming[this.id] && (i$2 = e$2.resourceTiming[this.id].slice(0));
							const r$1 = { dataType: "source" };
							this._collectResourceTiming && i$2 && i$2.length > 0 && t.e(r$1, { resourceTiming: i$2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, r$1), { sourceDataType: "content" })));
						} catch (e$2) {
							if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this.fire(new t.k(e$2));
						} finally {
							(this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
						}
					}));
				}
				loaded() {
					return !this._isUpdatingWorker && void 0 === this._pendingWorkerUpdate.data && void 0 === this._pendingWorkerUpdate.diff;
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = e$1.actor ? "RT" : "LT";
						e$1.actor = this.actor;
						const i$1 = {
							type: this.type,
							uid: e$1.uid,
							tileID: e$1.tileID,
							zoom: e$1.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						e$1.abortController = new AbortController();
						const o$1 = yield this.actor.sendAsync({
							type: t$1,
							data: i$1
						}, e$1.abortController);
						delete e$1.abortController, e$1.unloadVectorData(), e$1.aborted || e$1.loadVectorData(o$1, this.map.painter, "RT" === t$1);
					}));
				}
				abortTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.abortController && (e$1.abortController.abort(), delete e$1.abortController), e$1.aborted = !0;
					}));
				}
				unloadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						e$1.unloadVectorData(), yield this.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e$1.uid,
								type: this.type,
								source: this.id
							}
						});
					}));
				}
				onRemove() {
					this._removed = !0, this.actor.sendAsync({
						type: "RS",
						data: {
							type: this.type,
							source: this.id
						}
					});
				}
				serialize() {
					return t.e({}, this._options, {
						type: this.type,
						data: this._data
					});
				}
				hasTransition() {
					return !1;
				}
			}
			class X extends t.E {
				constructor(e$1, t$1, i$1, o$1) {
					super(), this.flippedWindingOrder = !1, this.id = e$1, this.dispatcher = i$1, this.coordinates = t$1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o$1), this.options = t$1;
				}
				load(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
						try {
							const t$1 = yield p.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
							this._request = null, this._loaded = !0, t$1 && t$1.data && (this.image = t$1.data, e$1 && (this.coordinates = e$1), this._finishLoading());
						} catch (e$2) {
							this._request = null, this._loaded = !0, this.fire(new t.k(e$2));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(e$1) {
					return e$1.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e$1.url, this.load(e$1.coordinates).finally((() => {
						this.texture = null;
					})), this) : this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(e$1) {
					this.map = e$1, this.load();
				}
				onRemove() {
					this._request && (this._request.abort(), this._request = null);
				}
				setCoordinates(e$1) {
					this.coordinates = e$1;
					const i$1 = e$1.map(t.a1.fromLngLat);
					var o$1;
					return this.tileID = function(e$2) {
						const i$2 = t.a2.fromPoints(e$2), o$2 = i$2.width(), r$1 = i$2.height(), a$1 = Math.max(o$2, r$1), s$1 = Math.max(0, Math.floor(-Math.log(a$1) / Math.LN2)), n$1 = Math.pow(2, s$1);
						return new t.a4(s$1, Math.floor((i$2.minX + i$2.maxX) / 2 * n$1), Math.floor((i$2.minY + i$2.maxY) / 2 * n$1));
					}(i$1), this.terrainTileRanges = this._getOverlappingTileRanges(i$1), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i$1.map(((e$2) => this.tileID.getTilePoint(e$2)._round())), this.flippedWindingOrder = ((o$1 = this.tileCoords)[1].x - o$1[0].x) * (o$1[2].y - o$1[0].y) - (o$1[1].y - o$1[0].y) * (o$1[2].x - o$1[0].x) < 0, this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || !this.image) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture || (this.texture = new t.T(e$1, this.image, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let o$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, o$1 = !0);
					}
					o$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				loadTile(e$1) {
					return t._(this, void 0, void 0, (function* () {
						this.tileID && this.tileID.equals(e$1.tileID.canonical) ? (this.tiles[String(e$1.tileID.wrap)] = e$1, e$1.buckets = {}) : e$1.state = "errored";
					}));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				_getOverlappingTileRanges(e$1) {
					const { minX: i$1, minY: o$1, maxX: r$1, maxY: a$1 } = t.a2.fromPoints(e$1), s$1 = {};
					for (let e$2 = 0; e$2 <= t.a3; e$2++) {
						const t$1 = Math.pow(2, e$2), n$1 = Math.floor(i$1 * t$1), l$1 = Math.floor(o$1 * t$1), c$1 = Math.floor(r$1 * t$1), h$1 = Math.floor(a$1 * t$1);
						s$1[e$2] = {
							minTileX: n$1,
							minTileY: l$1,
							maxTileX: c$1,
							maxTileY: h$1
						};
					}
					return s$1;
				}
			}
			class K extends X {
				constructor(e$1, t$1, i$1, o$1) {
					super(e$1, t$1, i$1, o$1), this.roundZoom = !0, this.type = "video", this.options = t$1;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1;
						const e$1 = this.options;
						this.urls = [];
						for (const t$1 of e$1.urls) this.urls.push(this.map._requestManager.transformRequest(t$1, "Source").url);
						try {
							const e$2 = yield t.a5(this.urls);
							if (this._loaded = !0, !e$2) return;
							this.video = e$2, this.video.loop = !0, this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading();
						} catch (e$2) {
							this.fire(new t.k(e$2));
						}
					}));
				}
				pause() {
					this.video && this.video.pause();
				}
				play() {
					this.video && this.video.play();
				}
				seek(e$1) {
					if (this.video) {
						const i$1 = this.video.seekable;
						e$1 < i$1.start(0) || e$1 > i$1.end(0) ? this.fire(new t.k(new t.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i$1.start(0)} and ${i$1.end(0)}-second mark.`))) : this.video.currentTime = e$1;
					}
				}
				getVideo() {
					return this.video;
				}
				onAdd(e$1) {
					this.map || (this.map = e$1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
				}
				prepare() {
					if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
					const e$1 = this.map.painter.context, i$1 = e$1.gl;
					this.texture ? this.video.paused || (this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE), i$1.texSubImage2D(i$1.TEXTURE_2D, 0, 0, 0, i$1.RGBA, i$1.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e$1, this.video, i$1.RGBA), this.texture.bind(i$1.LINEAR, i$1.CLAMP_TO_EDGE));
					let o$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, o$1 = !0);
					}
					o$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "video",
						urls: this.urls,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this.video && !this.video.paused;
				}
			}
			class Y extends X {
				constructor(e$1, i$1, o$1, r$1) {
					super(e$1, i$1, o$1, r$1), i$1.coordinates ? Array.isArray(i$1.coordinates) && 4 === i$1.coordinates.length && !i$1.coordinates.some(((e$2) => !Array.isArray(e$2) || 2 !== e$2.length || e$2.some(((e$3) => "number" != typeof e$3)))) || this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "missing required property \"coordinates\""))), i$1.animate && "boolean" != typeof i$1.animate && this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "optional \"animate\" property must be a boolean value"))), i$1.canvas ? "string" == typeof i$1.canvas || i$1.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new t.k(new t.a6(`sources.${e$1}`, null, "missing required property \"canvas\""))), this.options = i$1, this.animate = void 0 === i$1.animate || i$1.animate;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(/* @__PURE__ */ new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing && (this.prepare(), this._playing = !1);
						}, this._finishLoading());
					}));
				}
				getCanvas() {
					return this.canvas;
				}
				onAdd(e$1) {
					this.map = e$1, this.load(), this.canvas && this.animate && this.play();
				}
				onRemove() {
					this.pause();
				}
				prepare() {
					let e$1 = !1;
					if (this.canvas.width !== this.width && (this.width = this.canvas.width, e$1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e$1 = !0), this._hasInvalidDimensions()) return;
					if (0 === Object.keys(this.tiles).length) return;
					const i$1 = this.map.painter.context, o$1 = i$1.gl;
					this.texture ? (e$1 || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new t.T(i$1, this.canvas, o$1.RGBA, { premultiply: !0 });
					let r$1 = !1;
					for (const e$2 in this.tiles) {
						const t$1 = this.tiles[e$2];
						"loaded" !== t$1.state && (t$1.state = "loaded", t$1.texture = this.texture, r$1 = !0);
					}
					r$1 && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "canvas",
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this._playing;
				}
				_hasInvalidDimensions() {
					for (const e$1 of [this.canvas.width, this.canvas.height]) if (isNaN(e$1) || e$1 <= 0) return !0;
					return !1;
				}
			}
			const Q = {}, J = (e$1) => {
				switch (e$1) {
					case "geojson": return H;
					case "image": return X;
					case "raster": return q;
					case "raster-dem": return W;
					case "vector": return $;
					case "video": return K;
					case "canvas": return Y;
				}
				return Q[e$1];
			}, ee = "RTLPluginLoaded";
			class te extends t.E {
				constructor() {
					super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = B();
				}
				_syncState(e$1) {
					return this.status = e$1, this.dispatcher.broadcast("SRPS", {
						pluginStatus: e$1,
						pluginURL: this.url
					}).catch(((e$2) => {
						throw this.status = "error", e$2;
					}));
				}
				getRTLTextPluginStatus() {
					return this.status;
				}
				clearRTLTextPlugin() {
					this.status = "unavailable", this.url = null;
				}
				setRTLTextPlugin(e$1) {
					return t._(this, arguments, void 0, (function* (e$2, t$1 = !1) {
						if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
						if (this.url = s.resolveURL(e$2), !this.url) throw new Error(`requested url ${e$2} is invalid`);
						if ("unavailable" === this.status) {
							if (!t$1) return this._requestImport();
							this.status = "deferred", this._syncState(this.status);
						} else if ("requested" === this.status) return this._requestImport();
					}));
				}
				_requestImport() {
					return t._(this, void 0, void 0, (function* () {
						yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(ee));
					}));
				}
				lazyLoad() {
					"unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
				}
			}
			let ie = null;
			function oe() {
				return ie || (ie = new te()), ie;
			}
			class re {
				constructor(e$1, i$1) {
					this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e$1, this.uid = t.a7(), this.uses = 0, this.tileSize = i$1, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
				}
				registerFadeDuration(e$1) {
					const t$1 = e$1 + this.timeAdded;
					t$1 < this.fadeEndTime || (this.fadeEndTime = t$1);
				}
				wasRequested() {
					return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
				}
				clearTextures(e$1) {
					this.demTexture && e$1.saveTileTexture(this.demTexture), this.demTexture = null;
				}
				loadVectorData(e$1, i$1, o$1) {
					if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e$1) {
						e$1.featureIndex && (this.latestFeatureIndex = e$1.featureIndex, e$1.rawTileData ? (this.latestRawTileData = e$1.rawTileData, this.latestFeatureIndex.rawTileData = e$1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e$1.collisionBoxArray, this.buckets = function(e$2, t$1) {
							const i$2 = {};
							if (!t$1) return i$2;
							for (const o$2 of e$2) {
								const e$3 = o$2.layerIds.map(((e$4) => t$1.getLayer(e$4))).filter(Boolean);
								if (0 !== e$3.length) {
									o$2.layers = e$3, o$2.stateDependentLayerIds && (o$2.stateDependentLayers = o$2.stateDependentLayerIds.map(((t$2) => e$3.filter(((e$4) => e$4.id === t$2))[0])));
									for (const t$2 of e$3) i$2[t$2.id] = o$2;
								}
							}
							return i$2;
						}(e$1.buckets, null == i$1 ? void 0 : i$1.style), this.hasSymbolBuckets = !1;
						for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.a9) {
								if (this.hasSymbolBuckets = !0, !o$1) break;
								i$2.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e$2 in this.buckets) {
							const i$2 = this.buckets[e$2];
							if (i$2 instanceof t.a9 && i$2.hasRTLText) {
								this.hasRTLText = !0, oe().lazyLoad();
								break;
							}
						}
						this.queryPadding = 0;
						for (const e$2 in this.buckets) {
							const t$1 = this.buckets[e$2];
							this.queryPadding = Math.max(this.queryPadding, i$1.style.getLayer(e$2).queryRadius(t$1));
						}
						e$1.imageAtlas && (this.imageAtlas = e$1.imageAtlas), e$1.glyphAtlasImage && (this.glyphAtlasImage = e$1.glyphAtlasImage), this.dashPositions = e$1.dashPositions;
					} else this.collisionBoxArray = new t.a8();
				}
				unloadVectorData() {
					for (const e$1 in this.buckets) this.buckets[e$1].destroy();
					this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
				}
				getBucket(e$1) {
					return this.buckets[e$1.id];
				}
				upload(e$1) {
					for (const t$1 in this.buckets) {
						const i$2 = this.buckets[t$1];
						i$2.uploadPending() && i$2.upload(e$1);
					}
					const i$1 = e$1.gl;
					this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e$1, this.imageAtlas.image, i$1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e$1, this.glyphAtlasImage, i$1.ALPHA), this.glyphAtlasImage = null);
				}
				prepare(e$1) {
					this.imageAtlas && this.imageAtlas.patchUpdatedImages(e$1, this.imageAtlasTexture);
				}
				queryRenderedFeatures(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1) {
					return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
						queryGeometry: o$1,
						cameraQueryGeometry: r$1,
						scale: a$1,
						tileSize: this.tileSize,
						pixelPosMatrix: c$1,
						transform: n$1,
						params: s$1,
						queryPadding: this.queryPadding * l$1,
						getElevation: h$1
					}, e$1, t$1, i$1) : {};
				}
				querySourceFeatures(e$1, i$1) {
					const o$1 = this.latestFeatureIndex;
					if (!o$1 || !o$1.rawTileData) return;
					const r$1 = o$1.loadVTLayers(), a$1 = i$1 && i$1.sourceLayer ? i$1.sourceLayer : "", s$1 = r$1._geojsonTileLayer || r$1[a$1];
					if (!s$1) return;
					const n$1 = t.aa(null == i$1 ? void 0 : i$1.filter, null == i$1 ? void 0 : i$1.globalState), { z: l$1, x: c$1, y: h$1 } = this.tileID.canonical, u$1 = {
						z: l$1,
						x: c$1,
						y: h$1
					};
					for (let i$2 = 0; i$2 < s$1.length; i$2++) {
						const r$2 = s$1.feature(i$2);
						if (n$1.needGeometry) {
							const e$2 = t.ab(r$2, !0);
							if (!n$1.filter(new t.F(this.tileID.overscaledZ), e$2, this.tileID.canonical)) continue;
						} else if (!n$1.filter(new t.F(this.tileID.overscaledZ), r$2)) continue;
						const d$1 = o$1.getId(r$2, a$1), _$1 = new t.ac(r$2, l$1, c$1, h$1, d$1);
						_$1.tile = u$1, e$1.push(_$1);
					}
				}
				hasData() {
					return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
				}
				patternsLoaded() {
					return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
				}
				setExpiryData(e$1) {
					const i$1 = this.expirationTime;
					if (e$1.cacheControl) {
						const i$2 = t.ad(e$1.cacheControl);
						i$2["max-age"] && (this.expirationTime = Date.now() + 1e3 * i$2["max-age"]);
					} else e$1.expires && (this.expirationTime = new Date(e$1.expires).getTime());
					if (this.expirationTime) {
						const e$2 = Date.now();
						let t$1 = !1;
						if (this.expirationTime > e$2) t$1 = !1;
						else if (i$1) if (this.expirationTime < i$1) t$1 = !0;
						else {
							const o$1 = this.expirationTime - i$1;
							o$1 ? this.expirationTime = e$2 + Math.max(o$1, 3e4) : t$1 = !0;
						}
						else t$1 = !0;
						t$1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
				}
				setFeatureState(e$1, t$1) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e$1).length) return;
					const i$1 = this.latestFeatureIndex.loadVTLayers();
					for (const o$1 in this.buckets) {
						if (!t$1.style.hasLayer(o$1)) continue;
						const r$1 = this.buckets[o$1], a$1 = r$1.layers[0].sourceLayer || "_geojsonTileLayer", s$1 = i$1[a$1], n$1 = e$1[a$1];
						if (!s$1 || !n$1 || 0 === Object.keys(n$1).length) continue;
						r$1.update(n$1, s$1, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
						const l$1 = t$1 && t$1.style && t$1.style.getLayer(o$1);
						l$1 && (this.queryPadding = Math.max(this.queryPadding, l$1.queryRadius(r$1)));
					}
				}
				holdingForFade() {
					return void 0 !== this.symbolFadeHoldUntil;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.now();
				}
				clearFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setHoldDuration(e$1) {
					this.symbolFadeHoldUntil = s.now() + e$1;
				}
				setDependencies(e$1, t$1) {
					const i$1 = {};
					for (const e$2 of t$1) i$1[e$2] = !0;
					this.dependencies[e$1] = i$1;
				}
				hasDependency(e$1, t$1) {
					for (const i$1 of e$1) {
						const e$2 = this.dependencies[i$1];
						if (e$2) {
							for (const i$2 of t$1) if (e$2[i$2]) return !0;
						}
					}
					return !1;
				}
			}
			class ae {
				constructor(e$1, t$1) {
					this.max = e$1, this.onRemove = t$1, this.reset();
				}
				reset() {
					for (const e$1 in this.data) for (const t$1 of this.data[e$1]) t$1.timeout && clearTimeout(t$1.timeout), this.onRemove(t$1.value);
					return this.data = {}, this.order = [], this;
				}
				add(e$1, t$1, i$1) {
					const o$1 = e$1.wrapped().key;
					void 0 === this.data[o$1] && (this.data[o$1] = []);
					const r$1 = {
						value: t$1,
						timeout: void 0
					};
					if (void 0 !== i$1 && (r$1.timeout = setTimeout((() => {
						this.remove(e$1, r$1);
					}), i$1)), this.data[o$1].push(r$1), this.order.push(o$1), this.order.length > this.max) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				has(e$1) {
					return e$1.wrapped().key in this.data;
				}
				getAndRemove(e$1) {
					return this.has(e$1) ? this._getAndRemoveByKey(e$1.wrapped().key) : null;
				}
				_getAndRemoveByKey(e$1) {
					const t$1 = this.data[e$1].shift();
					return t$1.timeout && clearTimeout(t$1.timeout), 0 === this.data[e$1].length && delete this.data[e$1], this.order.splice(this.order.indexOf(e$1), 1), t$1.value;
				}
				getByKey(e$1) {
					const t$1 = this.data[e$1];
					return t$1 ? t$1[0].value : null;
				}
				get(e$1) {
					return this.has(e$1) ? this.data[e$1.wrapped().key][0].value : null;
				}
				remove(e$1, t$1) {
					if (!this.has(e$1)) return this;
					const i$1 = e$1.wrapped().key, o$1 = void 0 === t$1 ? 0 : this.data[i$1].indexOf(t$1), r$1 = this.data[i$1][o$1];
					return this.data[i$1].splice(o$1, 1), r$1.timeout && clearTimeout(r$1.timeout), 0 === this.data[i$1].length && delete this.data[i$1], this.onRemove(r$1.value), this.order.splice(this.order.indexOf(i$1), 1), this;
				}
				setMaxSize(e$1) {
					for (this.max = e$1; this.order.length > this.max;) {
						const e$2 = this._getAndRemoveByKey(this.order[0]);
						e$2 && this.onRemove(e$2);
					}
					return this;
				}
				filter(e$1) {
					const t$1 = [];
					for (const i$1 in this.data) for (const o$1 of this.data[i$1]) e$1(o$1.value) || t$1.push(o$1);
					for (const e$2 of t$1) this.remove(e$2.value.tileID, e$2);
				}
			}
			class se {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e$1, i$1, o$1) {
					const r$1 = String(i$1);
					if (this.stateChanges[e$1] = this.stateChanges[e$1] || {}, this.stateChanges[e$1][r$1] = this.stateChanges[e$1][r$1] || {}, t.e(this.stateChanges[e$1][r$1], o$1), null === this.deletedStates[e$1]) {
						this.deletedStates[e$1] = {};
						for (const t$1 in this.state[e$1]) t$1 !== r$1 && (this.deletedStates[e$1][t$1] = null);
					} else if (this.deletedStates[e$1] && null === this.deletedStates[e$1][r$1]) {
						this.deletedStates[e$1][r$1] = {};
						for (const t$1 in this.state[e$1][r$1]) o$1[t$1] || (this.deletedStates[e$1][r$1][t$1] = null);
					} else for (const t$1 in o$1) this.deletedStates[e$1] && this.deletedStates[e$1][r$1] && null === this.deletedStates[e$1][r$1][t$1] && delete this.deletedStates[e$1][r$1][t$1];
				}
				removeFeatureState(e$1, t$1, i$1) {
					if (null === this.deletedStates[e$1]) return;
					const o$1 = String(t$1);
					if (this.deletedStates[e$1] = this.deletedStates[e$1] || {}, i$1 && void 0 !== t$1) null !== this.deletedStates[e$1][o$1] && (this.deletedStates[e$1][o$1] = this.deletedStates[e$1][o$1] || {}, this.deletedStates[e$1][o$1][i$1] = null);
					else if (void 0 !== t$1) if (this.stateChanges[e$1] && this.stateChanges[e$1][o$1]) for (i$1 in this.deletedStates[e$1][o$1] = {}, this.stateChanges[e$1][o$1]) this.deletedStates[e$1][o$1][i$1] = null;
					else this.deletedStates[e$1][o$1] = null;
					else this.deletedStates[e$1] = null;
				}
				getState(e$1, i$1) {
					const o$1 = String(i$1), r$1 = t.e({}, (this.state[e$1] || {})[o$1], (this.stateChanges[e$1] || {})[o$1]);
					if (null === this.deletedStates[e$1]) return {};
					if (this.deletedStates[e$1]) {
						const t$1 = this.deletedStates[e$1][i$1];
						if (null === t$1) return {};
						for (const e$2 in t$1) delete r$1[e$2];
					}
					return r$1;
				}
				initializeTileState(e$1, t$1) {
					e$1.setFeatureState(this.state, t$1);
				}
				coalesceChanges(e$1, i$1) {
					const o$1 = {};
					for (const e$2 in this.stateChanges) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						for (const o$2 in this.stateChanges[e$2]) this.state[e$2][o$2] || (this.state[e$2][o$2] = {}), t.e(this.state[e$2][o$2], this.stateChanges[e$2][o$2]), i$2[o$2] = this.state[e$2][o$2];
						o$1[e$2] = i$2;
					}
					for (const e$2 in this.deletedStates) {
						this.state[e$2] = this.state[e$2] || {};
						const i$2 = {};
						if (null === this.deletedStates[e$2]) for (const t$1 in this.state[e$2]) i$2[t$1] = {}, this.state[e$2][t$1] = {};
						else for (const t$1 in this.deletedStates[e$2]) {
							if (null === this.deletedStates[e$2][t$1]) this.state[e$2][t$1] = {};
							else for (const i$3 of Object.keys(this.deletedStates[e$2][t$1])) delete this.state[e$2][t$1][i$3];
							i$2[t$1] = this.state[e$2][t$1];
						}
						o$1[e$2] = o$1[e$2] || {}, t.e(o$1[e$2], i$2);
					}
					if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o$1).length) for (const t$1 in e$1) e$1[t$1].setFeatureState(o$1, i$1);
				}
			}
			const ne = 89.25;
			function le(e$1, i$1) {
				const o$1 = t.ah(i$1.lat, -t.ai, t.ai);
				return new t.P(t.V(i$1.lng) * e$1, t.U(o$1) * e$1);
			}
			function ce(e$1, i$1) {
				return new t.a1(i$1.x / e$1, i$1.y / e$1).toLngLat();
			}
			function he(e$1) {
				return e$1.cameraToCenterDistance * Math.min(.85 * Math.tan(t.ae(90 - e$1.pitch)), Math.tan(t.ae(ne - e$1.pitch)));
			}
			function ue(e$1, i$1) {
				const o$1 = e$1.canonical, r$1 = i$1 / t.af(o$1.z), a$1 = o$1.x + Math.pow(2, o$1.z) * e$1.wrap, s$1 = t.ag(new Float64Array(16));
				return t.M(s$1, s$1, [
					a$1 * r$1,
					o$1.y * r$1,
					0
				]), t.N(s$1, s$1, [
					r$1 / t.$,
					r$1 / t.$,
					1
				]), s$1;
			}
			function de(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = t.a1.fromLngLat(e$1, i$1), n$1 = a$1 * t.aj(1, e$1.lat), l$1 = n$1 * Math.cos(t.ae(o$1)), c$1 = Math.sqrt(n$1 * n$1 - l$1 * l$1), h$1 = c$1 * Math.sin(t.ae(-r$1)), u$1 = c$1 * Math.cos(t.ae(-r$1));
				return new t.a1(s$1.x + h$1, s$1.y + u$1, s$1.z + l$1);
			}
			function _e(e$1, t$1, i$1) {
				const o$1 = t$1.intersectsFrustum(e$1);
				if (!i$1 || 0 === o$1) return o$1;
				const r$1 = t$1.intersectsPlane(i$1);
				return 0 === r$1 ? 0 : 2 === o$1 && 2 === r$1 ? 2 : 1;
			}
			function pe(e$1, t$1, i$1) {
				let o$1 = 0;
				const r$1 = (i$1 - t$1) / 10;
				for (let a$1 = 0; a$1 < 10; a$1++) o$1 += r$1 * Math.pow(Math.cos(t$1 + (a$1 + .5) / 10 * (i$1 - t$1)), e$1);
				return o$1;
			}
			function me(e$1, i$1) {
				return function(o$1, r$1, a$1, s$1, n$1) {
					const l$1 = 2 * ((e$1 - 1) / t.ak(Math.cos(t.ae(ne - n$1)) / Math.cos(t.ae(ne))) - 1), c$1 = Math.acos(a$1 / s$1), h$1 = 2 * pe(l$1 - 1, 0, t.ae(n$1 / 2)), u$1 = Math.min(t.ae(ne), c$1 + t.ae(n$1 / 2)), d$1 = pe(l$1 - 1, Math.min(u$1, c$1 - t.ae(n$1 / 2)), u$1), _$1 = Math.atan(r$1 / a$1), p$1 = Math.hypot(r$1, a$1);
					let m$1 = o$1;
					return m$1 += t.ak(s$1 / p$1 / Math.max(.5, Math.cos(t.ae(n$1 / 2)))), m$1 += l$1 * t.ak(Math.cos(_$1)) / 2, m$1 -= t.ak(Math.max(1, d$1 / h$1 / i$1)) / 2, m$1;
				};
			}
			const fe = me(9.314, 3);
			function ge(e$1, i$1) {
				const o$1 = (i$1.roundZoom ? Math.round : Math.floor)(e$1.zoom + t.ak(e$1.tileSize / i$1.tileSize));
				return Math.max(0, o$1);
			}
			function ve(e$1, i$1) {
				const o$1 = e$1.getCameraFrustum(), r$1 = e$1.getClippingPlane(), a$1 = e$1.screenPointToMercatorCoordinate(e$1.getCameraPoint()), s$1 = t.a1.fromLngLat(e$1.center, e$1.elevation);
				a$1.z = s$1.z + Math.cos(e$1.pitchInRadians) * e$1.cameraToCenterDistance / e$1.worldSize;
				const n$1 = e$1.getCoveringTilesDetailsProvider(), l$1 = n$1.allowVariableZoom(e$1, i$1), c$1 = ge(e$1, i$1), h$1 = i$1.minzoom || 0, u$1 = void 0 !== i$1.maxzoom ? i$1.maxzoom : e$1.maxZoom, d$1 = Math.min(Math.max(0, c$1), u$1), _$1 = Math.pow(2, d$1), p$1 = [
					_$1 * a$1.x,
					_$1 * a$1.y,
					0
				], m$1 = [
					_$1 * s$1.x,
					_$1 * s$1.y,
					0
				], f$1 = Math.hypot(s$1.x - a$1.x, s$1.y - a$1.y), g$1 = Math.abs(s$1.z - a$1.z), v$1 = Math.hypot(f$1, g$1), b$1 = (e$2) => ({
					zoom: 0,
					x: 0,
					y: 0,
					wrap: e$2,
					fullyVisible: !1
				}), x$1 = [], y$1 = [];
				if (e$1.renderWorldCopies && n$1.allowWorldCopies()) for (let e$2 = 1; e$2 <= 3; e$2++) x$1.push(b$1(-e$2)), x$1.push(b$1(e$2));
				for (x$1.push(b$1(0)); x$1.length > 0;) {
					const _$2 = x$1.pop(), f$2 = _$2.x, b$2 = _$2.y;
					let w$1 = _$2.fullyVisible;
					const T$1 = {
						x: f$2,
						y: b$2,
						z: _$2.zoom
					}, P$1 = n$1.getTileBoundingVolume(T$1, _$2.wrap, e$1.elevation, i$1);
					if (!w$1) {
						const e$2 = _e(o$1, P$1, r$1);
						if (0 === e$2) continue;
						w$1 = 2 === e$2;
					}
					const C$1 = n$1.distanceToTile2d(a$1.x, a$1.y, T$1, P$1);
					let I$1 = c$1;
					l$1 && (I$1 = (i$1.calculateTileZoom || fe)(e$1.zoom + t.ak(e$1.tileSize / i$1.tileSize), C$1, g$1, v$1, e$1.fov)), I$1 = (i$1.roundZoom ? Math.round : Math.floor)(I$1), I$1 = Math.max(0, I$1);
					const M$1 = Math.min(I$1, u$1);
					if (_$2.wrap = n$1.getWrap(s$1, T$1, _$2.wrap), _$2.zoom >= M$1) {
						if (_$2.zoom < h$1) continue;
						const e$2 = d$1 - _$2.zoom, o$2 = p$1[0] - .5 - (f$2 << e$2), r$2 = p$1[1] - .5 - (b$2 << e$2), a$2 = i$1.reparseOverscaled ? Math.max(_$2.zoom, I$1) : _$2.zoom;
						y$1.push({
							tileID: new t.Z(_$2.zoom === u$1 ? a$2 : _$2.zoom, _$2.wrap, _$2.zoom, f$2, b$2),
							distanceSq: t.al([m$1[0] - .5 - f$2, m$1[1] - .5 - b$2]),
							tileDistanceToCamera: Math.sqrt(o$2 * o$2 + r$2 * r$2)
						});
					} else for (let e$2 = 0; e$2 < 4; e$2++) x$1.push({
						zoom: _$2.zoom + 1,
						x: (f$2 << 1) + e$2 % 2,
						y: (b$2 << 1) + (e$2 >> 1),
						wrap: _$2.wrap,
						fullyVisible: w$1
					});
				}
				return y$1.sort(((e$2, t$1) => e$2.distanceSq - t$1.distanceSq)).map(((e$2) => e$2.tileID));
			}
			const be = t.a2.fromPoints([new t.P(0, 0), new t.P(t.$, t.$)]);
			class xe extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this.id = e$1, this.dispatcher = i$1, this.on("data", ((e$2) => this._dataHandler(e$2))), this.on("dataloading", (() => {
						this._sourceErrored = !1;
					})), this.on("error", (() => {
						this._sourceErrored = this._source.loaded();
					})), this._source = ((e$2, t$2, i$2, o$1) => {
						const r$1 = new (J(t$2.type))(e$2, t$2, i$2, o$1);
						if (r$1.id !== e$2) throw new Error(`Expected Source id to be ${e$2} instead of ${r$1.id}`);
						return r$1;
					})(e$1, t$1, i$1, this), this._tiles = {}, this._cache = new ae(0, ((e$2) => this._unloadTile(e$2))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new se(), this._didEmitContent = !1, this._updated = !1;
				}
				onAdd(e$1) {
					this.map = e$1, this._maxTileCacheSize = e$1 ? e$1._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e$1 ? e$1._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e$1);
				}
				onRemove(e$1) {
					this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e$1);
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded) return !1;
					if (!this._source.loaded()) return !1;
					if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return !0;
					if (!this._updated) return !1;
					for (const e$1 in this._tiles) {
						const t$1 = this._tiles[e$1];
						if ("loaded" !== t$1.state && "errored" !== t$1.state) return !1;
					}
					return !0;
				}
				getSource() {
					return this._source;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					const e$1 = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e$1 && this.reload(), this.transform && this.update(this.transform, this.terrain);
				}
				_loadTile(e$1, i$1, o$1) {
					return t._(this, void 0, void 0, (function* () {
						try {
							yield this._source.loadTile(e$1), this._tileLoaded(e$1, i$1, o$1);
						} catch (i$2) {
							e$1.state = "errored", 404 !== i$2.status ? this._source.fire(new t.k(i$2, { tile: e$1 })) : this.update(this.transform, this.terrain);
						}
					}));
				}
				_unloadTile(e$1) {
					this._source.unloadTile && this._source.unloadTile(e$1);
				}
				_abortTile(e$1) {
					this._source.abortTile && this._source.abortTile(e$1), this._source.fire(new t.l("dataabort", {
						tile: e$1,
						coord: e$1.tileID,
						dataType: "source"
					}));
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e$1) {
					this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						i$1.upload(e$1), i$1.prepare(this.map.style.imageManager);
					}
				}
				getIds() {
					return Object.values(this._tiles).map(((e$1) => e$1.tileID)).sort(ye).map(((e$1) => e$1.key));
				}
				getRenderableIds(e$1) {
					const i$1 = [];
					for (const t$1 in this._tiles) this._isIdRenderable(t$1, e$1) && i$1.push(this._tiles[t$1]);
					return e$1 ? i$1.sort(((e$2, i$2) => {
						const o$1 = e$2.tileID, r$1 = i$2.tileID, a$1 = new t.P(o$1.canonical.x, o$1.canonical.y)._rotate(-this.transform.bearingInRadians), s$1 = new t.P(r$1.canonical.x, r$1.canonical.y)._rotate(-this.transform.bearingInRadians);
						return o$1.overscaledZ - r$1.overscaledZ || s$1.y - a$1.y || s$1.x - a$1.x;
					})).map(((e$2) => e$2.tileID.key)) : i$1.map(((e$2) => e$2.tileID)).sort(ye).map(((e$2) => e$2.key));
				}
				hasRenderableParent(e$1) {
					const t$1 = this.findLoadedParent(e$1, 0);
					return !!t$1 && this._isIdRenderable(t$1.tileID.key);
				}
				_isIdRenderable(e$1, t$1) {
					return this._tiles[e$1] && this._tiles[e$1].hasData() && !this._coveredTiles[e$1] && (t$1 || !this._tiles[e$1].holdingForFade());
				}
				reload(e$1) {
					if (this._paused) this._shouldReloadOnResume = !0;
					else {
						this._cache.reset();
						for (const t$1 in this._tiles) e$1 ? this._reloadTile(t$1, "expired") : "errored" !== this._tiles[t$1].state && this._reloadTile(t$1, "reloading");
					}
				}
				_reloadTile(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const t$1 = this._tiles[e$1];
						t$1 && ("loading" !== t$1.state && (t$1.state = i$1), yield this._loadTile(t$1, e$1, i$1));
					}));
				}
				_tileLoaded(e$1, i$1, o$1) {
					e$1.timeAdded = s.now(), "expired" === o$1 && (e$1.refreshedUponExpiration = !0), this._setTileReloadTimer(i$1, e$1), "raster-dem" === this.getSource().type && e$1.dem && this._backfillDEM(e$1), this._state.initializeTileState(e$1, this.map ? this.map.painter : null), e$1.aborted || this._source.fire(new t.l("data", {
						dataType: "source",
						tile: e$1,
						coord: e$1.tileID
					}));
				}
				_backfillDEM(e$1) {
					const t$1 = this.getRenderableIds();
					for (let o$1 = 0; o$1 < t$1.length; o$1++) {
						const r$1 = t$1[o$1];
						if (e$1.neighboringTiles && e$1.neighboringTiles[r$1]) {
							const t$2 = this.getTileByID(r$1);
							i$1(e$1, t$2), i$1(t$2, e$1);
						}
					}
					function i$1(e$2, t$2) {
						e$2.needsHillshadePrepare = !0, e$2.needsTerrainPrepare = !0;
						let i$2 = t$2.tileID.canonical.x - e$2.tileID.canonical.x;
						const o$1 = t$2.tileID.canonical.y - e$2.tileID.canonical.y, r$1 = Math.pow(2, e$2.tileID.canonical.z), a$1 = t$2.tileID.key;
						0 === i$2 && 0 === o$1 || Math.abs(o$1) > 1 || (Math.abs(i$2) > 1 && (1 === Math.abs(i$2 + r$1) ? i$2 += r$1 : 1 === Math.abs(i$2 - r$1) && (i$2 -= r$1)), t$2.dem && e$2.dem && (e$2.dem.backfillBorder(t$2.dem, i$2, o$1), e$2.neighboringTiles && e$2.neighboringTiles[a$1] && (e$2.neighboringTiles[a$1].backfilled = !0)));
					}
				}
				getTile(e$1) {
					return this.getTileByID(e$1.key);
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				_retainLoadedChildren(e$1, t$1) {
					const i$1 = Object.values(e$1), o$1 = this._getLoadedDescendents(i$1), r$1 = {};
					for (const e$2 of i$1) {
						const i$2 = o$1[e$2.key];
						if (!(null == i$2 ? void 0 : i$2.length)) {
							r$1[e$2.key] = e$2;
							continue;
						}
						const a$1 = e$2.overscaledZ + xe.maxUnderzooming, s$1 = i$2.filter(((e$3) => e$3.tileID.overscaledZ <= a$1));
						if (!s$1.length) {
							r$1[e$2.key] = e$2;
							continue;
						}
						const n$1 = Math.min(...s$1.map(((e$3) => e$3.tileID.overscaledZ))), l$1 = s$1.filter(((e$3) => e$3.tileID.overscaledZ === n$1)).map(((e$3) => e$3.tileID));
						for (const e$3 of l$1) t$1[e$3.key] = e$3;
						this._areDescendentsComplete(l$1, n$1, e$2.overscaledZ) || (r$1[e$2.key] = e$2);
					}
					return r$1;
				}
				_getLoadedDescendents(e$1) {
					var t$1;
					const i$1 = {};
					for (const o$1 in this._tiles) {
						const r$1 = this._tiles[o$1];
						if (r$1.hasData()) for (const o$2 of e$1) r$1.tileID.isChildOf(o$2) && (i$1[t$1 = o$2.key] || (i$1[t$1] = [])).push(r$1);
					}
					return i$1;
				}
				_areDescendentsComplete(e$1, t$1, i$1) {
					return 1 === e$1.length && e$1[0].isOverscaled() ? e$1[0].overscaledZ === t$1 : Math.pow(4, t$1 - i$1) === e$1.length;
				}
				findLoadedParent(e$1, t$1) {
					if (e$1.key in this._loadedParentTiles) {
						const i$1 = this._loadedParentTiles[e$1.key];
						return i$1 && i$1.tileID.overscaledZ >= t$1 ? i$1 : null;
					}
					for (let i$1 = e$1.overscaledZ - 1; i$1 >= t$1; i$1--) {
						const t$2 = e$1.scaledTo(i$1), o$1 = this._getLoadedTile(t$2);
						if (o$1) return o$1;
					}
				}
				findLoadedSibling(e$1) {
					return this._getLoadedTile(e$1);
				}
				_getLoadedTile(e$1) {
					const t$1 = this._tiles[e$1.key];
					return t$1 && t$1.hasData() ? t$1 : this._cache.getByKey(e$1.wrapped().key);
				}
				updateCacheSize(e$1) {
					const i$1 = Math.ceil(e$1.width / this._source.tileSize) + 1, o$1 = Math.ceil(e$1.height / this._source.tileSize) + 1, r$1 = Math.floor(i$1 * o$1 * (null === this._maxTileCacheZoomLevels ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a$1 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r$1) : r$1;
					this._cache.setMaxSize(a$1);
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - (void 0 === this._prevLng ? e$1 : this._prevLng)) / 360);
					if (this._prevLng = e$1, t$1) {
						const e$2 = {};
						for (const i$1 in this._tiles) {
							const o$1 = this._tiles[i$1];
							o$1.tileID = o$1.tileID.unwrapTo(o$1.tileID.wrap + t$1), e$2[o$1.tileID.key] = o$1;
						}
						this._tiles = e$2;
						for (const e$3 in this._timers) clearTimeout(this._timers[e$3]), delete this._timers[e$3];
						for (const e$3 in this._tiles) this._setTileReloadTimer(e$3, this._tiles[e$3]);
					}
				}
				update(e$1, i$1) {
					if (!this._sourceLoaded || this._paused) return;
					let o$1;
					this.transform = e$1, this.terrain = i$1, this.updateCacheSize(e$1), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o$1 = e$1.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e$2) => new t.Z(e$2.canonical.z, e$2.wrap, e$2.canonical.z, e$2.canonical.x, e$2.canonical.y))) : (o$1 = ve(e$1, {
						tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: this._source.maxzoom,
						roundZoom: !this.usedForTerrain && this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled,
						terrain: i$1,
						calculateTileZoom: this._source.calculateTileZoom
					}), this._source.hasTile && (o$1 = o$1.filter(((e$2) => this._source.hasTile(e$2))))) : o$1 = [], this.usedForTerrain && (o$1 = this._addTerrainIdealTiles(o$1));
					const r$1 = ge(e$1, this._source), a$1 = Math.max(r$1 - xe.maxOverzooming, this._source.minzoom), s$1 = 0 === o$1.length && !this._updated && this._didEmitContent;
					this._updated = !0, s$1 && this.fire(new t.l("data", {
						sourceDataType: "idle",
						dataType: "source",
						sourceId: this.id
					}));
					const n$1 = this._updateRetainedTiles(o$1, r$1);
					we(this._source.type) && !i$1 && this._updateFadingTiles(n$1, a$1);
					for (const e$2 in n$1) this._tiles[e$2].clearFadeHold();
					const l$1 = t.am(this._tiles, n$1);
					for (const e$2 of l$1) {
						const t$1 = this._tiles[e$2];
						t$1.hasSymbolBuckets && !t$1.holdingForFade() ? t$1.setHoldDuration(this.map._fadeDuration) : t$1.hasSymbolBuckets && !t$1.symbolFadeFinished() || this._removeTile(e$2);
					}
					this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
				}
				_addTerrainIdealTiles(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) if (i$1.canonical.z > this._source.minzoom) {
						const e$2 = i$1.scaledTo(i$1.canonical.z - 1);
						t$1.push(e$2);
						const o$1 = i$1.scaledTo(Math.max(this._source.minzoom, Math.min(i$1.canonical.z, 5)));
						t$1.push(o$1);
					}
					return e$1.concat(t$1);
				}
				releaseSymbolFadeTiles() {
					for (const e$1 in this._tiles) this._tiles[e$1].holdingForFade() && this._removeTile(e$1);
				}
				_updateRetainedTiles(e$1, t$1) {
					var i$1;
					const o$1 = {}, r$1 = {}, a$1 = Math.max(t$1 - xe.maxOverzooming, this._source.minzoom);
					let s$1 = {};
					for (const t$2 of e$1) {
						const e$2 = this._addTile(t$2);
						o$1[t$2.key] = t$2, e$2.hasData() || (s$1[t$2.key] = t$2);
					}
					s$1 = this._retainLoadedChildren(s$1, o$1);
					for (const e$2 in s$1) {
						const t$2 = s$1[e$2];
						let n$1 = this._tiles[e$2], l$1 = null == n$1 ? void 0 : n$1.wasRequested();
						for (let e$3 = t$2.overscaledZ - 1; e$3 >= a$1; --e$3) {
							const a$2 = t$2.scaledTo(e$3);
							if (r$1[a$2.key]) break;
							if (r$1[a$2.key] = !0, n$1 = this.getTile(a$2), !n$1 && l$1 && (n$1 = this._addTile(a$2)), n$1) {
								const e$4 = n$1.hasData();
								if ((e$4 || !(null === (i$1 = this.map) || void 0 === i$1 ? void 0 : i$1.cancelPendingTileRequestsWhileZooming) || l$1) && (o$1[a$2.key] = a$2), l$1 = n$1.wasRequested(), e$4) break;
							}
						}
					}
					return o$1;
				}
				_updateFadingTiles(e$1, t$1) {
					const i$1 = {}, o$1 = {}, r$1 = Object.keys(e$1), a$1 = s.now();
					for (const s$1 of r$1) {
						const r$2 = e$1[s$1], n$1 = this._tiles[s$1];
						if (!n$1 || 0 !== n$1.fadeEndTime && n$1.fadeEndTime <= a$1) continue;
						const l$1 = this.findLoadedParent(r$2, t$1), c$1 = this.findLoadedSibling(r$2), h$1 = l$1 || c$1 || null;
						h$1 && (this._addTile(h$1.tileID), i$1[h$1.tileID.key] = h$1.tileID), o$1[s$1] = r$2;
					}
					this._retainLoadedChildren(o$1, e$1);
					for (const t$2 in i$1) e$1[t$2] || (this._coveredTiles[t$2] = !0, e$1[t$2] = i$1[t$2]);
				}
				_updateLoadedParentTileCache() {
					this._loadedParentTiles = {};
					for (const e$1 in this._tiles) {
						const t$1 = [];
						let i$1, o$1 = this._tiles[e$1].tileID;
						for (; o$1.overscaledZ > 0;) {
							if (o$1.key in this._loadedParentTiles) {
								i$1 = this._loadedParentTiles[o$1.key];
								break;
							}
							t$1.push(o$1.key);
							const e$2 = o$1.scaledTo(o$1.overscaledZ - 1);
							if (i$1 = this._getLoadedTile(e$2), i$1) break;
							o$1 = e$2;
						}
						for (const e$2 of t$1) this._loadedParentTiles[e$2] = i$1;
					}
				}
				_updateLoadedSiblingTileCache() {
					this._loadedSiblingTiles = {};
					for (const e$1 in this._tiles) {
						const t$1 = this._tiles[e$1].tileID, i$1 = this._getLoadedTile(t$1);
						this._loadedSiblingTiles[t$1.key] = i$1;
					}
				}
				_addTile(e$1) {
					let i$1 = this._tiles[e$1.key];
					if (i$1) return i$1;
					i$1 = this._cache.getAndRemove(e$1), i$1 && (this._setTileReloadTimer(e$1.key, i$1), i$1.tileID = e$1, this._state.initializeTileState(i$1, this.map ? this.map.painter : null), this._cacheTimers[e$1.key] && (clearTimeout(this._cacheTimers[e$1.key]), delete this._cacheTimers[e$1.key], this._setTileReloadTimer(e$1.key, i$1)));
					const o$1 = i$1;
					return i$1 || (i$1 = new re(e$1, this._source.tileSize * e$1.overscaleFactor()), this._loadTile(i$1, e$1.key, i$1.state)), i$1.uses++, this._tiles[e$1.key] = i$1, o$1 || this._source.fire(new t.l("dataloading", {
						tile: i$1,
						coord: i$1.tileID,
						dataType: "source"
					})), i$1;
				}
				_setTileReloadTimer(e$1, t$1) {
					e$1 in this._timers && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]);
					const i$1 = t$1.getExpiryTimeout();
					i$1 && (this._timers[e$1] = setTimeout((() => {
						this._reloadTile(e$1, "expired"), delete this._timers[e$1];
					}), i$1));
				}
				refreshTiles(e$1) {
					for (const t$1 in this._tiles) (this._isIdRenderable(t$1) || "errored" == this._tiles[t$1].state) && e$1.some(((e$2) => e$2.equals(this._tiles[t$1].tileID.canonical))) && this._reloadTile(t$1, "expired");
				}
				_removeTile(e$1) {
					const t$1 = this._tiles[e$1];
					t$1 && (t$1.uses--, delete this._tiles[e$1], this._timers[e$1] && (clearTimeout(this._timers[e$1]), delete this._timers[e$1]), t$1.uses > 0 || (t$1.hasData() && "reloading" !== t$1.state ? this._cache.add(t$1.tileID, t$1, t$1.getExpiryTimeout()) : (t$1.aborted = !0, this._abortTile(t$1), this._unloadTile(t$1))));
				}
				_dataHandler(e$1) {
					const t$1 = e$1.sourceDataType;
					"source" === e$1.dataType && "metadata" === t$1 && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e$1.dataType && "content" === t$1 && (this.reload(e$1.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
				}
				clearTiles() {
					this._shouldReloadOnResume = !1, this._paused = !1;
					for (const e$1 in this._tiles) this._removeTile(e$1);
					this._cache.reset();
				}
				tilesIn(e$1, i$1, o$1) {
					const r$1 = [], a$1 = this.transform;
					if (!a$1) return r$1;
					const s$1 = a$1.getCoveringTilesDetailsProvider().allowWorldCopies(), n$1 = o$1 ? a$1.getCameraQueryGeometry(e$1) : e$1, l$1 = (e$2) => a$1.screenPointToMercatorCoordinate(e$2, this.terrain), c$1 = this.transformBbox(e$1, l$1, !s$1), h$1 = this.transformBbox(n$1, l$1, !s$1), u$1 = this.getIds(), d$1 = t.a2.fromPoints(h$1);
					for (let e$2 = 0; e$2 < u$1.length; e$2++) {
						const o$2 = this._tiles[u$1[e$2]];
						if (o$2.holdingForFade()) continue;
						const n$2 = s$1 ? [o$2.tileID] : [o$2.tileID.unwrapTo(-1), o$2.tileID.unwrapTo(0)], l$2 = Math.pow(2, a$1.zoom - o$2.tileID.overscaledZ), _$1 = i$1 * o$2.queryPadding * t.$ / o$2.tileSize / l$2;
						for (const e$3 of n$2) {
							const i$2 = d$1.map(((i$3) => e$3.getTilePoint(new t.a1(i$3.x, i$3.y))));
							if (i$2.expandBy(_$1), i$2.intersects(be)) {
								const t$1 = c$1.map(((t$2) => e$3.getTilePoint(t$2))), i$3 = h$1.map(((t$2) => e$3.getTilePoint(t$2)));
								r$1.push({
									tile: o$2,
									tileID: s$1 ? e$3 : e$3.unwrapTo(0),
									queryGeometry: t$1,
									cameraQueryGeometry: i$3,
									scale: l$2
								});
							}
						}
					}
					return r$1;
				}
				transformBbox(e$1, i$1, o$1) {
					let r$1 = e$1.map(i$1);
					if (o$1) {
						const o$2 = t.a2.fromPoints(e$1);
						o$2.shrinkBy(.001 * Math.min(o$2.width(), o$2.height()));
						const a$1 = o$2.map(i$1);
						t.a2.fromPoints(r$1).covers(a$1) || (r$1 = r$1.map(((e$2) => e$2.x > .5 ? new t.a1(e$2.x - 1, e$2.y, e$2.z) : e$2)));
					}
					return r$1;
				}
				getVisibleCoordinates(e$1) {
					const t$1 = this.getRenderableIds(e$1).map(((e$2) => this._tiles[e$2].tileID));
					return this.transform && this.transform.populateCache(t$1), t$1;
				}
				hasTransition() {
					if (this._source.hasTransition()) return !0;
					if (we(this._source.type)) {
						const e$1 = s.now();
						for (const t$1 in this._tiles) if (this._tiles[t$1].fadeEndTime >= e$1) return !0;
					}
					return !1;
				}
				setFeatureState(e$1, t$1, i$1) {
					this._state.updateState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				removeFeatureState(e$1, t$1, i$1) {
					this._state.removeFeatureState(e$1 = e$1 || "_geojsonTileLayer", t$1, i$1);
				}
				getFeatureState(e$1, t$1) {
					return this._state.getState(e$1 = e$1 || "_geojsonTileLayer", t$1);
				}
				setDependencies(e$1, t$1, i$1) {
					const o$1 = this._tiles[e$1];
					o$1 && o$1.setDependencies(t$1, i$1);
				}
				reloadTilesForDependencies(e$1, t$1) {
					for (const i$1 in this._tiles) this._tiles[i$1].hasDependency(e$1, t$1) && this._reloadTile(i$1, "reloading");
					this._cache.filter(((i$1) => !i$1.hasDependency(e$1, t$1)));
				}
			}
			function ye(e$1, t$1) {
				const i$1 = Math.abs(2 * e$1.wrap) - +(e$1.wrap < 0), o$1 = Math.abs(2 * t$1.wrap) - +(t$1.wrap < 0);
				return e$1.overscaledZ - t$1.overscaledZ || o$1 - i$1 || t$1.canonical.y - e$1.canonical.y || t$1.canonical.x - e$1.canonical.x;
			}
			function we(e$1) {
				return "raster" === e$1 || "image" === e$1 || "video" === e$1;
			}
			xe.maxOverzooming = 10, xe.maxUnderzooming = 3;
			class Te {
				constructor(e$1, t$1) {
					this.reset(e$1, t$1);
				}
				reset(e$1, t$1) {
					this.points = e$1 || [], this._distances = [0];
					for (let e$2 = 1; e$2 < this.points.length; e$2++) this._distances[e$2] = this._distances[e$2 - 1] + this.points[e$2].dist(this.points[e$2 - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t$1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(e$1) {
					if (1 === this.points.length) return this.points[0];
					e$1 = t.ah(e$1, 0, 1);
					let i$1 = 1, o$1 = this._distances[i$1];
					const r$1 = e$1 * this.paddedLength + this.padding;
					for (; o$1 < r$1 && i$1 < this._distances.length;) o$1 = this._distances[++i$1];
					const a$1 = i$1 - 1, s$1 = this._distances[a$1], n$1 = o$1 - s$1, l$1 = n$1 > 0 ? (r$1 - s$1) / n$1 : 0;
					return this.points[a$1].mult(1 - l$1).add(this.points[i$1].mult(l$1));
				}
			}
			function Pe(e$1, t$1) {
				let i$1 = !0;
				return "always" === e$1 || "never" !== e$1 && "never" !== t$1 || (i$1 = !1), i$1;
			}
			class Ce {
				constructor(e$1, t$1, i$1) {
					const o$1 = this.boxCells = [], r$1 = this.circleCells = [];
					this.xCellCount = Math.ceil(e$1 / i$1), this.yCellCount = Math.ceil(t$1 / i$1);
					for (let e$2 = 0; e$2 < this.xCellCount * this.yCellCount; e$2++) o$1.push([]), r$1.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e$1, this.height = t$1, this.xScale = this.xCellCount / e$1, this.yScale = this.yCellCount / t$1, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e$1, t$1, i$1, o$1, r$1) {
					this._forEachCell(t$1, i$1, o$1, r$1, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e$1), this.bboxes.push(t$1), this.bboxes.push(i$1), this.bboxes.push(o$1), this.bboxes.push(r$1);
				}
				insertCircle(e$1, t$1, i$1, o$1) {
					this._forEachCell(t$1 - o$1, i$1 - o$1, t$1 + o$1, i$1 + o$1, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e$1), this.circles.push(t$1), this.circles.push(i$1), this.circles.push(o$1);
				}
				_insertBoxCell(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.boxCells[r$1].push(a$1);
				}
				_insertCircleCell(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.circleCells[r$1].push(a$1);
				}
				_query(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
					if (i$1 < 0 || e$1 > this.width || o$1 < 0 || t$1 > this.height) return [];
					const n$1 = [];
					if (e$1 <= 0 && t$1 <= 0 && this.width <= i$1 && this.height <= o$1) {
						if (r$1) return [{
							key: null,
							x1: e$1,
							y1: t$1,
							x2: i$1,
							y2: o$1
						}];
						for (let e$2 = 0; e$2 < this.boxKeys.length; e$2++) n$1.push({
							key: this.boxKeys[e$2],
							x1: this.bboxes[4 * e$2],
							y1: this.bboxes[4 * e$2 + 1],
							x2: this.bboxes[4 * e$2 + 2],
							y2: this.bboxes[4 * e$2 + 3]
						});
						for (let e$2 = 0; e$2 < this.circleKeys.length; e$2++) {
							const t$2 = this.circles[3 * e$2], i$2 = this.circles[3 * e$2 + 1], o$2 = this.circles[3 * e$2 + 2];
							n$1.push({
								key: this.circleKeys[e$2],
								x1: t$2 - o$2,
								y1: i$2 - o$2,
								x2: t$2 + o$2,
								y2: i$2 + o$2
							});
						}
					} else this._forEachCell(e$1, t$1, i$1, o$1, this._queryCell, n$1, {
						hitTest: r$1,
						overlapMode: a$1,
						seenUids: {
							box: {},
							circle: {}
						}
					}, s$1);
					return n$1;
				}
				query(e$1, t$1, i$1, o$1) {
					return this._query(e$1, t$1, i$1, o$1, !1, null);
				}
				hitTest(e$1, t$1, i$1, o$1, r$1, a$1) {
					return this._query(e$1, t$1, i$1, o$1, !0, r$1, a$1).length > 0;
				}
				hitTestCircle(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = e$1 - i$1, s$1 = e$1 + i$1, n$1 = t$1 - i$1, l$1 = t$1 + i$1;
					if (s$1 < 0 || a$1 > this.width || l$1 < 0 || n$1 > this.height) return !1;
					const c$1 = [];
					return this._forEachCell(a$1, n$1, s$1, l$1, this._queryCellCircle, c$1, {
						hitTest: !0,
						overlapMode: o$1,
						circle: {
							x: e$1,
							y: t$1,
							radius: i$1
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, r$1), c$1.length > 0;
				}
				_queryCell(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const { seenUids: l$1, hitTest: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const r$2 = this.bboxes;
						for (const s$2 of u$1) if (!l$1.box[s$2]) {
							l$1.box[s$2] = !0;
							const u$2 = 4 * s$2, d$2 = this.boxKeys[s$2];
							if (e$1 <= r$2[u$2 + 2] && t$1 <= r$2[u$2 + 3] && i$1 >= r$2[u$2 + 0] && o$1 >= r$2[u$2 + 1] && (!n$1 || n$1(d$2)) && (!c$1 || !Pe(h$1, d$2.overlapMode)) && (a$1.push({
								key: d$2,
								x1: r$2[u$2],
								y1: r$2[u$2 + 1],
								x2: r$2[u$2 + 2],
								y2: r$2[u$2 + 3]
							}), c$1)) return !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const r$2 = this.circles;
						for (const s$2 of d$1) if (!l$1.circle[s$2]) {
							l$1.circle[s$2] = !0;
							const u$2 = 3 * s$2, d$2 = this.circleKeys[s$2];
							if (this._circleAndRectCollide(r$2[u$2], r$2[u$2 + 1], r$2[u$2 + 2], e$1, t$1, i$1, o$1) && (!n$1 || n$1(d$2)) && (!c$1 || !Pe(h$1, d$2.overlapMode))) {
								const e$2 = r$2[u$2], t$2 = r$2[u$2 + 1], i$2 = r$2[u$2 + 2];
								if (a$1.push({
									key: d$2,
									x1: e$2 - i$2,
									y1: t$2 - i$2,
									x2: e$2 + i$2,
									y2: t$2 + i$2
								}), c$1) return !0;
							}
						}
					}
					return !1;
				}
				_queryCellCircle(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const { circle: l$1, seenUids: c$1, overlapMode: h$1 } = s$1, u$1 = this.boxCells[r$1];
					if (null !== u$1) {
						const e$2 = this.bboxes;
						for (const t$2 of u$1) if (!c$1.box[t$2]) {
							c$1.box[t$2] = !0;
							const i$2 = 4 * t$2, o$2 = this.boxKeys[t$2];
							if (this._circleAndRectCollide(l$1.x, l$1.y, l$1.radius, e$2[i$2 + 0], e$2[i$2 + 1], e$2[i$2 + 2], e$2[i$2 + 3]) && (!n$1 || n$1(o$2)) && !Pe(h$1, o$2.overlapMode)) return a$1.push(!0), !0;
						}
					}
					const d$1 = this.circleCells[r$1];
					if (null !== d$1) {
						const e$2 = this.circles;
						for (const t$2 of d$1) if (!c$1.circle[t$2]) {
							c$1.circle[t$2] = !0;
							const i$2 = 3 * t$2, o$2 = this.circleKeys[t$2];
							if (this._circlesCollide(e$2[i$2], e$2[i$2 + 1], e$2[i$2 + 2], l$1.x, l$1.y, l$1.radius) && (!n$1 || n$1(o$2)) && !Pe(h$1, o$2.overlapMode)) return a$1.push(!0), !0;
						}
					}
				}
				_forEachCell(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const l$1 = this._convertToXCellCoord(e$1), c$1 = this._convertToYCellCoord(t$1), h$1 = this._convertToXCellCoord(i$1), u$1 = this._convertToYCellCoord(o$1);
					for (let d$1 = l$1; d$1 <= h$1; d$1++) for (let l$2 = c$1; l$2 <= u$1; l$2++) if (r$1.call(this, e$1, t$1, i$1, o$1, this.xCellCount * l$2 + d$1, a$1, s$1, n$1)) return;
				}
				_convertToXCellCoord(e$1) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e$1 * this.xScale)));
				}
				_convertToYCellCoord(e$1) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e$1 * this.yScale)));
				}
				_circlesCollide(e$1, t$1, i$1, o$1, r$1, a$1) {
					const s$1 = o$1 - e$1, n$1 = r$1 - t$1, l$1 = i$1 + a$1;
					return l$1 * l$1 > s$1 * s$1 + n$1 * n$1;
				}
				_circleAndRectCollide(e$1, t$1, i$1, o$1, r$1, a$1, s$1) {
					const n$1 = (a$1 - o$1) / 2, l$1 = Math.abs(e$1 - (o$1 + n$1));
					if (l$1 > n$1 + i$1) return !1;
					const c$1 = (s$1 - r$1) / 2, h$1 = Math.abs(t$1 - (r$1 + c$1));
					if (h$1 > c$1 + i$1) return !1;
					if (l$1 <= n$1 || h$1 <= c$1) return !0;
					const u$1 = l$1 - n$1, d$1 = h$1 - c$1;
					return u$1 * u$1 + d$1 * d$1 <= i$1 * i$1;
				}
			}
			function Ie(e$1, i$1, r$1) {
				const a$1 = t.L();
				if (!e$1) {
					const { vecSouth: e$2, vecEast: t$1 } = Se(i$1), r$2 = o();
					r$2[0] = t$1[0], r$2[1] = t$1[1], r$2[2] = e$2[0], r$2[3] = e$2[1], s$1 = r$2, (d$1 = (l$1 = (n$1 = r$2)[0]) * (u$1 = n$1[3]) - (h$1 = n$1[2]) * (c$1 = n$1[1])) && (s$1[0] = u$1 * (d$1 = 1 / d$1), s$1[1] = -c$1 * d$1, s$1[2] = -h$1 * d$1, s$1[3] = l$1 * d$1), a$1[0] = r$2[0], a$1[1] = r$2[1], a$1[4] = r$2[2], a$1[5] = r$2[3];
				}
				var s$1, n$1, l$1, c$1, h$1, u$1, d$1;
				return t.N(a$1, a$1, [
					1 / r$1,
					1 / r$1,
					1
				]), a$1;
			}
			function Me(e$1, i$1, o$1, r$1) {
				if (e$1) {
					const e$2 = t.L();
					if (!i$1) {
						const { vecSouth: t$1, vecEast: i$2 } = Se(o$1);
						e$2[0] = i$2[0], e$2[1] = i$2[1], e$2[4] = t$1[0], e$2[5] = t$1[1];
					}
					return t.N(e$2, e$2, [
						r$1,
						r$1,
						1
					]), e$2;
				}
				return o$1.pixelsToClipSpaceMatrix;
			}
			function Se(e$1) {
				const i$1 = Math.cos(e$1.rollInRadians), o$1 = Math.sin(e$1.rollInRadians), r$1 = Math.cos(e$1.pitchInRadians), a$1 = Math.cos(e$1.bearingInRadians), s$1 = Math.sin(e$1.bearingInRadians), n$1 = t.ar();
				n$1[0] = -a$1 * r$1 * o$1 - s$1 * i$1, n$1[1] = -s$1 * r$1 * o$1 + a$1 * i$1;
				const l$1 = t.as(n$1);
				l$1 < 1e-9 ? t.at(n$1) : t.au(n$1, n$1, 1 / l$1);
				const c$1 = t.ar();
				c$1[0] = a$1 * r$1 * i$1 - s$1 * o$1, c$1[1] = s$1 * r$1 * i$1 + a$1 * o$1;
				const h$1 = t.as(c$1);
				return h$1 < 1e-9 ? t.at(c$1) : t.au(c$1, c$1, 1 / h$1), {
					vecEast: c$1,
					vecSouth: n$1
				};
			}
			function Ee(e$1, i$1, o$1, r$1) {
				let a$1;
				r$1 ? (a$1 = [
					e$1,
					i$1,
					r$1(e$1, i$1),
					1
				], t.aw(a$1, a$1, o$1)) : (a$1 = [
					e$1,
					i$1,
					0,
					1
				], qe(a$1, a$1, o$1));
				const s$1 = a$1[3];
				return {
					point: new t.P(a$1[0] / s$1, a$1[1] / s$1),
					signedDistanceFromCamera: s$1,
					isOccluded: !1
				};
			}
			function Re(e$1, t$1) {
				return .5 + e$1 / t$1 * .5;
			}
			function ze(e$1, t$1) {
				return e$1.x >= -t$1[0] && e$1.x <= t$1[0] && e$1.y >= -t$1[1] && e$1.y <= t$1[1];
			}
			function De(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) {
				const p$1 = o$1 ? e$1.textSizeData : e$1.iconSizeData, m$1 = t.an(p$1, i$1.transform.zoom), f$1 = [256 / i$1.width * 2 + 1, 256 / i$1.height * 2 + 1], g$1 = o$1 ? e$1.text.dynamicLayoutVertexArray : e$1.icon.dynamicLayoutVertexArray;
				g$1.clear();
				const v$1 = e$1.lineVertexArray, b$1 = o$1 ? e$1.text.placedSymbolArray : e$1.icon.placedSymbolArray, x$1 = i$1.transform.width / i$1.transform.height;
				let y$1 = !1;
				for (let o$2 = 0; o$2 < b$1.length; o$2++) {
					const w$1 = b$1.get(o$2);
					if (w$1.hidden || w$1.writingMode === t.ao.vertical && !y$1) {
						$e(w$1.numGlyphs, g$1);
						continue;
					}
					y$1 = !1;
					const T$1 = new t.P(w$1.anchorX, w$1.anchorY), P$1 = {
						getElevation: _$1,
						pitchedLabelPlaneMatrix: r$1,
						lineVertexArray: v$1,
						pitchWithMap: s$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: i$1.transform,
						tileAnchorPoint: T$1,
						unwrappedTileID: c$1,
						width: h$1,
						height: u$1,
						translation: d$1
					}, C$1 = Ne(w$1.anchorX, w$1.anchorY, P$1);
					if (!ze(C$1.point, f$1)) {
						$e(w$1.numGlyphs, g$1);
						continue;
					}
					const I$1 = Re(i$1.transform.cameraToCenterDistance, C$1.signedDistanceFromCamera), M$1 = t.ap(p$1, m$1, w$1), S$1 = s$1 ? M$1 * i$1.transform.getPitchedTextCorrection(w$1.anchorX, w$1.anchorY, c$1) / I$1 : M$1 * I$1, E$1 = ke({
						projectionContext: P$1,
						pitchedLabelPlaneMatrixInverse: a$1,
						symbol: w$1,
						fontSize: S$1,
						flip: !1,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$1,
						aspectRatio: x$1,
						rotateToLine: l$1
					});
					y$1 = E$1.useVertical, (E$1.notEnoughRoom || y$1 || E$1.needsFlipping && ke({
						projectionContext: P$1,
						pitchedLabelPlaneMatrixInverse: a$1,
						symbol: w$1,
						fontSize: S$1,
						flip: !0,
						keepUpright: n$1,
						glyphOffsetArray: e$1.glyphOffsetArray,
						dynamicLayoutVertexArray: g$1,
						aspectRatio: x$1,
						rotateToLine: l$1
					}).notEnoughRoom) && $e(w$1.numGlyphs, g$1);
				}
				o$1 ? e$1.text.dynamicLayoutVertexBuffer.updateData(g$1) : e$1.icon.dynamicLayoutVertexBuffer.updateData(g$1);
			}
			function Ae(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
				const l$1 = a$1.glyphStartIndex + a$1.numGlyphs, c$1 = a$1.lineStartIndex, h$1 = a$1.lineStartIndex + a$1.lineLength, u$1 = t$1.getoffsetX(a$1.glyphStartIndex), d$1 = t$1.getoffsetX(l$1 - 1), _$1 = Ge(e$1 * u$1, i$1, o$1, r$1, a$1.segment, c$1, h$1, n$1, s$1);
				if (!_$1) return null;
				const p$1 = Ge(e$1 * d$1, i$1, o$1, r$1, a$1.segment, c$1, h$1, n$1, s$1);
				return p$1 ? n$1.projectionCache.anyProjectionOccluded ? null : {
					first: _$1,
					last: p$1
				} : null;
			}
			function Le(e$1, i$1, o$1, r$1) {
				return e$1 === t.ao.horizontal && Math.abs(o$1.y - i$1.y) > Math.abs(o$1.x - i$1.x) * r$1 ? { useVertical: !0 } : (e$1 === t.ao.vertical ? i$1.y < o$1.y : i$1.x > o$1.x) ? { needsFlipping: !0 } : null;
			}
			function ke(e$1) {
				const { projectionContext: i$1, pitchedLabelPlaneMatrixInverse: o$1, symbol: r$1, fontSize: a$1, flip: s$1, keepUpright: n$1, glyphOffsetArray: l$1, dynamicLayoutVertexArray: c$1, aspectRatio: h$1, rotateToLine: u$1 } = e$1, d$1 = a$1 / 24, _$1 = r$1.lineOffsetX * d$1, p$1 = r$1.lineOffsetY * d$1;
				let m$1;
				if (r$1.numGlyphs > 1) {
					const e$2 = r$1.glyphStartIndex + r$1.numGlyphs, t$1 = r$1.lineStartIndex, a$2 = r$1.lineStartIndex + r$1.lineLength, c$2 = Ae(d$1, l$1, _$1, p$1, s$1, r$1, u$1, i$1);
					if (!c$2) return { notEnoughRoom: !0 };
					const f$1 = je(c$2.first.point.x, c$2.first.point.y, i$1, o$1), g$1 = je(c$2.last.point.x, c$2.last.point.y, i$1, o$1);
					if (n$1 && !s$1) {
						const e$3 = Le(r$1.writingMode, f$1, g$1, h$1);
						if (e$3) return e$3;
					}
					m$1 = [c$2.first];
					for (let o$2 = r$1.glyphStartIndex + 1; o$2 < e$2 - 1; o$2++) {
						const e$3 = Ge(d$1 * l$1.getoffsetX(o$2), _$1, p$1, s$1, r$1.segment, t$1, a$2, i$1, u$1);
						if (!e$3) return { notEnoughRoom: !0 };
						m$1.push(e$3);
					}
					m$1.push(c$2.last);
				} else {
					if (n$1 && !s$1) {
						const e$3 = Oe(i$1.tileAnchorPoint.x, i$1.tileAnchorPoint.y, i$1).point, a$2 = r$1.lineStartIndex + r$1.segment + 1, s$2 = new t.P(i$1.lineVertexArray.getx(a$2), i$1.lineVertexArray.gety(a$2)), n$2 = Oe(s$2.x, s$2.y, i$1), l$2 = n$2.signedDistanceFromCamera > 0 ? n$2.point : Fe(i$1.tileAnchorPoint, s$2, e$3, 1, i$1), c$2 = je(e$3.x, e$3.y, i$1, o$1), u$2 = je(l$2.x, l$2.y, i$1, o$1), d$2 = Le(r$1.writingMode, c$2, u$2, h$1);
						if (d$2) return d$2;
					}
					const e$2 = Ge(d$1 * l$1.getoffsetX(r$1.glyphStartIndex), _$1, p$1, s$1, r$1.segment, r$1.lineStartIndex, r$1.lineStartIndex + r$1.lineLength, i$1, u$1);
					if (!e$2 || i$1.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
					m$1 = [e$2];
				}
				for (const e$2 of m$1) t.av(c$1, e$2.point, e$2.angle);
				return {};
			}
			function Fe(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1.add(e$1.sub(t$1)._unit()), s$1 = Oe(a$1.x, a$1.y, r$1).point, n$1 = i$1.sub(s$1);
				return i$1.add(n$1._mult(o$1 / n$1.mag()));
			}
			function Be(e$1, i$1, o$1) {
				const r$1 = i$1.projectionCache;
				if (r$1.projections[e$1]) return r$1.projections[e$1];
				const a$1 = new t.P(i$1.lineVertexArray.getx(e$1), i$1.lineVertexArray.gety(e$1)), s$1 = Oe(a$1.x, a$1.y, i$1);
				if (s$1.signedDistanceFromCamera > 0) return r$1.projections[e$1] = s$1.point, r$1.anyProjectionOccluded = r$1.anyProjectionOccluded || s$1.isOccluded, s$1.point;
				const n$1 = e$1 - o$1.direction;
				return Fe(0 === o$1.distanceFromAnchor ? i$1.tileAnchorPoint : new t.P(i$1.lineVertexArray.getx(n$1), i$1.lineVertexArray.gety(n$1)), a$1, o$1.previousVertex, o$1.absOffsetX - o$1.distanceFromAnchor + 1, i$1);
			}
			function Oe(e$1, t$1, i$1) {
				const o$1 = e$1 + i$1.translation[0], r$1 = t$1 + i$1.translation[1];
				let a$1;
				return i$1.pitchWithMap ? (a$1 = Ee(o$1, r$1, i$1.pitchedLabelPlaneMatrix, i$1.getElevation), a$1.isOccluded = !1) : (a$1 = i$1.transform.projectTileCoordinates(o$1, r$1, i$1.unwrappedTileID, i$1.getElevation), a$1.point.x = (.5 * a$1.point.x + .5) * i$1.width, a$1.point.y = (.5 * -a$1.point.y + .5) * i$1.height), a$1;
			}
			function je(e$1, i$1, o$1, r$1) {
				if (o$1.pitchWithMap) {
					const a$1 = [
						e$1,
						i$1,
						0,
						1
					];
					return t.aw(a$1, a$1, r$1), o$1.transform.projectTileCoordinates(a$1[0] / a$1[3], a$1[1] / a$1[3], o$1.unwrappedTileID, o$1.getElevation).point;
				}
				return {
					x: e$1 / o$1.width * 2 - 1,
					y: 1 - i$1 / o$1.height * 2
				};
			}
			function Ne(e$1, t$1, i$1) {
				return i$1.transform.projectTileCoordinates(e$1, t$1, i$1.unwrappedTileID, i$1.getElevation);
			}
			function Ue(e$1, t$1, i$1) {
				return e$1._unit()._perp()._mult(t$1 * i$1);
			}
			function Ze(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1) {
				if (l$1.projectionCache.offsets[e$1]) return l$1.projectionCache.offsets[e$1];
				const h$1 = o$1.add(i$1);
				if (e$1 + c$1.direction < r$1 || e$1 + c$1.direction >= a$1) return l$1.projectionCache.offsets[e$1] = h$1, h$1;
				const u$1 = Be(e$1 + c$1.direction, l$1, c$1), d$1 = Ue(u$1.sub(o$1), n$1, c$1.direction), _$1 = o$1.add(d$1), p$1 = u$1.add(d$1);
				return l$1.projectionCache.offsets[e$1] = t.ax(s$1, h$1, _$1, p$1) || h$1, l$1.projectionCache.offsets[e$1];
			}
			function Ge(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = o$1 ? e$1 - t$1 : e$1 + t$1;
				let h$1 = c$1 > 0 ? 1 : -1, u$1 = 0;
				o$1 && (h$1 *= -1, u$1 = Math.PI), h$1 < 0 && (u$1 += Math.PI);
				let d$1, _$1 = h$1 > 0 ? a$1 + r$1 : a$1 + r$1 + 1;
				n$1.projectionCache.cachedAnchorPoint ? d$1 = n$1.projectionCache.cachedAnchorPoint : (d$1 = Oe(n$1.tileAnchorPoint.x, n$1.tileAnchorPoint.y, n$1).point, n$1.projectionCache.cachedAnchorPoint = d$1);
				let p$1, m$1, f$1 = d$1, g$1 = d$1, v$1 = 0, b$1 = 0;
				const x$1 = Math.abs(c$1), y$1 = [];
				let w$1;
				for (; v$1 + b$1 <= x$1;) {
					if (_$1 += h$1, _$1 < a$1 || _$1 >= s$1) return null;
					v$1 += b$1, g$1 = f$1, m$1 = p$1;
					const e$2 = {
						absOffsetX: x$1,
						direction: h$1,
						distanceFromAnchor: v$1,
						previousVertex: g$1
					};
					if (f$1 = Be(_$1, n$1, e$2), 0 === i$1) y$1.push(g$1), w$1 = f$1.sub(g$1);
					else {
						let t$2;
						const o$2 = f$1.sub(g$1);
						t$2 = 0 === o$2.mag() ? Ue(Be(_$1 + h$1, n$1, e$2).sub(f$1), i$1, h$1) : Ue(o$2, i$1, h$1), m$1 || (m$1 = g$1.add(t$2)), p$1 = Ze(_$1, t$2, f$1, a$1, s$1, m$1, i$1, n$1, e$2), y$1.push(m$1), w$1 = p$1.sub(m$1);
					}
					b$1 = w$1.mag();
				}
				const T$1 = w$1._mult((x$1 - v$1) / b$1)._add(m$1 || g$1), P$1 = u$1 + Math.atan2(f$1.y - g$1.y, f$1.x - g$1.x);
				return y$1.push(T$1), {
					point: T$1,
					angle: l$1 ? P$1 : 0,
					path: y$1
				};
			}
			const Ve = new Float32Array([
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0
			]);
			function $e(e$1, t$1) {
				for (let i$1 = 0; i$1 < e$1; i$1++) {
					const e$2 = t$1.length;
					t$1.resize(e$2 + 4), t$1.float32.set(Ve, 3 * e$2);
				}
			}
			function qe(e$1, t$1, i$1) {
				const o$1 = t$1[0], r$1 = t$1[1];
				return e$1[0] = i$1[0] * o$1 + i$1[4] * r$1 + i$1[12], e$1[1] = i$1[1] * o$1 + i$1[5] * r$1 + i$1[13], e$1[3] = i$1[3] * o$1 + i$1[7] * r$1 + i$1[15], e$1;
			}
			const We = 100;
			class He {
				constructor(e$1, t$1 = new Ce(e$1.width + 200, e$1.height + 200, 25), i$1 = new Ce(e$1.width + 200, e$1.height + 200, 25)) {
					this.transform = e$1, this.grid = t$1, this.ignoredGrid = i$1, this.pitchFactor = Math.cos(e$1.pitch * Math.PI / 180) * e$1.cameraToCenterDistance, this.screenRightBoundary = e$1.width + We, this.screenBottomBoundary = e$1.height + We, this.gridRightBoundary = e$1.width + 200, this.gridBottomBoundary = e$1.height + 200, this.perspectiveRatioCutoff = .6;
				}
				placeCollisionBox(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					const d$1 = this.projectAndGetPerspectiveRatio(e$1.anchorPointX + n$1[0], e$1.anchorPointY + n$1[1], r$1, c$1, u$1), _$1 = i$1 * d$1.perspectiveRatio;
					let p$1;
					if (a$1 || s$1) p$1 = this._projectCollisionBox(e$1, _$1, o$1, r$1, a$1, s$1, n$1, d$1, c$1, h$1, u$1);
					else {
						const t$2 = d$1.x + (h$1 ? h$1.x * _$1 : 0), i$2 = d$1.y + (h$1 ? h$1.y * _$1 : 0);
						p$1 = {
							allPointsOccluded: !1,
							box: [
								t$2 + e$1.x1 * _$1,
								i$2 + e$1.y1 * _$1,
								t$2 + e$1.x2 * _$1,
								i$2 + e$1.y2 * _$1
							]
						};
					}
					const [m$1, f$1, g$1, v$1] = p$1.box, b$1 = a$1 ? p$1.allPointsOccluded : d$1.isOccluded;
					let x$1 = b$1;
					return x$1 || (x$1 = d$1.perspectiveRatio < this.perspectiveRatioCutoff), x$1 || (x$1 = !this.isInsideGrid(m$1, f$1, g$1, v$1)), x$1 || "always" !== t$1 && this.grid.hitTest(m$1, f$1, g$1, v$1, t$1, l$1) ? {
						box: [
							m$1,
							f$1,
							g$1,
							v$1
						],
						placeable: !1,
						offscreen: !1,
						occluded: b$1
					} : {
						box: [
							m$1,
							f$1,
							g$1,
							v$1
						],
						placeable: !0,
						offscreen: this.isOffscreen(m$1, f$1, g$1, v$1),
						occluded: b$1
					};
				}
				placeCollisionCircles(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1) {
					const m$1 = [], f$1 = new t.P(i$1.anchorX, i$1.anchorY), g$1 = this.getPerspectiveRatio(f$1.x, f$1.y, s$1, p$1), v$1 = (c$1 ? a$1 * this.transform.getPitchedTextCorrection(i$1.anchorX, i$1.anchorY, s$1) / g$1 : a$1 * g$1) / t.aB, b$1 = {
						getElevation: p$1,
						pitchedLabelPlaneMatrix: n$1,
						lineVertexArray: o$1,
						pitchWithMap: c$1,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: this.transform,
						tileAnchorPoint: f$1,
						unwrappedTileID: s$1,
						width: this.transform.width,
						height: this.transform.height,
						translation: _$1
					}, x$1 = Ae(v$1, r$1, i$1.lineOffsetX * v$1, i$1.lineOffsetY * v$1, !1, i$1, !1, b$1);
					let y$1 = !1, w$1 = !1, T$1 = !0;
					if (x$1) {
						const i$2 = .5 * u$1 * g$1 + d$1, o$2 = new t.P(-100, -100), r$2 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), a$2 = new Te(), s$2 = x$1.first, n$2 = x$1.last;
						let _$2 = [];
						for (let e$2 = s$2.path.length - 1; e$2 >= 1; e$2--) _$2.push(s$2.path[e$2]);
						for (let e$2 = 1; e$2 < n$2.path.length; e$2++) _$2.push(n$2.path[e$2]);
						const p$2 = 2.5 * i$2;
						if (c$1) {
							const e$2 = this.projectPathToScreenSpace(_$2, b$1);
							_$2 = e$2.some(((e$3) => e$3.signedDistanceFromCamera <= 0)) ? [] : e$2.map(((e$3) => e$3.point));
						}
						let f$2 = [];
						if (_$2.length > 0) {
							const e$2 = _$2[0].clone(), i$3 = _$2[0].clone();
							for (let t$1 = 1; t$1 < _$2.length; t$1++) e$2.x = Math.min(e$2.x, _$2[t$1].x), e$2.y = Math.min(e$2.y, _$2[t$1].y), i$3.x = Math.max(i$3.x, _$2[t$1].x), i$3.y = Math.max(i$3.y, _$2[t$1].y);
							f$2 = e$2.x >= o$2.x && i$3.x <= r$2.x && e$2.y >= o$2.y && i$3.y <= r$2.y ? [_$2] : i$3.x < o$2.x || e$2.x > r$2.x || i$3.y < o$2.y || e$2.y > r$2.y ? [] : t.ay([_$2], o$2.x, o$2.y, r$2.x, r$2.y);
						}
						for (const t$1 of f$2) {
							a$2.reset(t$1, .25 * i$2);
							let o$3 = 0;
							o$3 = a$2.length <= .5 * i$2 ? 1 : Math.ceil(a$2.paddedLength / p$2) + 1;
							for (let t$2 = 0; t$2 < o$3; t$2++) {
								const r$3 = t$2 / Math.max(o$3 - 1, 1), s$3 = a$2.lerp(r$3), n$3 = s$3.x + We, c$2 = s$3.y + We;
								m$1.push(n$3, c$2, i$2, 0);
								const u$2 = n$3 - i$2, d$2 = c$2 - i$2, _$3 = n$3 + i$2, p$3 = c$2 + i$2;
								if (T$1 = T$1 && this.isOffscreen(u$2, d$2, _$3, p$3), w$1 = w$1 || this.isInsideGrid(u$2, d$2, _$3, p$3), "always" !== e$1 && this.grid.hitTestCircle(n$3, c$2, i$2, e$1, h$1) && (y$1 = !0, !l$1)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: y$1
								};
							}
						}
					}
					return {
						circles: !l$1 && y$1 || !w$1 || g$1 < this.perspectiveRatioCutoff ? [] : m$1,
						offscreen: T$1,
						collisionDetected: y$1
					};
				}
				projectPathToScreenSpace(e$1, i$1) {
					return function(e$2) {
						let t$1 = 0, i$2 = 0, o$1 = 0, r$1 = 0;
						for (let a$1 = 0; a$1 < e$2.length; a$1++) e$2[a$1].isOccluded ? (o$1 = a$1 + 1, r$1 = 0) : (r$1++, r$1 > i$2 && (i$2 = r$1, t$1 = o$1));
						return e$2.slice(t$1, t$1 + i$2);
					}(function(e$2, i$2) {
						const o$1 = t.L();
						return t.aq(o$1, i$2.pitchedLabelPlaneMatrix), e$2.map(((e$3) => {
							const t$1 = Ee(e$3.x, e$3.y, o$1, i$2.getElevation), r$1 = i$2.transform.projectTileCoordinates(t$1.point.x, t$1.point.y, i$2.unwrappedTileID, i$2.getElevation);
							return r$1.point.x = (.5 * r$1.point.x + .5) * i$2.width, r$1.point.y = (.5 * -r$1.point.y + .5) * i$2.height, r$1;
						}));
					}(e$1, i$1));
				}
				queryRenderedSymbols(e$1) {
					if (0 === e$1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
					const i$1 = [], o$1 = new t.a2();
					for (const r$2 of e$1) {
						const e$2 = new t.P(r$2.x + We, r$2.y + We);
						o$1.extend(e$2), i$1.push(e$2);
					}
					const { minX: r$1, minY: a$1, maxX: s$1, maxY: n$1 } = o$1, l$1 = this.grid.query(r$1, a$1, s$1, n$1).concat(this.ignoredGrid.query(r$1, a$1, s$1, n$1)), c$1 = {}, h$1 = {};
					for (const e$2 of l$1) {
						const o$2 = e$2.key;
						if (void 0 === c$1[o$2.bucketInstanceId] && (c$1[o$2.bucketInstanceId] = {}), c$1[o$2.bucketInstanceId][o$2.featureIndex]) continue;
						const r$2 = [
							new t.P(e$2.x1, e$2.y1),
							new t.P(e$2.x2, e$2.y1),
							new t.P(e$2.x2, e$2.y2),
							new t.P(e$2.x1, e$2.y2)
						];
						t.az(i$1, r$2) && (c$1[o$2.bucketInstanceId][o$2.featureIndex] = !0, void 0 === h$1[o$2.bucketInstanceId] && (h$1[o$2.bucketInstanceId] = []), h$1[o$2.bucketInstanceId].push(o$2.featureIndex));
					}
					return h$1;
				}
				insertCollisionBox(e$1, t$1, i$1, o$1, r$1, a$1) {
					(i$1 ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: o$1,
						featureIndex: r$1,
						collisionGroupID: a$1,
						overlapMode: t$1
					}, e$1[0], e$1[1], e$1[2], e$1[3]);
				}
				insertCollisionCircles(e$1, t$1, i$1, o$1, r$1, a$1) {
					const s$1 = i$1 ? this.ignoredGrid : this.grid, n$1 = {
						bucketInstanceId: o$1,
						featureIndex: r$1,
						collisionGroupID: a$1,
						overlapMode: t$1
					};
					for (let t$2 = 0; t$2 < e$1.length; t$2 += 4) s$1.insertCircle(n$1, e$1[t$2], e$1[t$2 + 1], e$1[t$2 + 2]);
				}
				projectAndGetPerspectiveRatio(e$1, i$1, o$1, r$1, a$1) {
					if (a$1) {
						let o$2;
						r$1 ? (o$2 = [
							e$1,
							i$1,
							r$1(e$1, i$1),
							1
						], t.aw(o$2, o$2, a$1)) : (o$2 = [
							e$1,
							i$1,
							0,
							1
						], qe(o$2, o$2, a$1));
						const s$1 = o$2[3];
						return {
							x: (o$2[0] / s$1 + 1) / 2 * this.transform.width + We,
							y: (-o$2[1] / s$1 + 1) / 2 * this.transform.height + We,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / s$1 * .5,
							isOccluded: !1,
							signedDistanceFromCamera: s$1
						};
					}
					{
						const t$1 = this.transform.projectTileCoordinates(e$1, i$1, o$1, r$1);
						return {
							x: (t$1.point.x + 1) / 2 * this.transform.width + We,
							y: (1 - t$1.point.y) / 2 * this.transform.height + We,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t$1.signedDistanceFromCamera * .5,
							isOccluded: t$1.isOccluded,
							signedDistanceFromCamera: t$1.signedDistanceFromCamera
						};
					}
				}
				getPerspectiveRatio(e$1, t$1, i$1, o$1) {
					const r$1 = this.transform.projectTileCoordinates(e$1, t$1, i$1, o$1);
					return .5 + this.transform.cameraToCenterDistance / r$1.signedDistanceFromCamera * .5;
				}
				isOffscreen(e$1, t$1, i$1, o$1) {
					return i$1 < We || e$1 >= this.screenRightBoundary || o$1 < We || t$1 > this.screenBottomBoundary;
				}
				isInsideGrid(e$1, t$1, i$1, o$1) {
					return i$1 >= 0 && e$1 < this.gridRightBoundary && o$1 >= 0 && t$1 < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					const e$1 = t.ag([]);
					return t.M(e$1, e$1, [
						-100,
						-100,
						0
					]), e$1;
				}
				_projectCollisionBox(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1) {
					let d$1 = 1, _$1 = 0, p$1 = 0, m$1 = 1;
					const f$1 = e$1.anchorPointX + n$1[0], g$1 = e$1.anchorPointY + n$1[1];
					if (s$1 && !a$1) {
						const e$2 = this.projectAndGetPerspectiveRatio(f$1 + 1, g$1, r$1, c$1, u$1), t$1 = e$2.x - l$1.x, i$2 = Math.atan((e$2.y - l$1.y) / t$1) + (t$1 < 0 ? Math.PI : 0), o$2 = Math.sin(i$2), a$2 = Math.cos(i$2);
						d$1 = a$2, _$1 = o$2, p$1 = -o$2, m$1 = a$2;
					} else if (!s$1 && a$1) {
						const e$2 = Se(this.transform);
						d$1 = e$2.vecEast[0], _$1 = e$2.vecEast[1], p$1 = e$2.vecSouth[0], m$1 = e$2.vecSouth[1];
					}
					let v$1 = l$1.x, b$1 = l$1.y, x$1 = i$1;
					a$1 && (v$1 = f$1, b$1 = g$1, x$1 = Math.pow(2, -(this.transform.zoom - o$1.overscaledZ)), x$1 *= this.transform.getPitchedTextCorrection(f$1, g$1, r$1), h$1 || (x$1 *= t.ah(.5 + l$1.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), h$1 && (v$1 += d$1 * h$1.x * x$1 + p$1 * h$1.y * x$1, b$1 += _$1 * h$1.x * x$1 + m$1 * h$1.y * x$1);
					const y$1 = e$1.x1 * x$1, w$1 = e$1.x2 * x$1, T$1 = (y$1 + w$1) / 2, P$1 = e$1.y1 * x$1, C$1 = e$1.y2 * x$1, I$1 = (P$1 + C$1) / 2, M$1 = [
						{
							offsetX: y$1,
							offsetY: P$1
						},
						{
							offsetX: T$1,
							offsetY: P$1
						},
						{
							offsetX: w$1,
							offsetY: P$1
						},
						{
							offsetX: w$1,
							offsetY: I$1
						},
						{
							offsetX: w$1,
							offsetY: C$1
						},
						{
							offsetX: T$1,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: C$1
						},
						{
							offsetX: y$1,
							offsetY: I$1
						}
					];
					let S$1 = [];
					for (const { offsetX: e$2, offsetY: i$2 } of M$1) S$1.push(new t.P(v$1 + d$1 * e$2 + p$1 * i$2, b$1 + _$1 * e$2 + m$1 * i$2));
					let E$1 = !1;
					if (a$1) {
						const e$2 = S$1.map(((e$3) => this.projectAndGetPerspectiveRatio(e$3.x, e$3.y, r$1, c$1, u$1)));
						E$1 = e$2.some(((e$3) => !e$3.isOccluded)), S$1 = e$2.map(((e$3) => new t.P(e$3.x, e$3.y)));
					} else E$1 = !0;
					return {
						box: t.aA(S$1),
						allPointsOccluded: !E$1
					};
				}
			}
			class Xe {
				constructor(e$1, t$1, i$1, o$1) {
					this.opacity = e$1 ? Math.max(0, Math.min(1, e$1.opacity + (e$1.placed ? t$1 : -t$1))) : o$1 && i$1 ? 1 : 0, this.placed = i$1;
				}
				isHidden() {
					return 0 === this.opacity && !this.placed;
				}
			}
			class Ke {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.text = new Xe(e$1 ? e$1.text : null, t$1, i$1, r$1), this.icon = new Xe(e$1 ? e$1.icon : null, t$1, o$1, r$1);
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class Ye {
				constructor(e$1, t$1, i$1) {
					this.text = e$1, this.icon = t$1, this.skipFade = i$1;
				}
			}
			class Qe {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.bucketInstanceId = e$1, this.featureIndex = t$1, this.sourceLayerIndex = i$1, this.bucketIndex = o$1, this.tileID = r$1;
				}
			}
			class Je {
				constructor(e$1) {
					this.crossSourceCollisions = e$1, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e$1) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e$1]) {
						const t$1 = ++this.maxGroupID;
						this.collisionGroups[e$1] = {
							ID: t$1,
							predicate: (e$2) => e$2.collisionGroupID === t$1
						};
					}
					return this.collisionGroups[e$1];
				}
			}
			function et(e$1, i$1, o$1, r$1, a$1) {
				const { horizontalAlign: s$1, verticalAlign: n$1 } = t.aH(e$1);
				return new t.P(-(s$1 - .5) * i$1 + r$1[0] * a$1, -(n$1 - .5) * o$1 + r$1[1] * a$1);
			}
			class tt {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.transform = e$1.clone(), this.terrain = t$1, this.collisionIndex = new He(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i$1, this.retainedQueryData = {}, this.collisionGroups = new Je(o$1), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = r$1, r$1 && (r$1.prevPlacement = void 0), this.placedOrientations = {};
				}
				_getTerrainElevationFunc(e$1) {
					const t$1 = this.terrain;
					return t$1 ? (i$1, o$1) => t$1.getElevation(e$1, i$1, o$1) : null;
				}
				getBucketParts(e$1, i$1, o$1, r$1) {
					const a$1 = o$1.getBucket(i$1), s$1 = o$1.latestFeatureIndex;
					if (!a$1 || !s$1 || i$1.id !== a$1.layerIds[0]) return;
					const n$1 = o$1.collisionBoxArray, l$1 = a$1.layers[0].layout, c$1 = a$1.layers[0].paint, h$1 = Math.pow(2, this.transform.zoom - o$1.tileID.overscaledZ), u$1 = o$1.tileSize / t.$, d$1 = o$1.tileID.toUnwrapped(), _$1 = "map" === l$1.get("text-rotation-alignment"), p$1 = t.aC(o$1, 1, this.transform.zoom), m$1 = t.aD(this.collisionIndex.transform, o$1, c$1.get("text-translate"), c$1.get("text-translate-anchor")), f$1 = t.aD(this.collisionIndex.transform, o$1, c$1.get("icon-translate"), c$1.get("icon-translate-anchor")), g$1 = Ie(_$1, this.transform, p$1);
					this.retainedQueryData[a$1.bucketInstanceId] = new Qe(a$1.bucketInstanceId, s$1, a$1.sourceLayerIndex, a$1.index, o$1.tileID);
					const v$1 = {
						bucket: a$1,
						layout: l$1,
						translationText: m$1,
						translationIcon: f$1,
						unwrappedTileID: d$1,
						pitchedLabelPlaneMatrix: g$1,
						scale: h$1,
						textPixelRatio: u$1,
						holdingForFade: o$1.holdingForFade(),
						collisionBoxArray: n$1,
						partiallyEvaluatedTextSize: t.an(a$1.textSizeData, this.transform.zoom),
						collisionGroup: this.collisionGroups.get(a$1.sourceID)
					};
					if (r$1) for (const t$1 of a$1.sortKeyRanges) {
						const { sortKey: i$2, symbolInstanceStart: o$2, symbolInstanceEnd: r$2 } = t$1;
						e$1.push({
							sortKey: i$2,
							symbolInstanceStart: o$2,
							symbolInstanceEnd: r$2,
							parameters: v$1
						});
					}
					else e$1.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: a$1.symbolInstances.length,
						parameters: v$1
					});
				}
				attemptAnchorPlacement(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1, m$1, f$1, g$1, v$1, b$1, x$1) {
					const y$1 = t.aE[e$1.textAnchor], w$1 = [e$1.textOffset0, e$1.textOffset1], T$1 = et(y$1, o$1, r$1, w$1, a$1), P$1 = this.collisionIndex.placeCollisionBox(i$1, d$1, l$1, c$1, h$1, n$1, s$1, f$1, u$1.predicate, b$1, T$1, x$1);
					if ((!v$1 || this.collisionIndex.placeCollisionBox(v$1, d$1, l$1, c$1, h$1, n$1, s$1, g$1, u$1.predicate, b$1, T$1, x$1).placeable) && P$1.placeable) {
						let e$2;
						if (this.prevPlacement && this.prevPlacement.variableOffsets[_$1.crossTileID] && this.prevPlacement.placements[_$1.crossTileID] && this.prevPlacement.placements[_$1.crossTileID].text && (e$2 = this.prevPlacement.variableOffsets[_$1.crossTileID].anchor), 0 === _$1.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						return this.variableOffsets[_$1.crossTileID] = {
							textOffset: w$1,
							width: o$1,
							height: r$1,
							anchor: y$1,
							textBoxScale: a$1,
							prevAnchor: e$2
						}, this.markUsedJustification(p$1, y$1, _$1, m$1), p$1.allowVerticalPlacement && (this.markUsedOrientation(p$1, m$1, _$1), this.placedOrientations[_$1.crossTileID] = m$1), {
							shift: T$1,
							placedGlyphBoxes: P$1
						};
					}
				}
				placeLayerBucketPart(e$1, i$1, o$1) {
					const { bucket: r$1, layout: a$1, translationText: s$1, translationIcon: n$1, unwrappedTileID: l$1, pitchedLabelPlaneMatrix: c$1, textPixelRatio: h$1, holdingForFade: u$1, collisionBoxArray: d$1, partiallyEvaluatedTextSize: _$1, collisionGroup: p$1 } = e$1.parameters, m$1 = a$1.get("text-optional"), f$1 = a$1.get("icon-optional"), g$1 = t.aF(a$1, "text-overlap", "text-allow-overlap"), v$1 = "always" === g$1, b$1 = t.aF(a$1, "icon-overlap", "icon-allow-overlap"), x$1 = "always" === b$1, y$1 = "map" === a$1.get("text-rotation-alignment"), w$1 = "map" === a$1.get("text-pitch-alignment"), T$1 = "none" !== a$1.get("icon-text-fit"), P$1 = "viewport-y" === a$1.get("symbol-z-order"), C$1 = v$1 && (x$1 || !r$1.hasIconData() || f$1), I$1 = x$1 && (v$1 || !r$1.hasTextData() || m$1);
					!r$1.collisionArrays && d$1 && r$1.deserializeCollisionBoxes(d$1);
					const M$1 = this.retainedQueryData[r$1.bucketInstanceId].tileID, S$1 = this._getTerrainElevationFunc(M$1), E$1 = this.transform.getFastPathSimpleProjectionMatrix(M$1), R$1 = (e$2, d$2, x$2) => {
						var P$2, R$2;
						if (i$1[e$2.crossTileID]) return;
						if (u$1) return void (this.placements[e$2.crossTileID] = new Ye(!1, !1, !1));
						let z$1 = !1, D$1 = !1, A$1 = !0, L$1 = null, k$1 = {
							box: null,
							placeable: !1,
							offscreen: null,
							occluded: !1
						}, F$1 = { placeable: !1 }, B$1 = null, O$1 = null, j$1 = null, N$1 = 0, U$1 = 0, Z$1 = 0;
						d$2.textFeatureIndex ? N$1 = d$2.textFeatureIndex : e$2.useRuntimeCollisionCircles && (N$1 = e$2.featureIndex), d$2.verticalTextFeatureIndex && (U$1 = d$2.verticalTextFeatureIndex);
						const G$1 = d$2.textBox;
						if (G$1) {
							const i$2 = (i$3) => {
								let o$2 = t.ao.horizontal;
								if (r$1.allowVerticalPlacement && !i$3 && this.prevPlacement) {
									const t$1 = this.prevPlacement.placedOrientations[e$2.crossTileID];
									t$1 && (this.placedOrientations[e$2.crossTileID] = t$1, o$2 = t$1, this.markUsedOrientation(r$1, o$2, e$2));
								}
								return o$2;
							}, a$2 = (i$3, o$2) => {
								if (r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && d$2.verticalTextBox) {
									for (const e$3 of r$1.writingModes) if (e$3 === t.ao.vertical ? (k$1 = o$2(), F$1 = k$1) : k$1 = i$3(), k$1 && k$1.placeable) break;
								} else k$1 = i$3();
							}, c$2 = e$2.textAnchorOffsetStartIndex, u$2 = e$2.textAnchorOffsetEndIndex;
							if (u$2 === c$2) {
								const o$2 = (t$1, i$3) => {
									const o$3 = this.collisionIndex.placeCollisionBox(t$1, g$1, h$1, M$1, l$1, w$1, y$1, s$1, p$1.predicate, S$1, void 0, E$1);
									return o$3 && o$3.placeable && (this.markUsedOrientation(r$1, i$3, e$2), this.placedOrientations[e$2.crossTileID] = i$3), o$3;
								};
								a$2((() => o$2(G$1, t.ao.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && e$2.numVerticalGlyphVertices > 0 && i$3 ? o$2(i$3, t.ao.vertical) : {
										box: null,
										offscreen: null
									};
								})), i$2(k$1 && k$1.placeable);
							} else {
								let _$2 = t.aE[null === (R$2 = null === (P$2 = this.prevPlacement) || void 0 === P$2 ? void 0 : P$2.variableOffsets[e$2.crossTileID]) || void 0 === R$2 ? void 0 : R$2.anchor];
								const m$2 = (t$1, i$3, a$3) => {
									const d$3 = t$1.x2 - t$1.x1, m$3 = t$1.y2 - t$1.y1, f$3 = e$2.textBoxScale, v$2 = T$1 && "never" === b$1 ? i$3 : null;
									let x$3 = null, P$3 = "never" === g$1 ? 1 : 2, C$2 = "never";
									_$2 && P$3++;
									for (let i$4 = 0; i$4 < P$3; i$4++) {
										for (let i$5 = c$2; i$5 < u$2; i$5++) {
											const o$2 = r$1.textAnchorOffsets.get(i$5);
											if (_$2 && o$2.textAnchor !== _$2) continue;
											const c$3 = this.attemptAnchorPlacement(o$2, t$1, d$3, m$3, f$3, y$1, w$1, h$1, M$1, l$1, p$1, C$2, e$2, r$1, a$3, s$1, n$1, v$2, S$1);
											if (c$3 && (x$3 = c$3.placedGlyphBoxes, x$3 && x$3.placeable)) return z$1 = !0, L$1 = c$3.shift, x$3;
										}
										_$2 ? _$2 = null : C$2 = g$1;
									}
									return o$1 && !x$3 && (x$3 = {
										box: this.collisionIndex.placeCollisionBox(G$1, "always", h$1, M$1, l$1, w$1, y$1, s$1, p$1.predicate, S$1, void 0, E$1).box,
										offscreen: !1,
										placeable: !1,
										occluded: !1
									}), x$3;
								};
								a$2((() => m$2(G$1, d$2.iconBox, t.ao.horizontal)), (() => {
									const i$3 = d$2.verticalTextBox;
									return r$1.allowVerticalPlacement && (!k$1 || !k$1.placeable) && e$2.numVerticalGlyphVertices > 0 && i$3 ? m$2(i$3, d$2.verticalIconBox, t.ao.vertical) : {
										box: null,
										occluded: !0,
										offscreen: null
									};
								})), k$1 && (z$1 = k$1.placeable, A$1 = k$1.offscreen);
								const f$2 = i$2(k$1 && k$1.placeable);
								if (!z$1 && this.prevPlacement) {
									const t$1 = this.prevPlacement.variableOffsets[e$2.crossTileID];
									t$1 && (this.variableOffsets[e$2.crossTileID] = t$1, this.markUsedJustification(r$1, t$1.anchor, e$2, f$2));
								}
							}
						}
						if (B$1 = k$1, z$1 = B$1 && B$1.placeable, A$1 = B$1 && B$1.offscreen, e$2.useRuntimeCollisionCircles && e$2.centerJustifiedTextSymbolIndex >= 0) {
							const i$2 = r$1.text.placedSymbolArray.get(e$2.centerJustifiedTextSymbolIndex), n$2 = t.ap(r$1.textSizeData, _$1, i$2), h$2 = a$1.get("text-padding");
							O$1 = this.collisionIndex.placeCollisionCircles(g$1, i$2, r$1.lineVertexArray, r$1.glyphOffsetArray, n$2, l$1, c$1, o$1, w$1, p$1.predicate, e$2.collisionCircleDiameter, h$2, s$1, S$1), O$1.circles.length && O$1.collisionDetected && !o$1 && t.w("Collisions detected, but collision boxes are not shown"), z$1 = v$1 || O$1.circles.length > 0 && !O$1.collisionDetected, A$1 = A$1 && O$1.offscreen;
						}
						if (d$2.iconFeatureIndex && (Z$1 = d$2.iconFeatureIndex), d$2.iconBox) {
							const e$3 = (e$4) => this.collisionIndex.placeCollisionBox(e$4, b$1, h$1, M$1, l$1, w$1, y$1, n$1, p$1.predicate, S$1, T$1 && L$1 ? L$1 : void 0, E$1);
							F$1 && F$1.placeable && d$2.verticalIconBox ? (j$1 = e$3(d$2.verticalIconBox), D$1 = j$1.placeable) : (j$1 = e$3(d$2.iconBox), D$1 = j$1.placeable), A$1 = A$1 && j$1.offscreen;
						}
						const V$1 = m$1 || 0 === e$2.numHorizontalGlyphVertices && 0 === e$2.numVerticalGlyphVertices, $$1 = f$1 || 0 === e$2.numIconVertices;
						V$1 || $$1 ? $$1 ? V$1 || (D$1 = D$1 && z$1) : z$1 = D$1 && z$1 : D$1 = z$1 = D$1 && z$1;
						const q$1 = D$1 && j$1.placeable;
						if (z$1 && B$1.placeable && this.collisionIndex.insertCollisionBox(B$1.box, g$1, a$1.get("text-ignore-placement"), r$1.bucketInstanceId, F$1 && F$1.placeable && U$1 ? U$1 : N$1, p$1.ID), q$1 && this.collisionIndex.insertCollisionBox(j$1.box, b$1, a$1.get("icon-ignore-placement"), r$1.bucketInstanceId, Z$1, p$1.ID), O$1 && z$1 && this.collisionIndex.insertCollisionCircles(O$1.circles, g$1, a$1.get("text-ignore-placement"), r$1.bucketInstanceId, N$1, p$1.ID), o$1 && this.storeCollisionData(r$1.bucketInstanceId, x$2, d$2, B$1, j$1, O$1), 0 === e$2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
						if (0 === r$1.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
						this.placements[e$2.crossTileID] = new Ye((z$1 || C$1) && !(null == B$1 ? void 0 : B$1.occluded), (D$1 || I$1) && !(null == j$1 ? void 0 : j$1.occluded), A$1 || r$1.justReloaded), i$1[e$2.crossTileID] = !0;
					};
					if (P$1) {
						if (0 !== e$1.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
						const t$1 = r$1.getSortedSymbolIndexes(-this.transform.bearingInRadians);
						for (let e$2 = t$1.length - 1; e$2 >= 0; --e$2) {
							const i$2 = t$1[e$2];
							R$1(r$1.symbolInstances.get(i$2), r$1.collisionArrays[i$2], i$2);
						}
					} else for (let t$1 = e$1.symbolInstanceStart; t$1 < e$1.symbolInstanceEnd; t$1++) R$1(r$1.symbolInstances.get(t$1), r$1.collisionArrays[t$1], t$1);
					r$1.justReloaded = !1;
				}
				storeCollisionData(e$1, t$1, i$1, o$1, r$1, a$1) {
					if (i$1.textBox || i$1.iconBox) {
						let a$2, s$1;
						this.collisionBoxArrays.has(e$1) ? a$2 = this.collisionBoxArrays.get(e$1) : (a$2 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e$1, a$2)), a$2.has(t$1) ? s$1 = a$2.get(t$1) : (s$1 = {
							text: null,
							icon: null
						}, a$2.set(t$1, s$1)), i$1.textBox && (s$1.text = o$1.box), i$1.iconBox && (s$1.icon = r$1.box);
					}
					if (a$1) {
						let t$2 = this.collisionCircleArrays[e$1];
						void 0 === t$2 && (t$2 = this.collisionCircleArrays[e$1] = []);
						for (let e$2 = 0; e$2 < a$1.circles.length; e$2 += 4) t$2.push(a$1.circles[e$2 + 0] - We), t$2.push(a$1.circles[e$2 + 1] - We), t$2.push(a$1.circles[e$2 + 2]), t$2.push(a$1.collisionDetected ? 1 : 0);
					}
				}
				markUsedJustification(e$1, i$1, o$1, r$1) {
					let a$1;
					a$1 = r$1 === t.ao.vertical ? o$1.verticalPlacedTextSymbolIndex : {
						left: o$1.leftJustifiedTextSymbolIndex,
						center: o$1.centerJustifiedTextSymbolIndex,
						right: o$1.rightJustifiedTextSymbolIndex
					}[t.aG(i$1)];
					const s$1 = [
						o$1.leftJustifiedTextSymbolIndex,
						o$1.centerJustifiedTextSymbolIndex,
						o$1.rightJustifiedTextSymbolIndex,
						o$1.verticalPlacedTextSymbolIndex
					];
					for (const t$1 of s$1) t$1 >= 0 && (e$1.text.placedSymbolArray.get(t$1).crossTileID = a$1 >= 0 && t$1 !== a$1 ? 0 : o$1.crossTileID);
				}
				markUsedOrientation(e$1, i$1, o$1) {
					const r$1 = i$1 === t.ao.horizontal || i$1 === t.ao.horizontalOnly ? i$1 : 0, a$1 = i$1 === t.ao.vertical ? i$1 : 0, s$1 = [
						o$1.leftJustifiedTextSymbolIndex,
						o$1.centerJustifiedTextSymbolIndex,
						o$1.rightJustifiedTextSymbolIndex
					];
					for (const t$1 of s$1) e$1.text.placedSymbolArray.get(t$1).placedOrientation = r$1;
					o$1.verticalPlacedTextSymbolIndex && (e$1.text.placedSymbolArray.get(o$1.verticalPlacedTextSymbolIndex).placedOrientation = a$1);
				}
				commit(e$1) {
					this.commitTime = e$1, this.zoomAtLastRecencyCheck = this.transform.zoom;
					const t$1 = this.prevPlacement;
					let i$1 = !1;
					this.prevZoomAdjustment = t$1 ? t$1.zoomAdjustment(this.transform.zoom) : 0;
					const o$1 = t$1 ? t$1.symbolFadeChange(e$1) : 1, r$1 = t$1 ? t$1.opacities : {}, a$1 = t$1 ? t$1.variableOffsets : {}, s$1 = t$1 ? t$1.placedOrientations : {};
					for (const e$2 in this.placements) {
						const t$2 = this.placements[e$2], a$2 = r$1[e$2];
						a$2 ? (this.opacities[e$2] = new Ke(a$2, o$1, t$2.text, t$2.icon), i$1 = i$1 || t$2.text !== a$2.text.placed || t$2.icon !== a$2.icon.placed) : (this.opacities[e$2] = new Ke(null, o$1, t$2.text, t$2.icon, t$2.skipFade), i$1 = i$1 || t$2.text || t$2.icon);
					}
					for (const e$2 in r$1) {
						const t$2 = r$1[e$2];
						if (!this.opacities[e$2]) {
							const r$2 = new Ke(t$2, o$1, !1, !1);
							r$2.isHidden() || (this.opacities[e$2] = r$2, i$1 = i$1 || t$2.text.placed || t$2.icon.placed);
						}
					}
					for (const e$2 in a$1) this.variableOffsets[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.variableOffsets[e$2] = a$1[e$2]);
					for (const e$2 in s$1) this.placedOrientations[e$2] || !this.opacities[e$2] || this.opacities[e$2].isHidden() || (this.placedOrientations[e$2] = s$1[e$2]);
					if (t$1 && void 0 === t$1.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
					i$1 ? this.lastPlacementChangeTime = e$1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t$1 ? t$1.lastPlacementChangeTime : e$1);
				}
				updateLayerOpacities(e$1, t$1) {
					const i$1 = {};
					for (const o$1 of t$1) {
						const t$2 = o$1.getBucket(e$1);
						t$2 && o$1.latestFeatureIndex && e$1.id === t$2.layerIds[0] && this.updateBucketOpacities(t$2, o$1.tileID, i$1, o$1.collisionBoxArray);
					}
				}
				updateBucketOpacities(e$1, i$1, o$1, r$1) {
					e$1.hasTextData() && (e$1.text.opacityVertexArray.clear(), e$1.text.hasVisibleVertices = !1), e$1.hasIconData() && (e$1.icon.opacityVertexArray.clear(), e$1.icon.hasVisibleVertices = !1), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexArray.clear(), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexArray.clear();
					const a$1 = e$1.layers[0], s$1 = a$1.layout, n$1 = new Ke(null, 0, !1, !1, !0), l$1 = s$1.get("text-allow-overlap"), c$1 = s$1.get("icon-allow-overlap"), h$1 = a$1._unevaluatedLayout.hasValue("text-variable-anchor") || a$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u$1 = "map" === s$1.get("text-rotation-alignment"), d$1 = "map" === s$1.get("text-pitch-alignment"), _$1 = "none" !== s$1.get("icon-text-fit"), p$1 = new Ke(null, 0, l$1 && (c$1 || !e$1.hasIconData() || s$1.get("icon-optional")), c$1 && (l$1 || !e$1.hasTextData() || s$1.get("text-optional")), !0);
					!e$1.collisionArrays && r$1 && (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) && e$1.deserializeCollisionBoxes(r$1);
					const m$1 = (e$2, t$1, i$2) => {
						for (let o$2 = 0; o$2 < t$1 / 4; o$2++) e$2.opacityVertexArray.emplaceBack(i$2);
						e$2.hasVisibleVertices = e$2.hasVisibleVertices || i$2 !== ut;
					}, f$1 = this.collisionBoxArrays.get(e$1.bucketInstanceId);
					for (let i$2 = 0; i$2 < e$1.symbolInstances.length; i$2++) {
						const r$2 = e$1.symbolInstances.get(i$2), { numHorizontalGlyphVertices: a$2, numVerticalGlyphVertices: s$2, crossTileID: l$2 } = r$2;
						let c$2 = this.opacities[l$2];
						o$1[l$2] ? c$2 = n$1 : c$2 || (c$2 = p$1, this.opacities[l$2] = c$2), o$1[l$2] = !0;
						const g$1 = r$2.numIconVertices > 0, v$1 = this.placedOrientations[r$2.crossTileID], b$1 = v$1 === t.ao.vertical, x$1 = v$1 === t.ao.horizontal || v$1 === t.ao.horizontalOnly;
						if (a$2 > 0 || s$2 > 0) {
							const t$1 = ht(c$2.text);
							m$1(e$1.text, a$2, b$1 ? ut : t$1), m$1(e$1.text, s$2, x$1 ? ut : t$1);
							const i$3 = c$2.text.isHidden();
							[
								r$2.rightJustifiedTextSymbolIndex,
								r$2.centerJustifiedTextSymbolIndex,
								r$2.leftJustifiedTextSymbolIndex
							].forEach(((t$2) => {
								t$2 >= 0 && (e$1.text.placedSymbolArray.get(t$2).hidden = i$3 || b$1 ? 1 : 0);
							})), r$2.verticalPlacedTextSymbolIndex >= 0 && (e$1.text.placedSymbolArray.get(r$2.verticalPlacedTextSymbolIndex).hidden = i$3 || x$1 ? 1 : 0);
							const o$2 = this.variableOffsets[r$2.crossTileID];
							o$2 && this.markUsedJustification(e$1, o$2.anchor, r$2, v$1);
							const n$2 = this.placedOrientations[r$2.crossTileID];
							n$2 && (this.markUsedJustification(e$1, "left", r$2, n$2), this.markUsedOrientation(e$1, n$2, r$2));
						}
						if (g$1) {
							const t$1 = ht(c$2.icon), i$3 = !(_$1 && r$2.verticalPlacedIconSymbolIndex && b$1);
							r$2.placedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numIconVertices, i$3 ? t$1 : ut), e$1.icon.placedSymbolArray.get(r$2.placedIconSymbolIndex).hidden = c$2.icon.isHidden()), r$2.verticalPlacedIconSymbolIndex >= 0 && (m$1(e$1.icon, r$2.numVerticalIconVertices, i$3 ? ut : t$1), e$1.icon.placedSymbolArray.get(r$2.verticalPlacedIconSymbolIndex).hidden = c$2.icon.isHidden());
						}
						const y$1 = f$1 && f$1.has(i$2) ? f$1.get(i$2) : {
							text: null,
							icon: null
						};
						if (e$1.hasIconCollisionBoxData() || e$1.hasTextCollisionBoxData()) {
							const o$2 = e$1.collisionArrays[i$2];
							if (o$2) {
								let i$3 = new t.P(0, 0);
								if (o$2.textBox || o$2.verticalTextBox) {
									let t$1 = !0;
									if (h$1) {
										const e$2 = this.variableOffsets[l$2];
										e$2 ? (i$3 = et(e$2.anchor, e$2.width, e$2.height, e$2.textOffset, e$2.textBoxScale), u$1 && i$3._rotate(d$1 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t$1 = !1;
									}
									if (o$2.textBox || o$2.verticalTextBox) {
										let r$3;
										o$2.textBox && (r$3 = b$1), o$2.verticalTextBox && (r$3 = x$1), it(e$1.textCollisionBox.collisionVertexArray, c$2.text.placed, !t$1 || r$3, y$1.text, i$3.x, i$3.y);
									}
								}
								if (o$2.iconBox || o$2.verticalIconBox) {
									const t$1 = Boolean(!x$1 && o$2.verticalIconBox);
									let r$3;
									o$2.iconBox && (r$3 = t$1), o$2.verticalIconBox && (r$3 = !t$1), it(e$1.iconCollisionBox.collisionVertexArray, c$2.icon.placed, r$3, y$1.icon, _$1 ? i$3.x : 0, _$1 ? i$3.y : 0);
								}
							}
						}
					}
					if (e$1.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e$1.bucketInstanceId] && (this.retainedQueryData[e$1.bucketInstanceId].featureSortOrder = e$1.featureSortOrder), e$1.hasTextData() && e$1.text.opacityVertexBuffer && e$1.text.opacityVertexBuffer.updateData(e$1.text.opacityVertexArray), e$1.hasIconData() && e$1.icon.opacityVertexBuffer && e$1.icon.opacityVertexBuffer.updateData(e$1.icon.opacityVertexArray), e$1.hasIconCollisionBoxData() && e$1.iconCollisionBox.collisionVertexBuffer && e$1.iconCollisionBox.collisionVertexBuffer.updateData(e$1.iconCollisionBox.collisionVertexArray), e$1.hasTextCollisionBoxData() && e$1.textCollisionBox.collisionVertexBuffer && e$1.textCollisionBox.collisionVertexBuffer.updateData(e$1.textCollisionBox.collisionVertexArray), e$1.text.opacityVertexArray.length !== e$1.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e$1.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e$1.text.layoutVertexArray.length}) / 4`);
					if (e$1.icon.opacityVertexArray.length !== e$1.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e$1.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e$1.icon.layoutVertexArray.length}) / 4`);
					e$1.bucketInstanceId in this.collisionCircleArrays && (e$1.collisionCircleArray = this.collisionCircleArrays[e$1.bucketInstanceId], delete this.collisionCircleArrays[e$1.bucketInstanceId]);
				}
				symbolFadeChange(e$1) {
					return 0 === this.fadeDuration ? 1 : (e$1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e$1) {
					return Math.max(0, (this.transform.zoom - e$1) / 1.5);
				}
				hasTransitions(e$1) {
					return this.stale || e$1 - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e$1, t$1) {
					const i$1 = this.zoomAtLastRecencyCheck === t$1 ? 1 - this.zoomAdjustment(t$1) : 1;
					return this.zoomAtLastRecencyCheck = t$1, this.commitTime + this.fadeDuration * i$1 > e$1;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function it(e$1, t$1, i$1, o$1, r$1, a$1) {
				o$1 && 0 !== o$1.length || (o$1 = [
					0,
					0,
					0,
					0
				]);
				const s$1 = o$1[0] - We, n$1 = o$1[1] - We, l$1 = o$1[2] - We, c$1 = o$1[3] - We;
				e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, s$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, l$1, n$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, l$1, c$1), e$1.emplaceBack(t$1 ? 1 : 0, i$1 ? 1 : 0, r$1 || 0, a$1 || 0, s$1, c$1);
			}
			const ot = Math.pow(2, 25), rt = Math.pow(2, 24), at = Math.pow(2, 17), st = Math.pow(2, 16), nt = Math.pow(2, 9), lt = Math.pow(2, 8), ct = Math.pow(2, 1);
			function ht(e$1) {
				if (0 === e$1.opacity && !e$1.placed) return 0;
				if (1 === e$1.opacity && e$1.placed) return 4294967295;
				const t$1 = e$1.placed ? 1 : 0, i$1 = Math.floor(127 * e$1.opacity);
				return i$1 * ot + t$1 * rt + i$1 * at + t$1 * st + i$1 * nt + t$1 * lt + i$1 * ct + t$1;
			}
			const ut = 0;
			class dt {
				constructor(e$1) {
					this._sortAcrossTiles = "viewport-y" !== e$1.layout.get("symbol-z-order") && !e$1.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
				}
				continuePlacement(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = this._bucketParts;
					for (; this._currentTileIndex < e$1.length;) if (t$1.getBucketParts(a$1, o$1, e$1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r$1()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a$1.sort(((e$2, t$2) => e$2.sortKey - t$2.sortKey))); this._currentPartIndex < a$1.length;) if (t$1.placeLayerBucketPart(a$1[this._currentPartIndex], this._seenCrossTileIDs, i$1), this._currentPartIndex++, r$1()) return !0;
					return !1;
				}
			}
			class _t {
				constructor(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					this.placement = new tt(e$1, t$1, a$1, s$1, n$1), this._currentPlacementIndex = i$1.length - 1, this._forceFullPlacement = o$1, this._showCollisionBoxes = r$1, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(e$1, t$1, i$1) {
					const o$1 = s.now(), r$1 = () => !this._forceFullPlacement && s.now() - o$1 > 2;
					for (; this._currentPlacementIndex >= 0;) {
						const o$2 = t$1[e$1[this._currentPlacementIndex]], a$1 = this.placement.collisionIndex.transform.zoom;
						if ("symbol" === o$2.type && (!o$2.minzoom || o$2.minzoom <= a$1) && (!o$2.maxzoom || o$2.maxzoom > a$1)) {
							if (this._inProgressLayer || (this._inProgressLayer = new dt(o$2)), this._inProgressLayer.continuePlacement(i$1[o$2.source], this.placement, this._showCollisionBoxes, o$2, r$1)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e$1) {
					return this.placement.commit(e$1), this.placement;
				}
			}
			const pt = 512 / t.$ / 2;
			class mt {
				constructor(e$1, i$1, o$1) {
					this.tileID = e$1, this.bucketInstanceId = o$1, this._symbolsByKey = {};
					const r$1 = /* @__PURE__ */ new Map();
					for (let e$2 = 0; e$2 < i$1.length; e$2++) {
						const t$1 = i$1.get(e$2), o$2 = t$1.key, a$1 = r$1.get(o$2);
						a$1 ? a$1.push(t$1) : r$1.set(o$2, [t$1]);
					}
					for (const [e$2, i$2] of r$1) {
						const o$2 = {
							positions: i$2.map(((e$3) => ({
								x: Math.floor(e$3.anchorX * pt),
								y: Math.floor(e$3.anchorY * pt)
							}))),
							crossTileIDs: i$2.map(((e$3) => e$3.crossTileID))
						};
						if (o$2.positions.length > 128) {
							const e$3 = new t.aI(o$2.positions.length, 16, Uint16Array);
							for (const { x: t$1, y: i$3 } of o$2.positions) e$3.add(t$1, i$3);
							e$3.finish(), delete o$2.positions, o$2.index = e$3;
						}
						this._symbolsByKey[e$2] = o$2;
					}
				}
				getScaledCoordinates(e$1, i$1) {
					const { x: o$1, y: r$1, z: a$1 } = this.tileID.canonical, { x: s$1, y: n$1, z: l$1 } = i$1.canonical, c$1 = pt / Math.pow(2, l$1 - a$1), h$1 = (n$1 * t.$ + e$1.anchorY) * c$1, u$1 = r$1 * t.$ * pt;
					return {
						x: Math.floor((s$1 * t.$ + e$1.anchorX) * c$1 - o$1 * t.$ * pt),
						y: Math.floor(h$1 - u$1)
					};
				}
				findMatches(e$1, t$1, i$1) {
					const o$1 = this.tileID.canonical.z < t$1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t$1.canonical.z);
					for (let r$1 = 0; r$1 < e$1.length; r$1++) {
						const a$1 = e$1.get(r$1);
						if (a$1.crossTileID) continue;
						const s$1 = this._symbolsByKey[a$1.key];
						if (!s$1) continue;
						const n$1 = this.getScaledCoordinates(a$1, t$1);
						if (s$1.index) {
							const e$2 = s$1.index.range(n$1.x - o$1, n$1.y - o$1, n$1.x + o$1, n$1.y + o$1).sort();
							for (const t$2 of e$2) {
								const e$3 = s$1.crossTileIDs[t$2];
								if (!i$1[e$3]) {
									i$1[e$3] = !0, a$1.crossTileID = e$3;
									break;
								}
							}
						} else if (s$1.positions) for (let e$2 = 0; e$2 < s$1.positions.length; e$2++) {
							const t$2 = s$1.positions[e$2], r$2 = s$1.crossTileIDs[e$2];
							if (Math.abs(t$2.x - n$1.x) <= o$1 && Math.abs(t$2.y - n$1.y) <= o$1 && !i$1[r$2]) {
								i$1[r$2] = !0, a$1.crossTileID = r$2;
								break;
							}
						}
					}
				}
				getCrossTileIDsLists() {
					return Object.values(this._symbolsByKey).map((({ crossTileIDs: e$1 }) => e$1));
				}
			}
			class ft {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class gt {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e$1) {
					const t$1 = Math.round((e$1 - this.lng) / 360);
					if (0 !== t$1) for (const e$2 in this.indexes) {
						const i$1 = this.indexes[e$2], o$1 = {};
						for (const e$3 in i$1) {
							const r$1 = i$1[e$3];
							r$1.tileID = r$1.tileID.unwrapTo(r$1.tileID.wrap + t$1), o$1[r$1.tileID.key] = r$1;
						}
						this.indexes[e$2] = o$1;
					}
					this.lng = e$1;
				}
				addBucket(e$1, t$1, i$1) {
					if (this.indexes[e$1.overscaledZ] && this.indexes[e$1.overscaledZ][e$1.key]) {
						if (this.indexes[e$1.overscaledZ][e$1.key].bucketInstanceId === t$1.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e$1.overscaledZ, this.indexes[e$1.overscaledZ][e$1.key]);
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) t$1.symbolInstances.get(e$2).crossTileID = 0;
					this.usedCrossTileIDs[e$1.overscaledZ] || (this.usedCrossTileIDs[e$1.overscaledZ] = {});
					const o$1 = this.usedCrossTileIDs[e$1.overscaledZ];
					for (const i$2 in this.indexes) {
						const r$1 = this.indexes[i$2];
						if (Number(i$2) > e$1.overscaledZ) for (const i$3 in r$1) {
							const a$1 = r$1[i$3];
							a$1.tileID.isChildOf(e$1) && a$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
						else {
							const a$1 = r$1[e$1.scaledTo(Number(i$2)).key];
							a$1 && a$1.findMatches(t$1.symbolInstances, e$1, o$1);
						}
					}
					for (let e$2 = 0; e$2 < t$1.symbolInstances.length; e$2++) {
						const r$1 = t$1.symbolInstances.get(e$2);
						r$1.crossTileID || (r$1.crossTileID = i$1.generate(), o$1[r$1.crossTileID] = !0);
					}
					return void 0 === this.indexes[e$1.overscaledZ] && (this.indexes[e$1.overscaledZ] = {}), this.indexes[e$1.overscaledZ][e$1.key] = new mt(e$1, t$1.symbolInstances, t$1.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e$1, t$1) {
					for (const i$1 of t$1.getCrossTileIDsLists()) for (const t$2 of i$1) delete this.usedCrossTileIDs[e$1][t$2];
				}
				removeStaleBuckets(e$1) {
					let t$1 = !1;
					for (const i$1 in this.indexes) {
						const o$1 = this.indexes[i$1];
						for (const r$1 in o$1) e$1[o$1[r$1].bucketInstanceId] || (this.removeBucketCrossTileIDs(i$1, o$1[r$1]), delete o$1[r$1], t$1 = !0);
					}
					return t$1;
				}
			}
			class vt {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new ft(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e$1, t$1, i$1) {
					let o$1 = this.layerIndexes[e$1.id];
					void 0 === o$1 && (o$1 = this.layerIndexes[e$1.id] = new gt());
					let r$1 = !1;
					const a$1 = {};
					o$1.handleWrapJump(i$1);
					for (const i$2 of t$1) {
						const t$2 = i$2.getBucket(e$1);
						t$2 && e$1.id === t$2.layerIds[0] && (t$2.bucketInstanceId || (t$2.bucketInstanceId = ++this.maxBucketInstanceId), o$1.addBucket(i$2.tileID, t$2, this.crossTileIDs) && (r$1 = !0), a$1[t$2.bucketInstanceId] = !0);
					}
					return o$1.removeStaleBuckets(a$1) && (r$1 = !0), r$1;
				}
				pruneUnusedLayers(e$1) {
					const t$1 = {};
					e$1.forEach(((e$2) => {
						t$1[e$2] = !0;
					}));
					for (const e$2 in this.layerIndexes) t$1[e$2] || delete this.layerIndexes[e$2];
				}
			}
			var bt = "void main() {fragColor=vec4(1.0);}";
			const xt = {
				prelude: yt("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"),
				projectionMercator: yt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
				projectionGlobe: yt("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"),
				background: yt("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				backgroundPattern: yt("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
				circle: yt("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
				clippingMask: yt(bt, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				heatmap: yt("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"),
				heatmapTexture: yt("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
				collisionBox: yt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: yt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				colorRelief: yt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				debug: yt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
				depth: yt(bt, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"),
				fill: yt("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"),
				fillOutline: yt("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillOutlinePattern: yt("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillPattern: yt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
				fillExtrusion: yt("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
				fillExtrusionPattern: yt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
				hillshadePrepare: yt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: yt("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				line: yt("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				lineGradient: yt("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				linePattern: yt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
				lineSDF: yt("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				raster: yt("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				symbolIcon: yt("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
				symbolSDF: yt("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
				symbolTextAndIcon: yt("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
				terrain: yt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
				terrainDepth: yt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
				terrainCoords: yt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
				projectionErrorMeasurement: yt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
				atmosphere: yt("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
				sky: yt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
			};
			function yt(e$1, t$1) {
				const i$1 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o$1 = t$1.match(/in ([\w]+) ([\w]+)/g), r$1 = e$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a$1 = t$1.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s$1 = a$1 ? a$1.concat(r$1) : r$1, n$1 = {};
				return {
					fragmentSource: e$1 = e$1.replace(i$1, ((e$2, t$2, i$2, o$2, r$2) => (n$1[r$2] = !0, "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nin ${i$2} ${o$2} ${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n`))),
					vertexSource: t$1 = t$1.replace(i$1, ((e$2, t$2, i$2, o$2, r$2) => {
						const a$2 = "float" === o$2 ? "vec2" : "vec4", s$2 = r$2.match(/color/) ? "color" : a$2;
						return n$1[r$2] ? "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${a$2} a_${r$2};\nout ${i$2} ${o$2} ${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = a_${r$2};\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : "define" === t$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\nuniform lowp float u_${r$2}_t;\nin ${i$2} ${a$2} a_${r$2};\n#else\nuniform ${i$2} ${o$2} u_${r$2};\n#endif\n` : "vec4" === s$2 ? `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = a_${r$2};\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r$2}\n    ${i$2} ${o$2} ${r$2} = unpack_mix_${s$2}(a_${r$2}, u_${r$2}_t);\n#else\n    ${i$2} ${o$2} ${r$2} = u_${r$2};\n#endif\n`;
					})),
					staticAttributes: o$1,
					staticUniforms: s$1
				};
			}
			class wt {
				constructor(e$1, t$1, i$1) {
					this.vertexBuffer = e$1, this.indexBuffer = t$1, this.segments = i$1;
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
				}
			}
			var Tt = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			const Pt = "#define PROJECTION_MERCATOR", Ct = "mercator";
			class It {
				constructor() {
					this._cachedMesh = null;
				}
				get name() {
					return "mercator";
				}
				get useSubdivision() {
					return !1;
				}
				get shaderVariantName() {
					return Ct;
				}
				get shaderDefine() {
					return Pt;
				}
				get shaderPreludeCode() {
					return xt.projectionMercator;
				}
				get vertexShaderPreludeCode() {
					return xt.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return t.aK.noSubdivision;
				}
				get useGlobeControls() {
					return !1;
				}
				get transitionState() {
					return 0;
				}
				get latitudeErrorCorrectionRadians() {
					return 0;
				}
				destroy() {}
				updateGPUdependent(e$1) {}
				getMeshFromTileID(e$1, i$1, o$1, r$1, a$1) {
					if (this._cachedMesh) return this._cachedMesh;
					const s$1 = new t.aL();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(t.$, 0), s$1.emplaceBack(0, t.$), s$1.emplaceBack(t.$, t.$);
					const n$1 = e$1.createVertexBuffer(s$1, Tt.members), l$1 = t.aM.simpleSegment(0, 0, 4, 2), c$1 = new t.aN();
					c$1.emplaceBack(1, 0, 2), c$1.emplaceBack(1, 2, 3);
					const h$1 = e$1.createIndexBuffer(c$1);
					return this._cachedMesh = new wt(n$1, h$1, l$1), this._cachedMesh;
				}
				recalculate() {}
				hasTransition() {
					return !1;
				}
				setErrorQueryLatitudeDegrees(e$1) {}
			}
			class Mt {
				constructor(e$1 = 0, t$1 = 0, i$1 = 0, o$1 = 0) {
					if (isNaN(e$1) || e$1 < 0 || isNaN(t$1) || t$1 < 0 || isNaN(i$1) || i$1 < 0 || isNaN(o$1) || o$1 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e$1, this.bottom = t$1, this.left = i$1, this.right = o$1;
				}
				interpolate(e$1, i$1, o$1) {
					return null != i$1.top && null != e$1.top && (this.top = t.C.number(e$1.top, i$1.top, o$1)), null != i$1.bottom && null != e$1.bottom && (this.bottom = t.C.number(e$1.bottom, i$1.bottom, o$1)), null != i$1.left && null != e$1.left && (this.left = t.C.number(e$1.left, i$1.left, o$1)), null != i$1.right && null != e$1.right && (this.right = t.C.number(e$1.right, i$1.right, o$1)), this;
				}
				getCenter(e$1, i$1) {
					const o$1 = t.ah((this.left + e$1 - this.right) / 2, 0, e$1), r$1 = t.ah((this.top + i$1 - this.bottom) / 2, 0, i$1);
					return new t.P(o$1, r$1);
				}
				equals(e$1) {
					return this.top === e$1.top && this.bottom === e$1.bottom && this.left === e$1.left && this.right === e$1.right;
				}
				clone() {
					return new Mt(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			function St(e$1, t$1) {
				if (!e$1.renderWorldCopies || e$1.lngRange) return;
				const i$1 = t$1.lng - e$1.center.lng;
				t$1.lng += i$1 > 180 ? -360 : i$1 < -180 ? 360 : 0;
			}
			function Et(e$1) {
				return Math.max(0, Math.floor(e$1));
			}
			class Rt {
				constructor(e$1, i$1, o$1, r$1, a$1, s$1) {
					this._callbacks = e$1, this._tileSize = 512, this._renderWorldCopies = void 0 === s$1 || !!s$1, this._minZoom = i$1 || 0, this._maxZoom = o$1 || 22, this._minPitch = null == r$1 ? 0 : r$1, this._maxPitch = null == a$1 ? 60 : a$1, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Et(this._zoom), this._scale = t.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Mt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
				}
				apply(e$1, i$1, o$1) {
					this._latRange = e$1.latRange, this._lngRange = e$1.lngRange, this._width = e$1.width, this._height = e$1.height, this._center = e$1.center, this._elevation = e$1.elevation, this._minElevationForCurrentTile = e$1.minElevationForCurrentTile, this._zoom = e$1.zoom, this._tileZoom = Et(this._zoom), this._scale = t.af(this._zoom), this._bearingInRadians = e$1.bearingInRadians, this._fovInRadians = e$1.fovInRadians, this._pitchInRadians = e$1.pitchInRadians, this._rollInRadians = e$1.rollInRadians, this._unmodified = e$1.unmodified, this._edgeInsets = new Mt(e$1.padding.top, e$1.padding.bottom, e$1.padding.left, e$1.padding.right), this._minZoom = e$1.minZoom, this._maxZoom = e$1.maxZoom, this._minPitch = e$1.minPitch, this._maxPitch = e$1.maxPitch, this._renderWorldCopies = e$1.renderWorldCopies, this._cameraToCenterDistance = e$1.cameraToCenterDistance, this._nearZ = e$1.nearZ, this._farZ = e$1.farZ, this._autoCalculateNearFarZ = !o$1 && e$1.autoCalculateNearFarZ, i$1 && this._constrain(), this._calcMatrices();
				}
				get pixelsToClipSpaceMatrix() {
					return this._pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._clipSpaceToPixelsMatrix;
				}
				get minElevationForCurrentTile() {
					return this._minElevationForCurrentTile;
				}
				setMinElevationForCurrentTile(e$1) {
					this._minElevationForCurrentTile = e$1;
				}
				get tileSize() {
					return this._tileSize;
				}
				get tileZoom() {
					return this._tileZoom;
				}
				get scale() {
					return this._scale;
				}
				get width() {
					return this._width;
				}
				get height() {
					return this._height;
				}
				get bearingInRadians() {
					return this._bearingInRadians;
				}
				get lngRange() {
					return this._lngRange;
				}
				get latRange() {
					return this._latRange;
				}
				get pixelsToGLUnits() {
					return this._pixelsToGLUnits;
				}
				get minZoom() {
					return this._minZoom;
				}
				setMinZoom(e$1) {
					this._minZoom !== e$1 && (this._minZoom = e$1, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				setMaxZoom(e$1) {
					this._maxZoom !== e$1 && (this._maxZoom = e$1, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
				}
				get minPitch() {
					return this._minPitch;
				}
				setMinPitch(e$1) {
					this._minPitch !== e$1 && (this._minPitch = e$1, this.setPitch(Math.max(this.pitch, e$1)));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				setMaxPitch(e$1) {
					this._maxPitch !== e$1 && (this._maxPitch = e$1, this.setPitch(Math.min(this.pitch, e$1)));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					void 0 === e$1 ? e$1 = !0 : null === e$1 && (e$1 = !1), this._renderWorldCopies = e$1;
				}
				get worldSize() {
					return this._tileSize * this._scale;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new t.P(this._width, this._height);
				}
				get bearing() {
					return this._bearingInRadians / Math.PI * 180;
				}
				setBearing(e$1) {
					const i$1 = t.aO(e$1, -180, 180) * Math.PI / 180;
					var r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1;
					this._bearingInRadians !== i$1 && (this._unmodified = !1, this._bearingInRadians = i$1, this._calcMatrices(), this._rotationMatrix = o(), r$1 = this._rotationMatrix, s$1 = -this._bearingInRadians, n$1 = (a$1 = this._rotationMatrix)[0], l$1 = a$1[1], c$1 = a$1[2], h$1 = a$1[3], u$1 = Math.sin(s$1), d$1 = Math.cos(s$1), r$1[0] = n$1 * d$1 + c$1 * u$1, r$1[1] = l$1 * d$1 + h$1 * u$1, r$1[2] = n$1 * -u$1 + c$1 * d$1, r$1[3] = l$1 * -u$1 + h$1 * d$1);
				}
				get rotationMatrix() {
					return this._rotationMatrix;
				}
				get pitchInRadians() {
					return this._pitchInRadians;
				}
				get pitch() {
					return this._pitchInRadians / Math.PI * 180;
				}
				setPitch(e$1) {
					const i$1 = t.ah(e$1, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitchInRadians !== i$1 && (this._unmodified = !1, this._pitchInRadians = i$1, this._calcMatrices());
				}
				get rollInRadians() {
					return this._rollInRadians;
				}
				get roll() {
					return this._rollInRadians / Math.PI * 180;
				}
				setRoll(e$1) {
					const t$1 = e$1 / 180 * Math.PI;
					this._rollInRadians !== t$1 && (this._unmodified = !1, this._rollInRadians = t$1, this._calcMatrices());
				}
				get fovInRadians() {
					return this._fovInRadians;
				}
				get fov() {
					return t.aP(this._fovInRadians);
				}
				setFov(e$1) {
					e$1 = t.ah(e$1, .1, 150), this.fov !== e$1 && (this._unmodified = !1, this._fovInRadians = t.ae(e$1), this._calcMatrices());
				}
				get zoom() {
					return this._zoom;
				}
				setZoom(e$1) {
					const i$1 = this.getConstrained(this._center, e$1).zoom;
					this._zoom !== i$1 && (this._unmodified = !1, this._zoom = i$1, this._tileZoom = Math.max(0, Math.floor(i$1)), this._scale = t.af(i$1), this._constrain(), this._calcMatrices());
				}
				get center() {
					return this._center;
				}
				setCenter(e$1) {
					e$1.lat === this._center.lat && e$1.lng === this._center.lng || (this._unmodified = !1, this._center = e$1, this._constrain(), this._calcMatrices());
				}
				get elevation() {
					return this._elevation;
				}
				setElevation(e$1) {
					e$1 !== this._elevation && (this._elevation = e$1, this._constrain(), this._calcMatrices());
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				setPadding(e$1) {
					this._edgeInsets.equals(e$1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e$1, 1), this._calcMatrices());
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this._width, this._height);
				}
				get pixelsPerMeter() {
					return this._pixelPerMeter;
				}
				get unmodified() {
					return this._unmodified;
				}
				get cameraToCenterDistance() {
					return this._cameraToCenterDistance;
				}
				get nearZ() {
					return this._nearZ;
				}
				get farZ() {
					return this._farZ;
				}
				get autoCalculateNearFarZ() {
					return this._autoCalculateNearFarZ;
				}
				overrideNearFarZ(e$1, t$1) {
					this._autoCalculateNearFarZ = !1, this._nearZ = e$1, this._farZ = t$1, this._calcMatrices();
				}
				clearNearFarZOverride() {
					this._autoCalculateNearFarZ = !0, this._calcMatrices();
				}
				isPaddingEqual(e$1) {
					return this._edgeInsets.equals(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					this._unmodified = !1, this._edgeInsets.interpolate(e$1, t$1, i$1), this._constrain(), this._calcMatrices();
				}
				resize(e$1, t$1, i$1 = !0) {
					this._width = e$1, this._height = t$1, i$1 && this._constrain(), this._calcMatrices();
				}
				getMaxBounds() {
					return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new G([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
				}
				setMaxBounds(e$1) {
					e$1 ? (this._lngRange = [e$1.getWest(), e$1.getEast()], this._latRange = [e$1.getSouth(), e$1.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-t.ai, t.ai]);
				}
				getConstrained(e$1, t$1) {
					return this._callbacks.getConstrained(e$1, t$1);
				}
				getCameraQueryGeometry(e$1, i$1) {
					if (1 === i$1.length) return [i$1[0], e$1];
					{
						const { minX: o$1, minY: r$1, maxX: a$1, maxY: s$1 } = t.a2.fromPoints(i$1).extend(e$1);
						return [
							new t.P(o$1, r$1),
							new t.P(a$1, r$1),
							new t.P(a$1, s$1),
							new t.P(o$1, s$1),
							new t.P(o$1, r$1)
						];
					}
				}
				_constrain() {
					if (!this.center || !this._width || !this._height || this._constraining) return;
					this._constraining = !0;
					const e$1 = this._unmodified, { center: t$1, zoom: i$1 } = this.getConstrained(this.center, this.zoom);
					this.setCenter(t$1), this.setZoom(i$1), this._unmodified = e$1, this._constraining = !1;
				}
				_calcMatrices() {
					if (this._width && this._height) {
						this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
						let e$1 = t.ag(new Float64Array(16));
						t.N(e$1, e$1, [
							this._width / 2,
							-this._height / 2,
							1
						]), t.M(e$1, e$1, [
							1,
							-1,
							0
						]), this._clipSpaceToPixelsMatrix = e$1, e$1 = t.ag(new Float64Array(16)), t.N(e$1, e$1, [
							1,
							-1,
							1
						]), t.M(e$1, e$1, [
							-1,
							-1,
							0
						]), t.N(e$1, e$1, [
							2 / this._width,
							2 / this._height,
							1
						]), this._pixelsToClipSpaceMatrix = e$1, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height;
					}
					this._callbacks.calcMatrices();
				}
				calculateCenterFromCameraLngLatAlt(e$1, i$1, o$1, r$1) {
					const a$1 = void 0 !== o$1 ? o$1 : this.bearing, s$1 = r$1 = void 0 !== r$1 ? r$1 : this.pitch, n$1 = t.a1.fromLngLat(e$1, i$1), l$1 = -Math.cos(t.ae(s$1)), c$1 = Math.sin(t.ae(s$1)), h$1 = c$1 * Math.sin(t.ae(a$1)), u$1 = -c$1 * Math.cos(t.ae(a$1));
					let d$1 = this.elevation;
					const _$1 = i$1 - d$1;
					let p$1;
					l$1 * _$1 >= 0 || Math.abs(l$1) < .1 ? (p$1 = 1e4, d$1 = i$1 + p$1 * l$1) : p$1 = -_$1 / l$1;
					let m$1, f$1, g$1 = t.aQ(1, n$1.y), v$1 = 0;
					do {
						if (v$1 += 1, v$1 > 10) break;
						f$1 = p$1 / g$1, m$1 = new t.a1(n$1.x + h$1 * f$1, n$1.y + u$1 * f$1), g$1 = 1 / m$1.meterInMercatorCoordinateUnits();
					} while (Math.abs(p$1 - f$1 * g$1) > 1e-12);
					return {
						center: m$1.toLngLat(),
						elevation: d$1,
						zoom: t.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / f$1 / this.tileSize)
					};
				}
				recalculateZoomAndCenter(e$1) {
					if (this.elevation - e$1 == 0) return;
					const i$1 = t.aj(1, this.center.lat) * this.worldSize, o$1 = this.cameraToCenterDistance / i$1, r$1 = t.a1.fromLngLat(this.center, this.elevation), a$1 = de(this.center, this.elevation, this.pitch, this.bearing, o$1);
					this._elevation = e$1;
					const s$1 = this.calculateCenterFromCameraLngLatAlt(a$1.toLngLat(), t.aQ(a$1.z, r$1.y), this.bearing, this.pitch);
					this._elevation = s$1.elevation, this._center = s$1.center, this.setZoom(s$1.zoom);
				}
				getCameraPoint() {
					const e$1 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
					return this.centerPoint.add(new t.P(e$1 * Math.sin(this.rollInRadians), e$1 * Math.cos(this.rollInRadians)));
				}
				getCameraAltitude() {
					return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
				}
				getCameraLngLat() {
					const e$1 = t.aj(1, this.center.lat) * this.worldSize;
					return de(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e$1).toLngLat();
				}
				getMercatorTileCoordinates(e$1) {
					if (!e$1) return [
						0,
						0,
						1,
						1
					];
					const i$1 = e$1.canonical.z >= 0 ? 1 << e$1.canonical.z : Math.pow(2, e$1.canonical.z);
					return [
						e$1.canonical.x / i$1,
						e$1.canonical.y / i$1,
						1 / i$1 / t.$,
						1 / i$1 / t.$
					];
				}
			}
			class zt {
				constructor(e$1, i$1) {
					this.min = e$1, this.max = i$1, this.center = t.aR([], t.aS([], this.min, this.max), .5);
				}
				quadrant(e$1) {
					const i$1 = [e$1 % 2 == 0, e$1 < 2], o$1 = t.aT(this.min), r$1 = t.aT(this.max);
					for (let e$2 = 0; e$2 < i$1.length; e$2++) o$1[e$2] = i$1[e$2] ? this.min[e$2] : this.center[e$2], r$1[e$2] = i$1[e$2] ? this.center[e$2] : this.max[e$2];
					return r$1[2] = this.max[2], new zt(o$1, r$1);
				}
				distanceX(e$1) {
					return Math.max(Math.min(this.max[0], e$1[0]), this.min[0]) - e$1[0];
				}
				distanceY(e$1) {
					return Math.max(Math.min(this.max[1], e$1[1]), this.min[1]) - e$1[1];
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					for (let i$1 = 0; i$1 < e$1.planes.length; i$1++) {
						const o$1 = this.intersectsPlane(e$1.planes[i$1]);
						if (0 === o$1) return 0;
						1 === o$1 && (t$1 = !1);
					}
					return t$1 ? 2 : e$1.aabb.min[0] > this.max[0] || e$1.aabb.min[1] > this.max[1] || e$1.aabb.min[2] > this.max[2] || e$1.aabb.max[0] < this.min[0] || e$1.aabb.max[1] < this.min[1] || e$1.aabb.max[2] < this.min[2] ? 0 : 1;
				}
				intersectsPlane(e$1) {
					let t$1 = e$1[3], i$1 = e$1[3];
					for (let o$1 = 0; o$1 < 3; o$1++) e$1[o$1] > 0 ? (t$1 += e$1[o$1] * this.min[o$1], i$1 += e$1[o$1] * this.max[o$1]) : (i$1 += e$1[o$1] * this.min[o$1], t$1 += e$1[o$1] * this.max[o$1]);
					return t$1 >= 0 ? 2 : i$1 < 0 ? 0 : 1;
				}
			}
			class Dt {
				distanceToTile2d(e$1, t$1, i$1, o$1) {
					const r$1 = o$1.distanceX([e$1, t$1]), a$1 = o$1.distanceY([e$1, t$1]);
					return Math.hypot(r$1, a$1);
				}
				getWrap(e$1, t$1, i$1) {
					return i$1;
				}
				getTileBoundingVolume(e$1, i$1, o$1, r$1) {
					var a$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$2 = new t.Z(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$2);
						n$1 = null !== (a$1 = h$1.minElevation) && void 0 !== a$1 ? a$1 : Math.min(0, o$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, o$1);
					}
					const c$1 = 1 << e$1.z;
					return new zt([
						i$1 + e$1.x / c$1,
						e$1.y / c$1,
						n$1
					], [
						i$1 + (e$1.x + 1) / c$1,
						(e$1.y + 1) / c$1,
						l$1
					]);
				}
				allowVariableZoom(e$1, i$1) {
					const o$1 = e$1.fov * (Math.abs(Math.cos(e$1.rollInRadians)) * e$1.height + Math.abs(Math.sin(e$1.rollInRadians)) * e$1.width) / e$1.height, r$1 = t.ah(78.5 - o$1 / 2, 0, 60);
					return !!i$1.terrain || e$1.pitch > r$1;
				}
				allowWorldCopies() {
					return !0;
				}
				prepareNextFrame() {}
			}
			class At {
				constructor(e$1, t$1, i$1) {
					this.points = e$1, this.planes = t$1, this.aabb = i$1;
				}
				static fromInvProjectionMatrix(e$1, i$1 = 1, o$1 = 0, r$1, a$1) {
					const s$1 = a$1 ? [
						[
							6,
							5,
							4
						],
						[
							0,
							1,
							2
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					] : [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					], n$1 = Math.pow(2, o$1), l$1 = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((o$2) => function(e$2, i$2, o$3, r$2) {
						const a$2 = t.aw([], e$2, i$2), s$2 = 1 / a$2[3] / o$3 * r$2;
						return t.aY(a$2, a$2, [
							s$2,
							s$2,
							1 / a$2[3],
							s$2
						]);
					}(o$2, e$1, i$1, n$1)));
					r$1 && function(e$2, i$2, o$2, r$2) {
						const a$2 = r$2 ? 4 : 0, s$2 = r$2 ? 0 : 4;
						let n$2 = 0;
						const l$2 = [], c$2 = [];
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const o$3 = t.aU([], e$2[i$3 + s$2], e$2[i$3 + a$2]), r$3 = t.aZ(o$3);
							t.aR(o$3, o$3, 1 / r$3), l$2.push(r$3), c$2.push(o$3);
						}
						for (let i$3 = 0; i$3 < 4; i$3++) {
							const r$3 = t.a_(e$2[i$3 + a$2], c$2[i$3], o$2);
							n$2 = null !== r$3 && r$3 >= 0 ? Math.max(n$2, r$3) : Math.max(n$2, l$2[i$3]);
						}
						const h$2 = function(e$3, i$3) {
							const o$3 = t.aU([], e$3[i$3[0]], e$3[i$3[1]]), r$3 = t.aU([], e$3[i$3[2]], e$3[i$3[1]]), a$3 = [
								0,
								0,
								0,
								0
							];
							return t.aV(a$3, t.aW([], o$3, r$3)), a$3[3] = -t.aX(a$3, e$3[i$3[0]]), a$3;
						}(e$2, i$2), u$2 = function(e$3, i$3) {
							const o$3 = t.a$(e$3), r$3 = t.b0([], e$3, 1 / o$3), a$3 = t.aU([], i$3, t.aR([], r$3, t.aX(i$3, r$3))), s$3 = t.a$(a$3);
							if (s$3 > 0) {
								const e$4 = Math.sqrt(1 - r$3[3] * r$3[3]), o$4 = t.aR([], r$3, -r$3[3]), n$3 = t.aS([], o$4, t.aR([], a$3, e$4 / s$3));
								return t.b1(i$3, n$3);
							}
							return null;
						}(o$2, h$2);
						if (null !== u$2) {
							const e$3 = u$2 / t.aX(c$2[0], h$2);
							n$2 = Math.min(n$2, e$3);
						}
						for (let t$1 = 0; t$1 < 4; t$1++) {
							const i$3 = Math.min(n$2, l$2[t$1]);
							e$2[t$1 + s$2] = [
								e$2[t$1 + a$2][0] + c$2[t$1][0] * i$3,
								e$2[t$1 + a$2][1] + c$2[t$1][1] * i$3,
								e$2[t$1 + a$2][2] + c$2[t$1][2] * i$3,
								1
							];
						}
					}(l$1, s$1[0], r$1, a$1);
					const c$1 = s$1.map(((e$2) => {
						const i$2 = t.aU([], l$1[e$2[0]], l$1[e$2[1]]), o$2 = t.aU([], l$1[e$2[2]], l$1[e$2[1]]), r$2 = t.aV([], t.aW([], i$2, o$2)), a$2 = -t.aX(r$2, l$1[e$2[1]]);
						return r$2.concat(a$2);
					})), h$1 = [
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY,
						Number.POSITIVE_INFINITY
					], u$1 = [
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY,
						Number.NEGATIVE_INFINITY
					];
					for (const e$2 of l$1) for (let t$1 = 0; t$1 < 3; t$1++) h$1[t$1] = Math.min(h$1[t$1], e$2[t$1]), u$1[t$1] = Math.max(u$1[t$1], e$2[t$1]);
					return new At(l$1, c$1, new zt(h$1, u$1));
				}
			}
			class Lt {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1, t$1) {}
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Rt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$2, t$2) => this.getConstrained(e$2, t$2)
					}, e$1, t$1, i$1, o$1, r$1), this._coveringTilesDetailsProvider = new Dt();
				}
				clone() {
					const e$1 = new Lt();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1, i$1) {
					this._helper.apply(e$1, t$1, i$1);
				}
				get cameraPosition() {
					return this._cameraPosition;
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._viewProjMatrix;
				}
				get inverseProjectionMatrix() {
					return this._invProjMatrix;
				}
				get mercatorMatrix() {
					return this._mercatorMatrix;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					const i$1 = [new t.b2(0, e$1)];
					if (this._helper._renderWorldCopies) {
						const o$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), r$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), a$1 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s$1 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n$1 = Math.floor(Math.min(o$1.x, r$1.x, a$1.x, s$1.x)), l$1 = Math.floor(Math.max(o$1.x, r$1.x, a$1.x, s$1.x)), c$1 = 1;
						for (let o$2 = n$1 - c$1; o$2 <= l$1 + c$1; o$2++) 0 !== o$2 && i$1.push(new t.b2(o$2, e$1));
					}
					return i$1;
				}
				getCameraFrustum() {
					return At.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
				}
				getClippingPlane() {
					return null;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					const t$1 = this.screenPointToLocation(this.centerPoint, e$1), i$1 = e$1 ? e$1.getElevationForLngLatZoom(t$1, this._helper._tileZoom) : 0;
					this._helper.recalculateZoomAndCenter(i$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const o$1 = t.aj(this.elevation, this.center.lat), r$1 = this.screenPointToMercatorCoordinateAtZ(i$1, o$1), a$1 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o$1), s$1 = t.a1.fromLngLat(e$1), n$1 = new t.a1(s$1.x - (r$1.x - a$1.x), s$1.y - (r$1.y - a$1.y));
					this.setCenter(null == n$1 ? void 0 : n$1.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
				}
				locationToScreenPoint(e$1, i$1) {
					return i$1 ? this.coordinatePoint(t.a1.fromLngLat(e$1), i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.a1.fromLngLat(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					if (t$1) {
						const i$1 = t$1.pointCoordinate(e$1);
						if (null != i$1) return i$1;
					}
					return this.screenPointToMercatorCoordinateAtZ(e$1);
				}
				screenPointToMercatorCoordinateAtZ(e$1, i$1) {
					const o$1 = i$1 || 0, r$1 = [
						e$1.x,
						e$1.y,
						0,
						1
					], a$1 = [
						e$1.x,
						e$1.y,
						1,
						1
					];
					t.aw(r$1, r$1, this._pixelMatrixInverse), t.aw(a$1, a$1, this._pixelMatrixInverse);
					const s$1 = r$1[3], n$1 = a$1[3], l$1 = r$1[1] / s$1, c$1 = a$1[1] / n$1, h$1 = r$1[2] / s$1, u$1 = a$1[2] / n$1, d$1 = h$1 === u$1 ? 0 : (o$1 - h$1) / (u$1 - h$1);
					return new t.a1(t.C.number(r$1[0] / s$1, a$1[0] / n$1, d$1) / this.worldSize, t.C.number(l$1, c$1, d$1) / this.worldSize, o$1);
				}
				coordinatePoint(e$1, i$1 = 0, o$1 = this._pixelMatrix) {
					const r$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aw(r$1, r$1, o$1), new t.P(r$1[0] / r$1[3], r$1[1] / r$1[3]);
				}
				getBounds() {
					const e$1 = Math.max(0, this._helper._height / 2 - he(this));
					return new G().extend(this.screenPointToLocation(new t.P(0, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, e$1))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
				}
				isPointOnMapSurface(e$1, t$1) {
					return t$1 ? null != t$1.pointCoordinate(e$1) : e$1.y > this.height / 2 - he(this);
				}
				calculatePosMatrix(e$1, i$1 = !1, o$1) {
					var r$1;
					const a$1 = null !== (r$1 = e$1.key) && void 0 !== r$1 ? r$1 : t.b3(e$1.wrap, e$1.canonical.z, e$1.canonical.z, e$1.canonical.x, e$1.canonical.y), s$1 = i$1 ? this._alignedPosMatrixCache : this._posMatrixCache;
					if (s$1.has(a$1)) {
						const e$2 = s$1.get(a$1);
						return o$1 ? e$2.f32 : e$2.f64;
					}
					const n$1 = ue(e$1, this.worldSize);
					t.O(n$1, i$1 ? this._alignedProjMatrix : this._viewProjMatrix, n$1);
					const l$1 = {
						f64: n$1,
						f32: new Float32Array(n$1)
					};
					return s$1.set(a$1, l$1), o$1 ? l$1.f32 : l$1.f64;
				}
				calculateFogMatrix(e$1) {
					const i$1 = e$1.key, o$1 = this._fogMatrixCacheF32;
					if (o$1.has(i$1)) return o$1.get(i$1);
					const r$1 = ue(e$1, this.worldSize);
					return t.O(r$1, this._fogMatrix, r$1), o$1.set(i$1, new Float32Array(r$1)), o$1.get(i$1);
				}
				getConstrained(e$1, i$1) {
					i$1 = t.ah(+i$1, this.minZoom, this.maxZoom);
					const o$1 = {
						center: new t.S(e$1.lng, e$1.lat),
						zoom: i$1
					};
					let r$1 = this._helper._lngRange;
					if (!this._helper._renderWorldCopies && null === r$1) {
						const e$2 = 179.9999999999;
						r$1 = [-e$2, e$2];
					}
					const a$1 = this.tileSize * t.af(o$1.zoom);
					let s$1 = 0, n$1 = a$1, l$1 = 0, c$1 = a$1, h$1 = 0, u$1 = 0;
					const { x: d$1, y: _$1 } = this.size;
					if (this._helper._latRange) {
						const e$2 = this._helper._latRange;
						s$1 = t.U(e$2[1]) * a$1, n$1 = t.U(e$2[0]) * a$1, n$1 - s$1 < _$1 && (h$1 = _$1 / (n$1 - s$1));
					}
					r$1 && (l$1 = t.aO(t.V(r$1[0]) * a$1, 0, a$1), c$1 = t.aO(t.V(r$1[1]) * a$1, 0, a$1), c$1 < l$1 && (c$1 += a$1), c$1 - l$1 < d$1 && (u$1 = d$1 / (c$1 - l$1)));
					const { x: p$1, y: m$1 } = le(a$1, e$1);
					let f$1, g$1;
					const v$1 = Math.max(u$1 || 0, h$1 || 0);
					if (v$1) {
						const e$2 = new t.P(u$1 ? (c$1 + l$1) / 2 : p$1, h$1 ? (n$1 + s$1) / 2 : m$1);
						return o$1.center = ce(a$1, e$2).wrap(), o$1.zoom += t.ak(v$1), o$1;
					}
					if (this._helper._latRange) {
						const e$2 = _$1 / 2;
						m$1 - e$2 < s$1 && (g$1 = s$1 + e$2), m$1 + e$2 > n$1 && (g$1 = n$1 - e$2);
					}
					if (r$1) {
						const e$2 = (l$1 + c$1) / 2;
						let i$2 = p$1;
						this._helper._renderWorldCopies && (i$2 = t.aO(p$1, e$2 - a$1 / 2, e$2 + a$1 / 2));
						const o$2 = d$1 / 2;
						i$2 - o$2 < l$1 && (f$1 = l$1 + o$2), i$2 + o$2 > c$1 && (f$1 = c$1 - o$2);
					}
					if (void 0 !== f$1 || void 0 !== g$1) {
						const e$2 = new t.P(null != f$1 ? f$1 : p$1, null != g$1 ? g$1 : m$1);
						o$1.center = ce(a$1, e$2).wrap();
					}
					return o$1;
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				_calculateNearFarZIfNeeded(e$1, i$1, o$1) {
					if (!this._helper.autoCalculateNearFarZ) return;
					const r$1 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a$1 = e$1 - r$1 * this._helper._pixelPerMeter / Math.cos(i$1), s$1 = r$1 < 0 ? a$1 : e$1, n$1 = Math.PI / 2 + this.pitchInRadians, l$1 = t.ae(this.fov) * (Math.abs(Math.cos(t.ae(this.roll))) * this.height + Math.abs(Math.sin(t.ae(this.roll))) * this.width) / this.height * (.5 + o$1.y / this.height), c$1 = Math.sin(l$1) * s$1 / Math.sin(t.ah(Math.PI - n$1 - l$1, .01, Math.PI - .01)), h$1 = he(this), u$1 = Math.atan(h$1 / this._helper.cameraToCenterDistance), d$1 = t.ae(.75), _$1 = u$1 > d$1 ? 2 * u$1 * (.5 + o$1.y / (2 * h$1)) : d$1, p$1 = Math.sin(_$1) * s$1 / Math.sin(t.ah(Math.PI - n$1 - _$1, .01, Math.PI - .01)), m$1 = Math.min(c$1, p$1);
					this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i$1) * m$1 + s$1), this._helper._nearZ = this._helper._height / 50;
				}
				_calcMatrices() {
					if (!this._helper._height) return;
					const e$1 = this.centerOffset, i$1 = le(this.worldSize, this.center), o$1 = i$1.x, r$1 = i$1.y;
					this._helper._pixelPerMeter = t.aj(1, this.center.lat) * this.worldSize;
					const a$1 = t.ae(Math.min(this.pitch, ne)), s$1 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a$1));
					let n$1;
					this._calculateNearFarZIfNeeded(s$1, a$1, e$1), n$1 = new Float64Array(16), t.b4(n$1, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aq(this._invProjMatrix, n$1), n$1[8] = 2 * -e$1.x / this._helper._width, n$1[9] = 2 * e$1.y / this._helper._height, this._projectionMatrix = t.b5(n$1), t.N(n$1, n$1, [
						1,
						-1,
						1
					]), t.M(n$1, n$1, [
						0,
						0,
						-this._helper.cameraToCenterDistance
					]), t.b6(n$1, n$1, -this.rollInRadians), t.b7(n$1, n$1, this.pitchInRadians), t.b6(n$1, n$1, -this.bearingInRadians), t.M(n$1, n$1, [
						-o$1,
						-r$1,
						0
					]), this._mercatorMatrix = t.N([], n$1, [
						this.worldSize,
						this.worldSize,
						this.worldSize
					]), t.N(n$1, n$1, [
						1,
						1,
						this._helper._pixelPerMeter
					]), this._pixelMatrix = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1), t.M(n$1, n$1, [
						0,
						0,
						-this.elevation
					]), this._viewProjMatrix = n$1, this._invViewProjMatrix = t.aq([], n$1);
					const l$1 = [
						0,
						0,
						-1,
						1
					];
					t.aw(l$1, l$1, this._invViewProjMatrix), this._cameraPosition = [
						l$1[0] / l$1[3],
						l$1[1] / l$1[3],
						l$1[2] / l$1[3]
					], this._fogMatrix = new Float64Array(16), t.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, s$1, this._helper._farZ), this._fogMatrix[8] = 2 * -e$1.x / this.width, this._fogMatrix[9] = 2 * e$1.y / this.height, t.N(this._fogMatrix, this._fogMatrix, [
						1,
						-1,
						1
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.M(this._fogMatrix, this._fogMatrix, [
						-o$1,
						-r$1,
						0
					]), t.N(this._fogMatrix, this._fogMatrix, [
						1,
						1,
						this._helper._pixelPerMeter
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.elevation
					]), this._pixelMatrix3D = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, n$1);
					const c$1 = this._helper._width % 2 / 2, h$1 = this._helper._height % 2 / 2, u$1 = Math.cos(this.bearingInRadians), d$1 = Math.sin(-this.bearingInRadians), _$1 = o$1 - Math.round(o$1) + u$1 * c$1 + d$1 * h$1, p$1 = r$1 - Math.round(r$1) + u$1 * h$1 + d$1 * c$1, m$1 = new Float64Array(n$1);
					if (t.M(m$1, m$1, [
						_$1 > .5 ? _$1 - 1 : _$1,
						p$1 > .5 ? p$1 - 1 : p$1,
						0
					]), this._alignedProjMatrix = m$1, n$1 = t.aq(new Float64Array(16), this._pixelMatrix), !n$1) throw new Error("failed to invert matrix");
					this._pixelMatrixInverse = n$1, this._clearMatrixCaches();
				}
				_clearMatrixCaches() {
					this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
				}
				maxPitchScaleFactor() {
					if (!this._pixelMatrixInverse) return 1;
					const e$1 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i$1 = [
						e$1.x * this.worldSize,
						e$1.y * this.worldSize,
						0,
						1
					];
					return t.aw(i$1, i$1, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					const e$1 = t.aj(1, this.center.lat) * this.worldSize;
					return de(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e$1).toLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1), r$1 = [
						o$1.x * this.worldSize,
						o$1.y * this.worldSize,
						i$1,
						1
					];
					return t.aw(r$1, r$1, this._viewProjMatrix), r$1[2] / r$1[3];
				}
				getProjectionData(e$1) {
					const { overscaledTileID: i$1, aligned: o$1, applyTerrainMatrix: r$1 } = e$1, a$1 = this._helper.getMercatorTileCoordinates(i$1), s$1 = i$1 ? this.calculatePosMatrix(i$1, o$1, !0) : null;
					let n$1;
					return n$1 = i$1 && i$1.terrainRttPosMatrix32f && r$1 ? i$1.terrainRttPosMatrix32f : s$1 || t.b8(), {
						mainMatrix: n$1,
						tileMercatorCoords: a$1,
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: n$1
					};
				}
				isLocationOccluded(e$1) {
					return !1;
				}
				getPixelScale() {
					return 1;
				}
				getCircleRadiusCorrection() {
					return 1;
				}
				getPitchedTextCorrection(e$1, t$1, i$1) {
					return 1;
				}
				transformLightDirection(e$1) {
					return t.aT(e$1);
				}
				getRayDirectionFromPixel(e$1) {
					throw new Error("Not implemented.");
				}
				projectTileCoordinates(e$1, i$1, o$1, r$1) {
					const a$1 = this.calculatePosMatrix(o$1);
					let s$1;
					r$1 ? (s$1 = [
						e$1,
						i$1,
						r$1(e$1, i$1),
						1
					], t.aw(s$1, s$1, a$1)) : (s$1 = [
						e$1,
						i$1,
						0,
						1
					], qe(s$1, s$1, a$1));
					const n$1 = s$1[3];
					return {
						point: new t.P(s$1[0] / n$1, s$1[1] / n$1),
						signedDistanceFromCamera: n$1,
						isOccluded: !1
					};
				}
				populateCache(e$1) {
					for (const t$1 of e$1) this.calculatePosMatrix(t$1);
				}
				getMatrixForModel(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1, i$1), r$1 = o$1.meterInMercatorCoordinateUnits(), a$1 = t.b9();
					return t.M(a$1, a$1, [
						o$1.x,
						o$1.y,
						o$1.z
					]), t.b6(a$1, a$1, Math.PI), t.b7(a$1, a$1, Math.PI / 2), t.N(a$1, a$1, [
						-r$1,
						r$1,
						r$1
					]), a$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = new t.Z(0, 0, 0, 0, 0), o$1 = this.getProjectionData({
						overscaledTileID: i$1,
						applyGlobeMatrix: e$1
					}), r$1 = ue(i$1, this.worldSize);
					t.O(r$1, this._viewProjMatrix, r$1), o$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					];
					const a$1 = [
						t.$,
						t.$,
						this.worldSize / this._helper.pixelsPerMeter
					], s$1 = t.ba();
					return t.N(s$1, r$1, a$1), o$1.fallbackMatrix = s$1, o$1.mainMatrix = s$1, o$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.calculatePosMatrix(e$1);
				}
			}
			function kt() {
				t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
			}
			function Ft(e$1) {
				if (e$1.useSlerp) if (e$1.k < 1) {
					const i$1 = t.bb(e$1.startEulerAngles.roll, e$1.startEulerAngles.pitch, e$1.startEulerAngles.bearing), o$1 = t.bb(e$1.endEulerAngles.roll, e$1.endEulerAngles.pitch, e$1.endEulerAngles.bearing), r$1 = new Float64Array(4);
					t.bc(r$1, i$1, o$1, e$1.k);
					const a$1 = t.bd(r$1);
					e$1.tr.setRoll(a$1.roll), e$1.tr.setPitch(a$1.pitch), e$1.tr.setBearing(a$1.bearing);
				} else e$1.tr.setRoll(e$1.endEulerAngles.roll), e$1.tr.setPitch(e$1.endEulerAngles.pitch), e$1.tr.setBearing(e$1.endEulerAngles.bearing);
				else e$1.tr.setRoll(t.C.number(e$1.startEulerAngles.roll, e$1.endEulerAngles.roll, e$1.k)), e$1.tr.setPitch(t.C.number(e$1.startEulerAngles.pitch, e$1.endEulerAngles.pitch, e$1.k)), e$1.tr.setBearing(t.C.number(e$1.startEulerAngles.bearing, e$1.endEulerAngles.bearing, e$1.k));
			}
			function Bt(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = a$1.padding, n$1 = le(a$1.worldSize, o$1.getNorthWest()), l$1 = le(a$1.worldSize, o$1.getNorthEast()), c$1 = le(a$1.worldSize, o$1.getSouthEast()), h$1 = le(a$1.worldSize, o$1.getSouthWest()), u$1 = t.ae(-r$1), d$1 = n$1.rotate(u$1), _$1 = l$1.rotate(u$1), p$1 = c$1.rotate(u$1), m$1 = h$1.rotate(u$1), f$1 = new t.P(Math.max(d$1.x, _$1.x, m$1.x, p$1.x), Math.max(d$1.y, _$1.y, m$1.y, p$1.y)), g$1 = new t.P(Math.min(d$1.x, _$1.x, m$1.x, p$1.x), Math.min(d$1.y, _$1.y, m$1.y, p$1.y)), v$1 = f$1.sub(g$1), b$1 = (a$1.width - (s$1.left + s$1.right + i$1.left + i$1.right)) / v$1.x, x$1 = (a$1.height - (s$1.top + s$1.bottom + i$1.top + i$1.bottom)) / v$1.y;
				if (x$1 < 0 || b$1 < 0) return void kt();
				const y$1 = Math.min(t.ak(a$1.scale * Math.min(b$1, x$1)), e$1.maxZoom), w$1 = t.P.convert(e$1.offset), T$1 = new t.P((i$1.left - i$1.right) / 2, (i$1.top - i$1.bottom) / 2).rotate(t.ae(r$1)), P$1 = w$1.add(T$1).mult(a$1.scale / t.af(y$1));
				return {
					center: ce(a$1.worldSize, n$1.add(c$1).div(2).sub(P$1)),
					zoom: y$1,
					bearing: r$1
				};
			}
			class Ot {
				get useGlobeControls() {
					return !1;
				}
				handlePanInertia(e$1, t$1) {
					const i$1 = e$1.mag(), o$1 = Math.abs(he(t$1));
					return {
						easingOffset: e$1.mult(Math.min(.75 * o$1 / i$1, 1)),
						easingCenter: t$1.center
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					e$1.bearingDelta && t$1.setBearing(t$1.bearing + e$1.bearingDelta), e$1.pitchDelta && t$1.setPitch(t$1.pitch + e$1.pitchDelta), e$1.rollDelta && t$1.setRoll(t$1.roll + e$1.rollDelta), e$1.zoomDelta && t$1.setZoom(t$1.zoom + e$1.zoomDelta);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					e$1.around.distSqr(t$1.centerPoint) < .01 || t$1.setLocationAtPoint(i$1, e$1.around);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1) {
					return Bt(e$1, t$1, i$1, o$1, r$1);
				}
				handleJumpToCenterZoom(e$1, i$1) {
					e$1.zoom !== (void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom) && e$1.setZoom(+i$1.zoom), void 0 !== i$1.center && e$1.setCenter(t.S.convert(i$1.center));
				}
				handleEaseTo(e$1, i$1) {
					const o$1 = e$1.zoom, r$1 = e$1.padding, a$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, s$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, n$1 = void 0 !== i$1.zoom, l$1 = !e$1.isPaddingEqual(i$1.padding);
					let c$1 = !1;
					const h$1 = n$1 ? +i$1.zoom : e$1.zoom;
					let u$1 = e$1.centerPoint.add(i$1.offsetAsPoint);
					const d$1 = e$1.screenPointToLocation(u$1), { center: _$1, zoom: p$1 } = e$1.getConstrained(t.S.convert(i$1.center || d$1), null != h$1 ? h$1 : o$1);
					St(e$1, _$1);
					const m$1 = le(e$1.worldSize, d$1), f$1 = le(e$1.worldSize, _$1).sub(m$1), g$1 = t.af(p$1 - o$1);
					return c$1 = p$1 !== o$1, {
						easeFunc: (n$2) => {
							if (c$1 && e$1.setZoom(t.C.number(o$1, p$1, n$2)), t.be(a$1, s$1) || Ft({
								startEulerAngles: a$1,
								endEulerAngles: s$1,
								tr: e$1,
								k: n$2,
								useSlerp: a$1.roll != s$1.roll
							}), l$1 && (e$1.interpolatePadding(r$1, i$1.padding, n$2), u$1 = e$1.centerPoint.add(i$1.offsetAsPoint)), i$1.around) e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const i$2 = t.af(e$1.zoom - o$1), r$2 = p$1 > o$1 ? Math.min(2, g$1) : Math.max(.5, g$1), a$2 = Math.pow(r$2, 1 - n$2), s$2 = ce(e$1.worldSize, m$1.add(f$1.mult(n$2 * a$2)).mult(i$2));
								e$1.setLocationAtPoint(e$1.renderWorldCopies ? s$2.wrap() : s$2, u$1);
							}
						},
						isZooming: c$1,
						elevationCenter: _$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const o$1 = void 0 !== i$1.zoom, r$1 = e$1.zoom, a$1 = e$1.getConstrained(t.S.convert(i$1.center || i$1.locationAtOffset), o$1 ? +i$1.zoom : r$1), s$1 = a$1.center, n$1 = a$1.zoom;
					St(e$1, s$1);
					const l$1 = le(e$1.worldSize, i$1.locationAtOffset), c$1 = le(e$1.worldSize, s$1).sub(l$1), h$1 = c$1.mag(), u$1 = t.af(n$1 - r$1);
					let d$1;
					if (void 0 !== i$1.minZoom) {
						const o$2 = Math.min(+i$1.minZoom, r$1, n$1), a$2 = e$1.getConstrained(s$1, o$2).zoom;
						d$1 = t.af(a$2 - r$1);
					}
					return {
						easeFunc: (i$2, o$2, a$2, h$2) => {
							e$1.setZoom(1 === i$2 ? n$1 : r$1 + t.ak(o$2));
							const u$2 = 1 === i$2 ? s$1 : ce(e$1.worldSize, l$1.add(c$1.mult(a$2)).mult(o$2));
							e$1.setLocationAtPoint(e$1.renderWorldCopies ? u$2.wrap() : u$2, h$2);
						},
						scaleOfZoom: u$1,
						targetCenter: s$1,
						scaleOfMinZoom: d$1,
						pixelPathLength: h$1
					};
				}
			}
			class jt {
				constructor(e$1, t$1, i$1) {
					this.blendFunction = e$1, this.blendColor = t$1, this.mask = i$1;
				}
			}
			jt.Replace = [1, 0], jt.disabled = new jt(jt.Replace, t.bf.transparent, [
				!1,
				!1,
				!1,
				!1
			]), jt.unblended = new jt(jt.Replace, t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]), jt.alphaBlended = new jt([1, 771], t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			const Nt = 2305;
			class Ut {
				constructor(e$1, t$1, i$1) {
					this.enable = e$1, this.mode = t$1, this.frontFace = i$1;
				}
			}
			Ut.disabled = new Ut(!1, 1029, Nt), Ut.backCCW = new Ut(!0, 1029, Nt), Ut.frontCCW = new Ut(!0, 1028, Nt);
			class Zt {
				constructor(e$1, t$1, i$1) {
					this.func = e$1, this.mask = t$1, this.range = i$1;
				}
			}
			Zt.ReadOnly = !1, Zt.ReadWrite = !0, Zt.disabled = new Zt(519, Zt.ReadOnly, [0, 1]);
			const Gt = 7680;
			class Vt {
				constructor(e$1, t$1, i$1, o$1, r$1, a$1) {
					this.test = e$1, this.ref = t$1, this.mask = i$1, this.fail = o$1, this.depthFail = r$1, this.pass = a$1;
				}
			}
			Vt.disabled = new Vt({
				func: 519,
				mask: 0
			}, 0, 0, Gt, Gt, Gt);
			const $t = /* @__PURE__ */ new WeakMap();
			function qt(e$1) {
				var t$1;
				if ($t.has(e$1)) return $t.get(e$1);
				{
					const i$1 = null === (t$1 = e$1.getParameter(e$1.VERSION)) || void 0 === t$1 ? void 0 : t$1.startsWith("WebGL 2.0");
					return $t.set(e$1, i$1), i$1;
				}
			}
			class Wt {
				get awaitingQuery() {
					return !!this._readbackQueue;
				}
				constructor(e$1) {
					this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e$1;
					const i$1 = e$1.context, o$1 = i$1.gl;
					this._texFormat = o$1.RGBA, this._texType = o$1.UNSIGNED_BYTE;
					const r$1 = new t.aL();
					r$1.emplaceBack(-1, -1), r$1.emplaceBack(2, -1), r$1.emplaceBack(-1, 2);
					const a$1 = new t.aN();
					a$1.emplaceBack(0, 1, 2), this._fullscreenTriangle = new wt(i$1.createVertexBuffer(r$1, Tt.members), i$1.createIndexBuffer(a$1), t.aM.simpleSegment(0, 0, r$1.length, a$1.length)), this._resultBuffer = new Uint8Array(4), i$1.activeTexture.set(o$1.TEXTURE1);
					const s$1 = o$1.createTexture();
					o$1.bindTexture(o$1.TEXTURE_2D, s$1), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_S, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_WRAP_T, o$1.CLAMP_TO_EDGE), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MIN_FILTER, o$1.NEAREST), o$1.texParameteri(o$1.TEXTURE_2D, o$1.TEXTURE_MAG_FILTER, o$1.NEAREST), o$1.texImage2D(o$1.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i$1.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(s$1), qt(o$1) && (this._pbo = o$1.createBuffer(), o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, this._pbo), o$1.bufferData(o$1.PIXEL_PACK_BUFFER, 4, o$1.STREAM_READ), o$1.bindBuffer(o$1.PIXEL_PACK_BUFFER, null));
				}
				destroy() {
					const e$1 = this._cachedRenderContext.context.gl;
					this._fullscreenTriangle.destroy(), this._fbo.destroy(), e$1.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
				}
				updateErrorLoop(e$1, t$1) {
					const i$1 = this._updateCount;
					return this._readbackQueue ? i$1 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i$1 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e$1, t$1), this._updateCount++, this._measuredError;
				}
				_bindFramebuffer() {
					const e$1 = this._cachedRenderContext.context, t$1 = e$1.gl;
					e$1.activeTexture.set(t$1.TEXTURE1), t$1.bindTexture(t$1.TEXTURE_2D, this._fbo.colorAttachment.get()), e$1.bindFramebuffer.set(this._fbo.framebuffer);
				}
				_renderErrorTexture(e$1, i$1) {
					const o$1 = this._cachedRenderContext.context, r$1 = o$1.gl;
					if (this._bindFramebuffer(), o$1.viewport.set([
						0,
						0,
						this._texWidth,
						this._texHeight
					]), o$1.clear({ color: t.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o$1, r$1.TRIANGLES, Zt.disabled, Vt.disabled, jt.unblended, Ut.disabled, ((e$2, t$1) => ({
						u_input: e$2,
						u_output_expected: t$1
					}))(e$1, i$1), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && qt(r$1)) {
						r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, this._pbo), r$1.readBuffer(r$1.COLOR_ATTACHMENT0), r$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), r$1.bindBuffer(r$1.PIXEL_PACK_BUFFER, null);
						const e$2 = r$1.fenceSync(r$1.SYNC_GPU_COMMANDS_COMPLETE, 0);
						r$1.flush(), this._readbackQueue = {
							frameNumberIssued: this._updateCount,
							sync: e$2
						};
					} else this._readbackQueue = {
						frameNumberIssued: this._updateCount,
						sync: null
					};
				}
				_tryReadback() {
					const e$1 = this._cachedRenderContext.context.gl;
					if (this._pbo && this._readbackQueue && qt(e$1)) {
						const i$1 = e$1.clientWaitSync(this._readbackQueue.sync, 0, 0);
						if (i$1 === e$1.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
						if (i$1 === e$1.TIMEOUT_EXPIRED) return;
						e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, this._pbo), e$1.getBufferSubData(e$1.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e$1.bindBuffer(e$1.PIXEL_PACK_BUFFER, null);
					} else this._bindFramebuffer(), e$1.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
					this._readbackQueue = null, this._measuredError = Wt._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
				}
				static _parseRGBA8float(e$1) {
					let t$1 = 0;
					return t$1 += e$1[0] / 256, t$1 += e$1[1] / 65536, t$1 += e$1[2] / 16777216, e$1[3] < 127 && (t$1 = -t$1), t$1 / 128;
				}
			}
			const Ht = t.$ / 128;
			function Xt(e$1, i$1) {
				const o$1 = void 0 !== e$1.granularity ? Math.max(e$1.granularity, 1) : 1, r$1 = o$1 + (e$1.generateBorders ? 2 : 0), a$1 = o$1 + (e$1.extendToNorthPole || e$1.generateBorders ? 1 : 0) + (e$1.extendToSouthPole || e$1.generateBorders ? 1 : 0), s$1 = r$1 + 1, n$1 = a$1 + 1, l$1 = e$1.generateBorders ? -1 : 0, c$1 = e$1.generateBorders || e$1.extendToNorthPole ? -1 : 0, h$1 = o$1 + (e$1.generateBorders ? 1 : 0), u$1 = o$1 + (e$1.generateBorders || e$1.extendToSouthPole ? 1 : 0), d$1 = s$1 * n$1, _$1 = r$1 * a$1 * 6, p$1 = s$1 * n$1 > 65536;
				if (p$1 && "16bit" === i$1) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
				const m$1 = p$1 || "32bit" === i$1, f$1 = new Int16Array(2 * d$1);
				let g$1 = 0;
				for (let i$2 = c$1; i$2 <= u$1; i$2++) for (let r$2 = l$1; r$2 <= h$1; r$2++) {
					let a$2 = r$2 / o$1 * t.$;
					-1 === r$2 && (a$2 = -Ht), r$2 === o$1 + 1 && (a$2 = t.$ + Ht);
					let s$2 = i$2 / o$1 * t.$;
					-1 === i$2 && (s$2 = e$1.extendToNorthPole ? t.bh : -Ht), i$2 === o$1 + 1 && (s$2 = e$1.extendToSouthPole ? t.bi : t.$ + Ht), f$1[g$1++] = a$2, f$1[g$1++] = s$2;
				}
				const v$1 = m$1 ? new Uint32Array(_$1) : new Uint16Array(_$1);
				let b$1 = 0;
				for (let e$2 = 0; e$2 < a$1; e$2++) for (let t$1 = 0; t$1 < r$1; t$1++) {
					const i$2 = t$1 + 1 + e$2 * s$1, o$2 = t$1 + (e$2 + 1) * s$1, r$2 = t$1 + 1 + (e$2 + 1) * s$1;
					v$1[b$1++] = t$1 + e$2 * s$1, v$1[b$1++] = o$2, v$1[b$1++] = i$2, v$1[b$1++] = i$2, v$1[b$1++] = o$2, v$1[b$1++] = r$2;
				}
				return {
					vertices: f$1.buffer.slice(0),
					indices: v$1.buffer.slice(0),
					uses32bitIndices: m$1
				};
			}
			const Kt = new t.aK({
				fill: new t.bj(128, 2),
				line: new t.bj(512, 0),
				tile: new t.bj(128, 32),
				stencil: new t.bj(128, 1),
				circle: 3
			});
			class Yt {
				constructor() {
					this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
				}
				get name() {
					return "vertical-perspective";
				}
				get transitionState() {
					return 1;
				}
				get useSubdivision() {
					return !0;
				}
				get shaderVariantName() {
					return "globe";
				}
				get shaderDefine() {
					return "#define GLOBE";
				}
				get shaderPreludeCode() {
					return xt.projectionGlobe;
				}
				get vertexShaderPreludeCode() {
					return xt.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return Kt;
				}
				get useGlobeControls() {
					return !0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._errorCorrectionUsable;
				}
				destroy() {
					this._errorMeasurement && this._errorMeasurement.destroy();
				}
				updateGPUdependent(e$1) {
					this._errorMeasurement || (this._errorMeasurement = new Wt(e$1));
					const i$1 = t.U(this._errorQueryLatitudeDegrees), o$1 = 2 * Math.atan(Math.exp(Math.PI - i$1 * Math.PI * 2)) - .5 * Math.PI, r$1 = this._errorMeasurement.updateErrorLoop(i$1, o$1), a$1 = s.now();
					r$1 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = r$1, this._errorMeasurementLastChangeTime = a$1);
					const n$1 = Math.min(Math.max((a$1 - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
					this._errorCorrectionUsable = t.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bl(n$1));
				}
				_getMeshKey(e$1) {
					return `${e$1.granularity.toString(36)}_${e$1.generateBorders ? "b" : ""}${e$1.extendToNorthPole ? "n" : ""}${e$1.extendToSouthPole ? "s" : ""}`;
				}
				getMeshFromTileID(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = ("stencil" === r$1 ? Kt.stencil : Kt.tile).getGranularityForZoomLevel(t$1.z);
					return this._getMesh(e$1, {
						granularity: a$1,
						generateBorders: i$1,
						extendToNorthPole: 0 === t$1.y && o$1,
						extendToSouthPole: t$1.y === (1 << t$1.z) - 1 && o$1
					});
				}
				_getMesh(e$1, i$1) {
					const o$1 = this._getMeshKey(i$1);
					if (o$1 in this._tileMeshCache) return this._tileMeshCache[o$1];
					const r$1 = function(e$2, i$2) {
						const o$2 = Xt(i$2, "16bit"), r$2 = t.aL.deserialize({
							arrayBuffer: o$2.vertices,
							length: o$2.vertices.byteLength / 2 / 2
						}), a$1 = t.aN.deserialize({
							arrayBuffer: o$2.indices,
							length: o$2.indices.byteLength / 2 / 3
						});
						return new wt(e$2.createVertexBuffer(r$2, Tt.members), e$2.createIndexBuffer(a$1), t.aM.simpleSegment(0, 0, r$2.length, a$1.length));
					}(e$1, i$1);
					return this._tileMeshCache[o$1] = r$1, r$1;
				}
				recalculate(e$1) {}
				hasTransition() {
					const e$1 = s.now();
					let t$1 = !1;
					return t$1 = t$1 || (e$1 - this._errorMeasurementLastChangeTime) / 1e3 < .7, t$1 = t$1 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t$1;
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._errorQueryLatitudeDegrees = e$1;
				}
			}
			const Qt = new t.r({ type: new t.D(t.v.projection.type) });
			class Jt extends t.E {
				constructor(e$1) {
					super(), this._transitionable = new t.t(Qt, void 0), this.setProjection(e$1), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0)), this._mercatorProjection = new It(), this._verticalPerspectiveProjection = new Yt();
				}
				get transitionState() {
					const e$1 = this.properties.get("type");
					if ("string" == typeof e$1 && "mercator" === e$1) return 0;
					if ("string" == typeof e$1 && "vertical-perspective" === e$1) return 1;
					if (e$1 instanceof t.bm) {
						if ("vertical-perspective" === e$1.from && "mercator" === e$1.to) return 1 - e$1.transition;
						if ("mercator" === e$1.from && "vertical-perspective" === e$1.to) return e$1.transition;
					}
					return 1;
				}
				get useGlobeRendering() {
					return this.transitionState > 0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
				}
				get currentProjection() {
					return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
				}
				get name() {
					return "globe";
				}
				get useSubdivision() {
					return this.currentProjection.useSubdivision;
				}
				get shaderVariantName() {
					return this.currentProjection.shaderVariantName;
				}
				get shaderDefine() {
					return this.currentProjection.shaderDefine;
				}
				get shaderPreludeCode() {
					return this.currentProjection.shaderPreludeCode;
				}
				get vertexShaderPreludeCode() {
					return this.currentProjection.vertexShaderPreludeCode;
				}
				get subdivisionGranularity() {
					return this.currentProjection.subdivisionGranularity;
				}
				get useGlobeControls() {
					return this.transitionState > 0;
				}
				destroy() {
					this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
				}
				updateGPUdependent(e$1) {
					this._mercatorProjection.updateGPUdependent(e$1), this._verticalPerspectiveProjection.updateGPUdependent(e$1);
				}
				getMeshFromTileID(e$1, t$1, i$1, o$1, r$1) {
					return this.currentProjection.getMeshFromTileID(e$1, t$1, i$1, o$1, r$1);
				}
				setProjection(e$1) {
					this._transitionable.setValue("type", (null == e$1 ? void 0 : e$1.type) || "mercator");
				}
				updateTransitions(e$1) {
					this._transitioning = this._transitionable.transitioned(e$1, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
				}
				recalculate(e$1) {
					this.properties = this._transitioning.possiblyEvaluate(e$1);
				}
				setErrorQueryLatitudeDegrees(e$1) {
					this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e$1), this._mercatorProjection.setErrorQueryLatitudeDegrees(e$1);
				}
			}
			function ei(e$1) {
				const t$1 = oi(e$1.worldSize, e$1.center.lat);
				return 2 * Math.PI * t$1;
			}
			function ti(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = 1 / (1 << a$1), n$1 = i$1 / t.$ * s$1 + r$1 * s$1, l$1 = t.bo((e$1 / t.$ * s$1 + o$1 * s$1) * Math.PI * 2 + Math.PI, 2 * Math.PI), c$1 = 2 * Math.atan(Math.exp(Math.PI - n$1 * Math.PI * 2)) - .5 * Math.PI, h$1 = Math.cos(c$1), u$1 = new Float64Array(3);
				return u$1[0] = Math.sin(l$1) * h$1, u$1[1] = Math.sin(c$1), u$1[2] = Math.cos(l$1) * h$1, u$1;
			}
			function ii(e$1) {
				return function(e$2, t$1) {
					const i$1 = Math.cos(t$1), o$1 = new Float64Array(3);
					return o$1[0] = Math.sin(e$2) * i$1, o$1[1] = Math.sin(t$1), o$1[2] = Math.cos(e$2) * i$1, o$1;
				}(e$1.lng * Math.PI / 180, e$1.lat * Math.PI / 180);
			}
			function oi(e$1, t$1) {
				return e$1 / (2 * Math.PI) / Math.cos(t$1 * Math.PI / 180);
			}
			function ri(e$1) {
				const i$1 = Math.asin(e$1[1]) / Math.PI * 180, o$1 = Math.sqrt(e$1[0] * e$1[0] + e$1[2] * e$1[2]);
				if (o$1 > 1e-6) {
					const r$1 = e$1[0] / o$1, a$1 = Math.acos(e$1[2] / o$1), s$1 = (r$1 > 0 ? a$1 : -a$1) / Math.PI * 180;
					return new t.S(t.aO(s$1, -180, 180), i$1);
				}
				return new t.S(0, i$1);
			}
			function ai(e$1) {
				return Math.cos(e$1 * Math.PI / 180);
			}
			function si(e$1, i$1) {
				const o$1 = ai(e$1), r$1 = ai(i$1);
				return t.ak(r$1 / o$1);
			}
			function ni(e$1, i$1) {
				const o$1 = e$1.rotate(i$1.bearingInRadians), r$1 = i$1.zoom + si(i$1.center.lat, 0), a$1 = t.bk(1 / ai(i$1.center.lat), 1 / ai(Math.min(Math.abs(i$1.center.lat), 60)), t.bn(r$1, 7, 3, 0, 1)), s$1 = 360 / ei({
					worldSize: i$1.worldSize,
					center: { lat: i$1.center.lat }
				});
				return new t.S(i$1.center.lng - o$1.x * s$1 * a$1, t.ah(i$1.center.lat + o$1.y * s$1, -t.ai, t.ai));
			}
			function li(e$1) {
				const t$1 = .5 * e$1, i$1 = Math.sin(t$1), o$1 = Math.cos(t$1);
				return Math.log(i$1 + o$1) - Math.log(o$1 - i$1);
			}
			function ci(e$1, i$1, o$1, r$1) {
				const a$1 = e$1.lat + o$1 * r$1;
				if (Math.abs(o$1) > 1) {
					const s$1 = (Math.sign(e$1.lat + o$1) !== Math.sign(e$1.lat) ? -Math.abs(e$1.lat) : Math.abs(e$1.lat)) * Math.PI / 180, n$1 = Math.abs(e$1.lat + o$1) * Math.PI / 180, l$1 = li(s$1 + r$1 * (n$1 - s$1)), c$1 = li(s$1), h$1 = li(n$1);
					return new t.S(e$1.lng + i$1 * ((l$1 - c$1) / (h$1 - c$1)), a$1);
				}
				return new t.S(e$1.lng + i$1 * r$1, a$1);
			}
			class hi {
				constructor(e$1) {
					this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e$1;
				}
				swapBuffers() {
					if (!this._hadAnyChanges) return;
					const e$1 = this._cachePrevious;
					this._cachePrevious = this._cache, this._cache = e$1, this._cache.clear(), this._hadAnyChanges = !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, o$1) {
					const r$1 = `${e$1.z}_${e$1.x}_${e$1.y}_${(null == o$1 ? void 0 : o$1.terrain) ? "t" : ""}`, a$1 = this._cache.get(r$1);
					if (a$1) return a$1;
					const s$1 = this._cachePrevious.get(r$1);
					if (s$1) return this._cache.set(r$1, s$1), s$1;
					const n$1 = this._boundingVolumeFactory(e$1, t$1, i$1, o$1);
					return this._cache.set(r$1, n$1), this._hadAnyChanges = !0, n$1;
				}
			}
			class ui {
				constructor(e$1, t$1, i$1, o$1) {
					this.min = i$1, this.max = o$1, this.points = e$1, this.planes = t$1;
				}
				static fromAabb(e$1, t$1) {
					const i$1 = [];
					for (let o$1 = 0; o$1 < 8; o$1++) i$1.push([
						1 & ~o$1 ? e$1[0] : t$1[0],
						1 == (o$1 >> 1 & 1) ? t$1[1] : e$1[1],
						1 == (o$1 >> 2 & 1) ? t$1[2] : e$1[2]
					]);
					return new ui(i$1, [
						[
							-1,
							0,
							0,
							t$1[0]
						],
						[
							1,
							0,
							0,
							-e$1[0]
						],
						[
							0,
							-1,
							0,
							t$1[1]
						],
						[
							0,
							1,
							0,
							-e$1[1]
						],
						[
							0,
							0,
							-1,
							t$1[2]
						],
						[
							0,
							0,
							1,
							-e$1[2]
						]
					], e$1, t$1);
				}
				static fromCenterSizeAngles(e$1, i$1, o$1) {
					const r$1 = t.br([], o$1[0], o$1[1], o$1[2]), a$1 = t.bs([], [
						i$1[0],
						0,
						0
					], r$1), s$1 = t.bs([], [
						0,
						i$1[1],
						0
					], r$1), n$1 = t.bs([], [
						0,
						0,
						i$1[2]
					], r$1), l$1 = [...e$1], c$1 = [...e$1];
					for (let t$1 = 0; t$1 < 8; t$1++) for (let i$2 = 0; i$2 < 3; i$2++) {
						const o$2 = e$1[i$2] + a$1[i$2] * (1 & ~t$1 ? -1 : 1) + s$1[i$2] * (1 == (t$1 >> 1 & 1) ? 1 : -1) + n$1[i$2] * (1 == (t$1 >> 2 & 1) ? 1 : -1);
						l$1[i$2] = Math.min(l$1[i$2], o$2), c$1[i$2] = Math.max(c$1[i$2], o$2);
					}
					const h$1 = [];
					for (let i$2 = 0; i$2 < 8; i$2++) {
						const o$2 = [...e$1];
						t.aS(o$2, o$2, t.aR([], a$1, 1 & ~i$2 ? -1 : 1)), t.aS(o$2, o$2, t.aR([], s$1, 1 == (i$2 >> 1 & 1) ? 1 : -1)), t.aS(o$2, o$2, t.aR([], n$1, 1 == (i$2 >> 2 & 1) ? 1 : -1)), h$1.push(o$2);
					}
					return new ui(h$1, [
						[...a$1, -t.aX(a$1, h$1[0])],
						[...s$1, -t.aX(s$1, h$1[0])],
						[...n$1, -t.aX(n$1, h$1[0])],
						[
							-a$1[0],
							-a$1[1],
							-a$1[2],
							-t.aX(a$1, h$1[7])
						],
						[
							-s$1[0],
							-s$1[1],
							-s$1[2],
							-t.aX(s$1, h$1[7])
						],
						[
							-n$1[0],
							-n$1[1],
							-n$1[2],
							-t.aX(n$1, h$1[7])
						]
					], l$1, c$1);
				}
				intersectsFrustum(e$1) {
					let t$1 = !0;
					const i$1 = this.points.length, o$1 = this.planes.length, r$1 = e$1.planes.length, a$1 = e$1.points.length;
					for (let o$2 = 0; o$2 < r$1; o$2++) {
						const r$2 = e$1.planes[o$2];
						let a$2 = 0;
						for (let e$2 = 0; e$2 < i$1; e$2++) {
							const t$2 = this.points[e$2];
							r$2[0] * t$2[0] + r$2[1] * t$2[1] + r$2[2] * t$2[2] + r$2[3] >= 0 && a$2++;
						}
						if (0 === a$2) return 0;
						a$2 < i$1 && (t$1 = !1);
					}
					if (t$1) return 2;
					for (let t$2 = 0; t$2 < o$1; t$2++) {
						const i$2 = this.planes[t$2];
						let o$2 = 0;
						for (let t$3 = 0; t$3 < a$1; t$3++) {
							const r$2 = e$1.points[t$3];
							i$2[0] * r$2[0] + i$2[1] * r$2[1] + i$2[2] * r$2[2] + i$2[3] >= 0 && o$2++;
						}
						if (0 === o$2) return 0;
					}
					return 1;
				}
				intersectsPlane(e$1) {
					const t$1 = this.points.length;
					let i$1 = 0;
					for (let o$1 = 0; o$1 < t$1; o$1++) {
						const t$2 = this.points[o$1];
						e$1[0] * t$2[0] + e$1[1] * t$2[1] + e$1[2] * t$2[2] + e$1[3] >= 0 && i$1++;
					}
					return i$1 === t$1 ? 2 : 0 === i$1 ? 0 : 1;
				}
			}
			function di(e$1, t$1, i$1) {
				const o$1 = e$1 - t$1;
				return o$1 < 0 ? -o$1 : Math.max(0, o$1 - i$1);
			}
			function _i(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1 - i$1;
				let s$1;
				return s$1 = a$1 < 0 ? Math.min(-a$1, 1 + a$1 - r$1) : a$1 > 1 ? Math.min(Math.max(a$1 - r$1, 0), 1 - a$1) : 0, Math.max(s$1, di(t$1, o$1, r$1));
			}
			class pi {
				constructor() {
					this._boundingVolumeCache = new hi(this._computeTileBoundingVolume);
				}
				prepareNextFrame() {
					this._boundingVolumeCache.swapBuffers();
				}
				distanceToTile2d(e$1, t$1, i$1, o$1) {
					const r$1 = 1 << i$1.z, a$1 = 1 / r$1, s$1 = i$1.x / r$1, n$1 = i$1.y / r$1;
					let l$1 = 2;
					return l$1 = Math.min(l$1, _i(e$1, t$1, s$1, n$1, a$1)), l$1 = Math.min(l$1, _i(e$1, t$1, s$1 + .5, -n$1 - a$1, a$1)), l$1 = Math.min(l$1, _i(e$1, t$1, s$1 + .5, 2 - n$1 - a$1, a$1)), l$1;
				}
				getWrap(e$1, t$1, i$1) {
					const o$1 = 1 << t$1.z, r$1 = 1 / o$1, a$1 = t$1.x / o$1, s$1 = di(e$1.x, a$1, r$1), n$1 = di(e$1.x, a$1 - 1, r$1), l$1 = di(e$1.x, a$1 + 1, r$1), c$1 = Math.min(s$1, n$1, l$1);
					return c$1 === l$1 ? 1 : c$1 === n$1 ? -1 : 0;
				}
				allowVariableZoom(e$1, t$1) {
					return ge(e$1, t$1) > 4;
				}
				allowWorldCopies() {
					return !1;
				}
				getTileBoundingVolume(e$1, t$1, i$1, o$1) {
					return this._boundingVolumeCache.getTileBoundingVolume(e$1, t$1, i$1, o$1);
				}
				_computeTileBoundingVolume(e$1, i$1, o$1, r$1) {
					var a$1, s$1;
					let n$1 = 0, l$1 = 0;
					if (null == r$1 ? void 0 : r$1.terrain) {
						const c$1 = new t.Z(e$1.z, i$1, e$1.z, e$1.x, e$1.y), h$1 = r$1.terrain.getMinMaxElevation(c$1);
						n$1 = null !== (a$1 = h$1.minElevation) && void 0 !== a$1 ? a$1 : Math.min(0, o$1), l$1 = null !== (s$1 = h$1.maxElevation) && void 0 !== s$1 ? s$1 : Math.max(0, o$1);
					}
					if (n$1 /= t.bu, l$1 /= t.bu, n$1 += 1, l$1 += 1, e$1.z <= 0) return ui.fromAabb([
						-l$1,
						-l$1,
						-l$1
					], [
						l$1,
						l$1,
						l$1
					]);
					if (1 === e$1.z) return ui.fromAabb([
						0 === e$1.x ? -l$1 : 0,
						0 === e$1.y ? 0 : -l$1,
						-l$1
					], [
						0 === e$1.x ? 0 : l$1,
						0 === e$1.y ? l$1 : 0,
						l$1
					]);
					{
						const i$2 = [
							ti(0, 0, e$1.x, e$1.y, e$1.z),
							ti(t.$, 0, e$1.x, e$1.y, e$1.z),
							ti(t.$, t.$, e$1.x, e$1.y, e$1.z),
							ti(0, t.$, e$1.x, e$1.y, e$1.z)
						], o$2 = [];
						for (const e$2 of i$2) o$2.push(t.aR([], e$2, l$1));
						if (l$1 !== n$1) for (const e$2 of i$2) o$2.push(t.aR([], e$2, n$1));
						0 === e$1.y && o$2.push([
							0,
							1,
							0
						]), e$1.y === (1 << e$1.z) - 1 && o$2.push([
							0,
							-1,
							0
						]);
						const r$2 = [
							1,
							1,
							1
						], a$2 = [
							-1,
							-1,
							-1
						];
						for (const e$2 of o$2) for (let t$1 = 0; t$1 < 3; t$1++) r$2[t$1] = Math.min(r$2[t$1], e$2[t$1]), a$2[t$1] = Math.max(a$2[t$1], e$2[t$1]);
						const s$2 = ti(t.$ / 2, t.$ / 2, e$1.x, e$1.y, e$1.z), c$1 = t.aW([], [
							0,
							1,
							0
						], s$2);
						t.aV(c$1, c$1);
						const h$1 = t.aW([], s$2, c$1);
						t.aV(h$1, h$1);
						const u$1 = t.aW([], i$2[2], i$2[1]);
						t.aV(u$1, u$1);
						const d$1 = t.aW([], i$2[0], i$2[3]);
						t.aV(d$1, d$1), o$2.push(t.aR([], s$2, l$1)), e$1.y >= (1 << e$1.z) / 2 && o$2.push(t.aR([], ti(t.$ / 2, 0, e$1.x, e$1.y, e$1.z), l$1)), e$1.y < (1 << e$1.z) / 2 && o$2.push(t.aR([], ti(t.$ / 2, t.$, e$1.x, e$1.y, e$1.z), l$1));
						const _$1 = mi(s$2, o$2), p$1 = mi(h$1, o$2), m$1 = [
							-s$2[0],
							-s$2[1],
							-s$2[2],
							_$1.max
						], f$1 = [
							s$2[0],
							s$2[1],
							s$2[2],
							-_$1.min
						], g$1 = [
							-h$1[0],
							-h$1[1],
							-h$1[2],
							p$1.max
						], v$1 = [
							h$1[0],
							h$1[1],
							h$1[2],
							-p$1.min
						], b$1 = [...u$1, 0], x$1 = [...d$1, 0], y$1 = [];
						return 0 === e$1.y ? y$1.push(t.bt(x$1, b$1, m$1), t.bt(x$1, b$1, f$1)) : y$1.push(t.bt(g$1, b$1, m$1), t.bt(g$1, b$1, f$1), t.bt(g$1, x$1, m$1), t.bt(g$1, x$1, f$1)), e$1.y === (1 << e$1.z) - 1 ? y$1.push(t.bt(x$1, b$1, m$1), t.bt(x$1, b$1, f$1)) : y$1.push(t.bt(v$1, b$1, m$1), t.bt(v$1, b$1, f$1), t.bt(v$1, x$1, m$1), t.bt(v$1, x$1, f$1)), new ui(y$1, [
							m$1,
							f$1,
							g$1,
							v$1,
							b$1,
							x$1
						], r$2, a$2);
					}
				}
			}
			function mi(e$1, i$1) {
				let o$1 = Infinity, r$1 = -Infinity;
				for (const a$1 of i$1) {
					const i$2 = t.aX(e$1, a$1);
					o$1 = Math.min(o$1, i$2), r$1 = Math.max(r$1, i$2);
				}
				return {
					min: o$1,
					max: r$1
				};
			}
			class fi {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1) {
					this._helper.resize(e$1, t$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e$1) {}
				constructor() {
					this._cachedClippingPlane = t.bv(), this._projectionMatrix = t.b9(), this._globeViewProjMatrix32f = t.b8(), this._globeViewProjMatrixNoCorrection = t.b9(), this._globeViewProjMatrixNoCorrectionInverted = t.b9(), this._globeProjMatrixInverted = t.b9(), this._cameraPosition = t.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Rt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$1, t$1) => this.getConstrained(e$1, t$1)
					}), this._coveringTilesDetailsProvider = new pi();
				}
				clone() {
					const e$1 = new fi();
					return e$1.apply(this), e$1;
				}
				apply(e$1, t$1) {
					this._globeLatitudeErrorCorrectionRadians = t$1 || 0, this._helper.apply(e$1);
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._globeViewProjMatrixNoCorrection;
				}
				get inverseProjectionMatrix() {
					return this._globeProjMatrixInverted;
				}
				get cameraPosition() {
					const e$1 = t.bp();
					return e$1[0] = this._cameraPosition[0], e$1[1] = this._cameraPosition[1], e$1[2] = this._cameraPosition[2], e$1;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				getProjectionData(e$1) {
					const { overscaledTileID: t$1, applyGlobeMatrix: i$1 } = e$1, o$1 = this._helper.getMercatorTileCoordinates(t$1);
					return {
						mainMatrix: this._globeViewProjMatrix32f,
						tileMercatorCoords: o$1,
						clippingPlane: this._cachedClippingPlane,
						projectionTransition: i$1 ? 1 : 0,
						fallbackMatrix: this._globeViewProjMatrix32f
					};
				}
				_computeClippingPlane(e$1) {
					const i$1 = this.pitchInRadians, o$1 = this.cameraToCenterDistance / e$1, r$1 = Math.sin(i$1) * o$1, a$1 = Math.cos(i$1) * o$1 + 1, s$1 = 1 / Math.sqrt(r$1 * r$1 + a$1 * a$1) * 1;
					let n$1 = -r$1, l$1 = a$1;
					const c$1 = Math.sqrt(n$1 * n$1 + l$1 * l$1);
					n$1 /= c$1, l$1 /= c$1;
					const h$1 = [
						0,
						n$1,
						l$1
					];
					t.bw(h$1, h$1, [
						0,
						0,
						0
					], -this.bearingInRadians), t.bx(h$1, h$1, [
						0,
						0,
						0
					], -1 * this.center.lat * Math.PI / 180), t.by(h$1, h$1, [
						0,
						0,
						0
					], this.center.lng * Math.PI / 180);
					const u$1 = 1 / t.aZ(h$1);
					return t.aR(h$1, h$1, u$1), [...h$1, -s$1 * u$1];
				}
				isLocationOccluded(e$1) {
					return !this.isSurfacePointVisible(ii(e$1));
				}
				transformLightDirection(e$1) {
					const i$1 = this._helper._center.lng * Math.PI / 180, o$1 = this._helper._center.lat * Math.PI / 180, r$1 = Math.cos(o$1), a$1 = [
						Math.sin(i$1) * r$1,
						Math.sin(o$1),
						Math.cos(i$1) * r$1
					], s$1 = [
						a$1[2],
						0,
						-a$1[0]
					], n$1 = [
						0,
						0,
						0
					];
					t.aW(n$1, s$1, a$1), t.aV(s$1, s$1), t.aV(n$1, n$1);
					const l$1 = [
						0,
						0,
						0
					];
					return t.aV(l$1, [
						s$1[0] * e$1[0] + n$1[0] * e$1[1] + a$1[0] * e$1[2],
						s$1[1] * e$1[0] + n$1[1] * e$1[1] + a$1[1] * e$1[2],
						s$1[2] * e$1[0] + n$1[2] * e$1[1] + a$1[2] * e$1[2]
					]), l$1;
				}
				getPixelScale() {
					return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getCircleRadiusCorrection() {
					return Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getPitchedTextCorrection(e$1, i$1, o$1) {
					const r$1 = function(e$2, i$2, o$2) {
						const r$2 = 1 / (1 << o$2.z);
						return new t.a1(e$2 / t.$ * r$2 + o$2.x * r$2, i$2 / t.$ * r$2 + o$2.y * r$2);
					}(e$1, i$1, o$1.canonical), a$1 = (s$1 = r$1.y, [t.bo(r$1.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s$1 * Math.PI * 2)) - .5 * Math.PI]);
					var s$1;
					return this.getCircleRadiusCorrection() / Math.cos(a$1[1]);
				}
				projectTileCoordinates(e$1, i$1, o$1, r$1) {
					const a$1 = o$1.canonical, s$1 = ti(e$1, i$1, a$1.x, a$1.y, a$1.z), n$1 = 1 + (r$1 ? r$1(e$1, i$1) : 0) / t.bu, l$1 = [
						s$1[0] * n$1,
						s$1[1] * n$1,
						s$1[2] * n$1,
						1
					];
					t.aw(l$1, l$1, this._globeViewProjMatrixNoCorrection);
					const c$1 = this._cachedClippingPlane, h$1 = c$1[0] * s$1[0] + c$1[1] * s$1[1] + c$1[2] * s$1[2] + c$1[3] < 0;
					return {
						point: new t.P(l$1[0] / l$1[3], l$1[1] / l$1[3]),
						signedDistanceFromCamera: l$1[3],
						isOccluded: h$1
					};
				}
				_calcMatrices() {
					if (!this._helper._width || !this._helper._height) return;
					const e$1 = oi(this.worldSize, this.center.lat), i$1 = t.ba(), o$1 = t.ba();
					this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e$1), t.b4(i$1, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
					const r$1 = this.centerOffset;
					i$1[8] = 2 * -r$1.x / this._helper._width, i$1[9] = 2 * r$1.y / this._helper._height, this._projectionMatrix = t.b5(i$1), this._globeProjMatrixInverted = t.ba(), t.aq(this._globeProjMatrixInverted, i$1), t.M(i$1, i$1, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(i$1, i$1, this.rollInRadians), t.b7(i$1, i$1, -this.pitchInRadians), t.b6(i$1, i$1, this.bearingInRadians), t.M(i$1, i$1, [
						0,
						0,
						-e$1
					]);
					const a$1 = t.bp();
					a$1[0] = e$1, a$1[1] = e$1, a$1[2] = e$1, t.b7(o$1, i$1, this.center.lat * Math.PI / 180), t.bz(o$1, o$1, -this.center.lng * Math.PI / 180), t.N(o$1, o$1, a$1), this._globeViewProjMatrixNoCorrection = o$1, t.b7(i$1, i$1, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bz(i$1, i$1, -this.center.lng * Math.PI / 180), t.N(i$1, i$1, a$1), this._globeViewProjMatrix32f = new Float32Array(i$1), this._globeViewProjMatrixNoCorrectionInverted = t.ba(), t.aq(this._globeViewProjMatrixNoCorrectionInverted, o$1);
					const s$1 = t.bp();
					this._cameraPosition = t.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e$1, t.bw(this._cameraPosition, this._cameraPosition, s$1, -this.rollInRadians), t.bx(this._cameraPosition, this._cameraPosition, s$1, this.pitchInRadians), t.bw(this._cameraPosition, this._cameraPosition, s$1, -this.bearingInRadians), t.aS(this._cameraPosition, this._cameraPosition, [
						0,
						0,
						1
					]), t.bx(this._cameraPosition, this._cameraPosition, s$1, -this.center.lat * Math.PI / 180), t.by(this._cameraPosition, this._cameraPosition, s$1, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e$1);
					const n$1 = t.b5(this._globeViewProjMatrixNoCorrectionInverted);
					t.N(n$1, n$1, [
						1,
						1,
						-1
					]), this._cachedFrustum = At.fromInvProjectionMatrix(n$1, 1, 0, this._cachedClippingPlane, !0);
				}
				calculateFogMatrix(e$1) {
					t.w("calculateFogMatrix is not supported on globe projection.");
					const i$1 = t.ba();
					return t.ag(i$1), i$1;
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return [new t.b2(0, e$1)];
				}
				getCameraFrustum() {
					return this._cachedFrustum;
				}
				getClippingPlane() {
					return this._cachedClippingPlane;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e$1) {
					e$1 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
				}
				maxPitchScaleFactor() {
					return 1;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, i$1) {
					if (!this._globeViewProjMatrixNoCorrection) return 1;
					const o$1 = ii(e$1);
					t.aR(o$1, o$1, 1 + i$1 / t.bu);
					const r$1 = t.bv();
					return t.aw(r$1, [
						o$1[0],
						o$1[1],
						o$1[2],
						1
					], this._globeViewProjMatrixNoCorrection), r$1[2] / r$1[3];
				}
				populateCache(e$1) {}
				getBounds() {
					const e$1 = .5 * this.width, i$1 = .5 * this.height, o$1 = [
						new t.P(0, 0),
						new t.P(e$1, 0),
						new t.P(this.width, 0),
						new t.P(this.width, i$1),
						new t.P(this.width, this.height),
						new t.P(e$1, this.height),
						new t.P(0, this.height),
						new t.P(0, i$1)
					], r$1 = [];
					for (const e$2 of o$1) r$1.push(this.unprojectScreenPoint(e$2));
					let a$1 = 0, s$1 = 0, n$1 = 0, l$1 = 0;
					const c$1 = this.center;
					for (const e$2 of r$1) {
						const i$2 = t.bA(c$1.lng, e$2.lng), o$2 = t.bA(c$1.lat, e$2.lat);
						i$2 < s$1 && (s$1 = i$2), i$2 > a$1 && (a$1 = i$2), o$2 < l$1 && (l$1 = o$2), o$2 > n$1 && (n$1 = o$2);
					}
					const h$1 = [
						c$1.lng + s$1,
						c$1.lat + l$1,
						c$1.lng + a$1,
						c$1.lat + n$1
					];
					return this.isSurfacePointOnScreen([
						0,
						1,
						0
					]) && (h$1[3] = 90, h$1[0] = -180, h$1[2] = 180), this.isSurfacePointOnScreen([
						0,
						-1,
						0
					]) && (h$1[1] = -90, h$1[0] = -180, h$1[2] = 180), new G(h$1);
				}
				getConstrained(e$1, i$1) {
					const o$1 = t.ah(e$1.lat, -t.ai, t.ai), r$1 = t.ah(+i$1, this.minZoom + si(0, o$1), this.maxZoom);
					return {
						center: new t.S(e$1.lng, o$1),
						zoom: r$1
					};
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				setLocationAtPoint(e$1, i$1) {
					const o$1 = ii(this.unprojectScreenPoint(i$1)), r$1 = ii(e$1), a$1 = t.bp();
					t.bB(a$1);
					const s$1 = t.bp();
					t.by(s$1, o$1, a$1, -this.center.lng * Math.PI / 180), t.bx(s$1, s$1, a$1, this.center.lat * Math.PI / 180);
					const n$1 = r$1[0] * r$1[0] + r$1[2] * r$1[2], l$1 = s$1[0] * s$1[0];
					if (n$1 < l$1) return;
					const c$1 = Math.sqrt(n$1 - l$1), h$1 = -c$1, u$1 = t.bC(r$1[0], r$1[2], s$1[0], c$1), d$1 = t.bC(r$1[0], r$1[2], s$1[0], h$1), _$1 = t.bp();
					t.by(_$1, r$1, a$1, -u$1);
					const p$1 = t.bC(_$1[1], _$1[2], s$1[1], s$1[2]), m$1 = t.bp();
					t.by(m$1, r$1, a$1, -d$1);
					const f$1 = t.bC(m$1[1], m$1[2], s$1[1], s$1[2]), g$1 = .5 * Math.PI, v$1 = p$1 >= -g$1 && p$1 <= g$1, b$1 = f$1 >= -g$1 && f$1 <= g$1;
					let x$1, y$1;
					if (v$1 && b$1) {
						const e$2 = this.center.lng * Math.PI / 180, i$2 = this.center.lat * Math.PI / 180;
						t.bD(u$1, e$2) + t.bD(p$1, i$2) < t.bD(d$1, e$2) + t.bD(f$1, i$2) ? (x$1 = u$1, y$1 = p$1) : (x$1 = d$1, y$1 = f$1);
					} else if (v$1) x$1 = u$1, y$1 = p$1;
					else {
						if (!b$1) return;
						x$1 = d$1, y$1 = f$1;
					}
					const w$1 = x$1 / Math.PI * 180, T$1 = y$1 / Math.PI * 180, P$1 = this.center.lat;
					this.setCenter(new t.S(w$1, t.ah(T$1, -90, 90))), this.setZoom(this.zoom + si(P$1, this.center.lat));
				}
				locationToScreenPoint(e$1, i$1) {
					const o$1 = ii(e$1);
					if (i$1) {
						const r$1 = i$1.getElevationForLngLatZoom(e$1, this._helper._tileZoom);
						t.aR(o$1, o$1, 1 + r$1 / t.bu);
					}
					return this._projectSurfacePointToScreen(o$1);
				}
				_projectSurfacePointToScreen(e$1) {
					const i$1 = t.bv();
					return t.aw(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], new t.P((.5 * i$1[0] + .5) * this.width, (.5 * -i$1[1] + .5) * this.height);
				}
				screenPointToMercatorCoordinate(e$1, i$1) {
					if (i$1) {
						const t$1 = i$1.pointCoordinate(e$1);
						if (t$1) return t$1;
					}
					return t.a1.fromLngLat(this.unprojectScreenPoint(e$1));
				}
				screenPointToLocation(e$1, t$1) {
					var i$1;
					return null === (i$1 = this.screenPointToMercatorCoordinate(e$1, t$1)) || void 0 === i$1 ? void 0 : i$1.toLngLat();
				}
				isPointOnMapSurface(e$1, t$1) {
					const i$1 = this._cameraPosition, o$1 = this.getRayDirectionFromPixel(e$1);
					return !!this.rayPlanetIntersection(i$1, o$1);
				}
				getRayDirectionFromPixel(e$1) {
					const i$1 = t.bv();
					i$1[0] = e$1.x / this.width * 2 - 1, i$1[1] = -1 * (e$1.y / this.height * 2 - 1), i$1[2] = 1, i$1[3] = 1, t.aw(i$1, i$1, this._globeViewProjMatrixNoCorrectionInverted), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3];
					const o$1 = t.bp();
					o$1[0] = i$1[0] - this._cameraPosition[0], o$1[1] = i$1[1] - this._cameraPosition[1], o$1[2] = i$1[2] - this._cameraPosition[2];
					const r$1 = t.bp();
					return t.aV(r$1, o$1), r$1;
				}
				isSurfacePointVisible(e$1) {
					const t$1 = this._cachedClippingPlane;
					return t$1[0] * e$1[0] + t$1[1] * e$1[1] + t$1[2] * e$1[2] + t$1[3] >= 0;
				}
				isSurfacePointOnScreen(e$1) {
					if (!this.isSurfacePointVisible(e$1)) return !1;
					const i$1 = t.bv();
					return t.aw(i$1, [...e$1, 1], this._globeViewProjMatrixNoCorrection), i$1[0] /= i$1[3], i$1[1] /= i$1[3], i$1[2] /= i$1[3], i$1[0] > -1 && i$1[0] < 1 && i$1[1] > -1 && i$1[1] < 1 && i$1[2] > -1 && i$1[2] < 1;
				}
				rayPlanetIntersection(e$1, i$1) {
					const o$1 = t.aX(e$1, i$1), r$1 = t.bp(), a$1 = t.bp();
					t.aR(a$1, i$1, o$1), t.aU(r$1, e$1, a$1);
					const s$1 = 1 - t.aX(r$1, r$1);
					if (s$1 < 0) return null;
					const n$1 = t.aX(e$1, e$1) - 1, l$1 = -o$1 + (o$1 < 0 ? 1 : -1) * Math.sqrt(s$1), c$1 = n$1 / l$1, h$1 = l$1;
					return {
						tMin: Math.min(c$1, h$1),
						tMax: Math.max(c$1, h$1)
					};
				}
				unprojectScreenPoint(e$1) {
					const i$1 = this._cameraPosition, o$1 = this.getRayDirectionFromPixel(e$1), r$1 = this.rayPlanetIntersection(i$1, o$1);
					if (r$1) {
						const e$2 = t.bp();
						t.aS(e$2, i$1, [
							o$1[0] * r$1.tMin,
							o$1[1] * r$1.tMin,
							o$1[2] * r$1.tMin
						]);
						const a$2 = t.bp();
						return t.aV(a$2, e$2), ri(a$2);
					}
					const a$1 = this._cachedClippingPlane, s$1 = a$1[0] * o$1[0] + a$1[1] * o$1[1] + a$1[2] * o$1[2], n$1 = -t.b1(a$1, i$1) / s$1, l$1 = t.bp();
					if (n$1 > 0) t.aS(l$1, i$1, [
						o$1[0] * n$1,
						o$1[1] * n$1,
						o$1[2] * n$1
					]);
					else {
						const e$2 = t.bp();
						t.aS(e$2, i$1, [
							2 * o$1[0],
							2 * o$1[1],
							2 * o$1[2]
						]);
						const r$2 = t.b1(this._cachedClippingPlane, e$2);
						t.aU(l$1, e$2, [
							this._cachedClippingPlane[0] * r$2,
							this._cachedClippingPlane[1] * r$2,
							this._cachedClippingPlane[2] * r$2
						]);
					}
					const c$1 = function(e$2) {
						const i$2 = t.bp();
						return i$2[0] = e$2[0] * -e$2[3], i$2[1] = e$2[1] * -e$2[3], i$2[2] = e$2[2] * -e$2[3], {
							center: i$2,
							radius: Math.sqrt(1 - e$2[3] * e$2[3])
						};
					}(a$1);
					return ri(function(e$2, i$2, o$2) {
						const r$2 = t.bp();
						t.aU(r$2, o$2, e$2);
						const a$2 = t.bp();
						return t.bq(a$2, e$2, r$2, i$2 / t.a$(r$2)), a$2;
					}(c$1.center, c$1.radius, l$1));
				}
				getMatrixForModel(e$1, i$1) {
					const o$1 = t.S.convert(e$1), r$1 = 1 / t.bu, a$1 = t.b9();
					return t.bz(a$1, a$1, o$1.lng / 180 * Math.PI), t.b7(a$1, a$1, -o$1.lat / 180 * Math.PI), t.M(a$1, a$1, [
						0,
						0,
						1 + i$1 / t.bu
					]), t.b7(a$1, a$1, .5 * Math.PI), t.N(a$1, a$1, [
						r$1,
						r$1,
						r$1
					]), a$1;
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const i$1 = this.getProjectionData({
						overscaledTileID: new t.Z(0, 0, 0, 0, 0),
						applyGlobeMatrix: e$1
					});
					return i$1.tileMercatorCoords = [
						0,
						0,
						1,
						1
					], i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {}
			}
			class gi {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e$1) {
					this._helper.setMinZoom(e$1);
				}
				setMaxZoom(e$1) {
					this._helper.setMaxZoom(e$1);
				}
				setMinPitch(e$1) {
					this._helper.setMinPitch(e$1);
				}
				setMaxPitch(e$1) {
					this._helper.setMaxPitch(e$1);
				}
				setRenderWorldCopies(e$1) {
					this._helper.setRenderWorldCopies(e$1);
				}
				setBearing(e$1) {
					this._helper.setBearing(e$1);
				}
				setPitch(e$1) {
					this._helper.setPitch(e$1);
				}
				setRoll(e$1) {
					this._helper.setRoll(e$1);
				}
				setFov(e$1) {
					this._helper.setFov(e$1);
				}
				setZoom(e$1) {
					this._helper.setZoom(e$1);
				}
				setCenter(e$1) {
					this._helper.setCenter(e$1);
				}
				setElevation(e$1) {
					this._helper.setElevation(e$1);
				}
				setMinElevationForCurrentTile(e$1) {
					this._helper.setMinElevationForCurrentTile(e$1);
				}
				setPadding(e$1) {
					this._helper.setPadding(e$1);
				}
				interpolatePadding(e$1, t$1, i$1) {
					return this._helper.interpolatePadding(e$1, t$1, i$1);
				}
				isPaddingEqual(e$1) {
					return this._helper.isPaddingEqual(e$1);
				}
				resize(e$1, t$1, i$1 = !0) {
					this._helper.resize(e$1, t$1, i$1);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e$1) {
					this._helper.setMaxBounds(e$1);
				}
				overrideNearFarZ(e$1, t$1) {
					this._helper.overrideNearFarZ(e$1, t$1);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e$1) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e$1);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				get isGlobeRendering() {
					return this._globeness > 0;
				}
				setTransitionState(e$1, t$1) {
					this._globeness = e$1, this._globeLatitudeErrorCorrectionRadians = t$1, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
				}
				get currentTransform() {
					return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
				}
				constructor() {
					this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Rt({
						calcMatrices: () => {
							this._calcMatrices();
						},
						getConstrained: (e$1, t$1) => this.getConstrained(e$1, t$1)
					}), this._globeness = 1, this._mercatorTransform = new Lt(), this._verticalPerspectiveTransform = new fi();
				}
				clone() {
					const e$1 = new gi();
					return e$1._globeness = this._globeness, e$1._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e$1.apply(this), e$1;
				}
				apply(e$1) {
					this._helper.apply(e$1), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
				}
				get projectionMatrix() {
					return this.currentTransform.projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this.currentTransform.modelViewProjectionMatrix;
				}
				get inverseProjectionMatrix() {
					return this.currentTransform.inverseProjectionMatrix;
				}
				get cameraPosition() {
					return this.currentTransform.cameraPosition;
				}
				getProjectionData(e$1) {
					const t$1 = this._mercatorTransform.getProjectionData(e$1), i$1 = this._verticalPerspectiveTransform.getProjectionData(e$1);
					return {
						mainMatrix: this.isGlobeRendering ? i$1.mainMatrix : t$1.mainMatrix,
						clippingPlane: i$1.clippingPlane,
						tileMercatorCoords: i$1.tileMercatorCoords,
						projectionTransition: e$1.applyGlobeMatrix ? this._globeness : 0,
						fallbackMatrix: t$1.fallbackMatrix
					};
				}
				isLocationOccluded(e$1) {
					return this.currentTransform.isLocationOccluded(e$1);
				}
				transformLightDirection(e$1) {
					return this.currentTransform.transformLightDirection(e$1);
				}
				getPixelScale() {
					return t.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
				}
				getCircleRadiusCorrection() {
					return t.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
				}
				getPitchedTextCorrection(e$1, i$1, o$1) {
					const r$1 = this._mercatorTransform.getPitchedTextCorrection(e$1, i$1, o$1), a$1 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e$1, i$1, o$1);
					return t.bk(r$1, a$1, this._globeness);
				}
				projectTileCoordinates(e$1, t$1, i$1, o$1) {
					return this.currentTransform.projectTileCoordinates(e$1, t$1, i$1, o$1);
				}
				_calcMatrices() {
					this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
				}
				calculateFogMatrix(e$1) {
					return this.currentTransform.calculateFogMatrix(e$1);
				}
				getVisibleUnwrappedCoordinates(e$1) {
					return this.currentTransform.getVisibleUnwrappedCoordinates(e$1);
				}
				getCameraFrustum() {
					return this.currentTransform.getCameraFrustum();
				}
				getClippingPlane() {
					return this.currentTransform.getClippingPlane();
				}
				getCoveringTilesDetailsProvider() {
					return this.currentTransform.getCoveringTilesDetailsProvider();
				}
				recalculateZoomAndCenter(e$1) {
					this._mercatorTransform.recalculateZoomAndCenter(e$1), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e$1);
				}
				maxPitchScaleFactor() {
					return this._mercatorTransform.maxPitchScaleFactor();
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e$1, t$1) {
					return this.currentTransform.lngLatToCameraDepth(e$1, t$1);
				}
				populateCache(e$1) {
					this._mercatorTransform.populateCache(e$1), this._verticalPerspectiveTransform.populateCache(e$1);
				}
				getBounds() {
					return this.currentTransform.getBounds();
				}
				getConstrained(e$1, t$1) {
					return this.currentTransform.getConstrained(e$1, t$1);
				}
				calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
				}
				setLocationAtPoint(e$1, t$1) {
					if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e$1, t$1), void this.apply(this._mercatorTransform);
					this._verticalPerspectiveTransform.setLocationAtPoint(e$1, t$1), this.apply(this._verticalPerspectiveTransform);
				}
				locationToScreenPoint(e$1, t$1) {
					return this.currentTransform.locationToScreenPoint(e$1, t$1);
				}
				screenPointToMercatorCoordinate(e$1, t$1) {
					return this.currentTransform.screenPointToMercatorCoordinate(e$1, t$1);
				}
				screenPointToLocation(e$1, t$1) {
					return this.currentTransform.screenPointToLocation(e$1, t$1);
				}
				isPointOnMapSurface(e$1, t$1) {
					return this.currentTransform.isPointOnMapSurface(e$1, t$1);
				}
				getRayDirectionFromPixel(e$1) {
					return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e$1);
				}
				getMatrixForModel(e$1, t$1) {
					return this.currentTransform.getMatrixForModel(e$1, t$1);
				}
				getProjectionDataForCustomLayer(e$1 = !0) {
					const t$1 = this._mercatorTransform.getProjectionDataForCustomLayer(e$1);
					if (!this.isGlobeRendering) return t$1;
					const i$1 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e$1);
					return i$1.fallbackMatrix = t$1.mainMatrix, i$1;
				}
				getFastPathSimpleProjectionMatrix(e$1) {
					return this.currentTransform.getFastPathSimpleProjectionMatrix(e$1);
				}
			}
			class vi {
				get useGlobeControls() {
					return !0;
				}
				handlePanInertia(e$1, i$1) {
					const o$1 = ni(e$1, i$1);
					return Math.abs(o$1.lng - i$1.center.lng) > 180 && (o$1.lng = i$1.center.lng + 179.5 * Math.sign(o$1.lng - i$1.center.lng)), {
						easingCenter: o$1,
						easingOffset: new t.P(0, 0)
					};
				}
				handleMapControlsRollPitchBearingZoom(e$1, i$1) {
					const o$1 = e$1.around, r$1 = i$1.screenPointToLocation(o$1);
					e$1.bearingDelta && i$1.setBearing(i$1.bearing + e$1.bearingDelta), e$1.pitchDelta && i$1.setPitch(i$1.pitch + e$1.pitchDelta), e$1.rollDelta && i$1.setRoll(i$1.roll + e$1.rollDelta);
					const a$1 = i$1.zoom;
					e$1.zoomDelta && i$1.setZoom(i$1.zoom + e$1.zoomDelta);
					const s$1 = i$1.zoom - a$1;
					if (0 === s$1) return;
					const n$1 = t.bA(i$1.center.lng, r$1.lng), l$1 = n$1 / (Math.abs(n$1 / 180) + 1), c$1 = t.bA(i$1.center.lat, r$1.lat), h$1 = i$1.getRayDirectionFromPixel(o$1), u$1 = i$1.cameraPosition, d$1 = -1 * t.aX(u$1, h$1), _$1 = t.bp();
					t.aS(_$1, u$1, [
						h$1[0] * d$1,
						h$1[1] * d$1,
						h$1[2] * d$1
					]);
					const p$1 = t.aZ(_$1) - 1, m$1 = Math.exp(.5 * -Math.max(p$1 - .3, 0)), f$1 = oi(i$1.worldSize, i$1.center.lat) / Math.min(i$1.width, i$1.height), g$1 = t.bn(f$1, .9, .5, 1, .25), v$1 = (1 - t.af(-s$1)) * Math.min(m$1, g$1), b$1 = i$1.center.lat, x$1 = i$1.zoom, y$1 = new t.S(i$1.center.lng + l$1 * v$1, t.ah(i$1.center.lat + c$1 * v$1, -t.ai, t.ai));
					i$1.setLocationAtPoint(r$1, o$1);
					const w$1 = i$1.center, T$1 = t.bn(Math.abs(n$1), 45, 85, 0, 1), P$1 = t.bn(f$1, .75, .35, 0, 1), C$1 = Math.pow(Math.max(T$1, P$1), .25), I$1 = t.bA(w$1.lng, y$1.lng), M$1 = t.bA(w$1.lat, y$1.lat);
					i$1.setCenter(new t.S(w$1.lng + I$1 * C$1, w$1.lat + M$1 * C$1).wrap()), i$1.setZoom(x$1 + si(b$1, i$1.center.lat));
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					if (!e$1.panDelta) return;
					const o$1 = t$1.center.lat, r$1 = t$1.zoom;
					t$1.setCenter(ni(e$1.panDelta, t$1).wrap()), t$1.setZoom(r$1 + si(o$1, t$1.center.lat));
				}
				cameraForBoxAndBearing(e$1, i$1, o$1, r$1, a$1) {
					const s$1 = Bt(e$1, i$1, o$1, r$1, a$1), n$1 = i$1.left / a$1.width * 2 - 1, l$1 = (a$1.width - i$1.right) / a$1.width * 2 - 1, c$1 = i$1.top / a$1.height * -2 + 1, h$1 = (a$1.height - i$1.bottom) / a$1.height * -2 + 1, u$1 = t.bA(o$1.getWest(), o$1.getEast()) < 0, d$1 = u$1 ? o$1.getEast() : o$1.getWest(), _$1 = u$1 ? o$1.getWest() : o$1.getEast(), p$1 = Math.max(o$1.getNorth(), o$1.getSouth()), m$1 = Math.min(o$1.getNorth(), o$1.getSouth()), f$1 = d$1 + .5 * t.bA(d$1, _$1), g$1 = p$1 + .5 * t.bA(p$1, m$1), v$1 = a$1.clone();
					v$1.setCenter(s$1.center), v$1.setBearing(s$1.bearing), v$1.setPitch(0), v$1.setRoll(0), v$1.setZoom(s$1.zoom);
					const b$1 = v$1.modelViewProjectionMatrix, x$1 = [
						ii(o$1.getNorthWest()),
						ii(o$1.getNorthEast()),
						ii(o$1.getSouthWest()),
						ii(o$1.getSouthEast()),
						ii(new t.S(_$1, g$1)),
						ii(new t.S(d$1, g$1)),
						ii(new t.S(f$1, p$1)),
						ii(new t.S(f$1, m$1))
					], y$1 = ii(s$1.center);
					let w$1 = Number.POSITIVE_INFINITY;
					for (const e$2 of x$1) n$1 < 0 && (w$1 = vi.getLesserNonNegativeNonNull(w$1, vi.solveVectorScale(e$2, y$1, b$1, "x", n$1))), l$1 > 0 && (w$1 = vi.getLesserNonNegativeNonNull(w$1, vi.solveVectorScale(e$2, y$1, b$1, "x", l$1))), c$1 > 0 && (w$1 = vi.getLesserNonNegativeNonNull(w$1, vi.solveVectorScale(e$2, y$1, b$1, "y", c$1))), h$1 < 0 && (w$1 = vi.getLesserNonNegativeNonNull(w$1, vi.solveVectorScale(e$2, y$1, b$1, "y", h$1)));
					if (Number.isFinite(w$1) && 0 !== w$1) return s$1.zoom = v$1.zoom + t.ak(w$1), s$1;
					kt();
				}
				handleJumpToCenterZoom(e$1, i$1) {
					const o$1 = e$1.center.lat, r$1 = e$1.getConstrained(i$1.center ? t.S.convert(i$1.center) : e$1.center, e$1.zoom).center;
					e$1.setCenter(r$1.wrap());
					const a$1 = void 0 !== i$1.zoom ? +i$1.zoom : e$1.zoom + si(o$1, r$1.lat);
					e$1.zoom !== a$1 && e$1.setZoom(a$1);
				}
				handleEaseTo(e$1, i$1) {
					const o$1 = e$1.zoom, r$1 = e$1.center, a$1 = e$1.padding, s$1 = {
						roll: e$1.roll,
						pitch: e$1.pitch,
						bearing: e$1.bearing
					}, n$1 = {
						roll: void 0 === i$1.roll ? e$1.roll : i$1.roll,
						pitch: void 0 === i$1.pitch ? e$1.pitch : i$1.pitch,
						bearing: void 0 === i$1.bearing ? e$1.bearing : i$1.bearing
					}, l$1 = void 0 !== i$1.zoom, c$1 = !e$1.isPaddingEqual(i$1.padding);
					let h$1 = !1;
					const u$1 = i$1.center ? t.S.convert(i$1.center) : r$1, d$1 = e$1.getConstrained(u$1, o$1).center;
					St(e$1, d$1);
					const _$1 = e$1.clone();
					_$1.setCenter(d$1), _$1.setZoom(l$1 ? +i$1.zoom : o$1 + si(r$1.lat, u$1.lat)), _$1.setBearing(i$1.bearing);
					const p$1 = new t.P(t.ah(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ah(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					_$1.setLocationAtPoint(d$1, p$1);
					const m$1 = (i$1.offset && i$1.offsetAsPoint.mag()) > 0 ? _$1.center : d$1, f$1 = l$1 ? +i$1.zoom : o$1 + si(r$1.lat, m$1.lat), g$1 = o$1 + si(r$1.lat, 0), v$1 = f$1 + si(m$1.lat, 0), b$1 = t.bA(r$1.lng, m$1.lng), x$1 = t.bA(r$1.lat, m$1.lat), y$1 = t.af(v$1 - g$1);
					return h$1 = f$1 !== o$1, {
						easeFunc: (o$2) => {
							if (t.be(s$1, n$1) || Ft({
								startEulerAngles: s$1,
								endEulerAngles: n$1,
								tr: e$1,
								k: o$2,
								useSlerp: s$1.roll != n$1.roll
							}), c$1 && e$1.interpolatePadding(a$1, i$1.padding, o$2), i$1.around) t.w("Easing around a point is not supported under globe projection."), e$1.setLocationAtPoint(i$1.around, i$1.aroundPoint);
							else {
								const t$1 = v$1 > g$1 ? Math.min(2, y$1) : Math.max(.5, y$1), i$2 = Math.pow(t$1, 1 - o$2), a$2 = ci(r$1, b$1, x$1, o$2 * i$2);
								e$1.setCenter(a$2.wrap());
							}
							if (h$1) {
								const i$2 = t.C.number(g$1, v$1, o$2) + si(0, e$1.center.lat);
								e$1.setZoom(i$2);
							}
						},
						isZooming: h$1,
						elevationCenter: m$1
					};
				}
				handleFlyTo(e$1, i$1) {
					const o$1 = void 0 !== i$1.zoom, r$1 = e$1.center, a$1 = e$1.zoom, s$1 = e$1.padding, n$1 = !e$1.isPaddingEqual(i$1.padding), l$1 = e$1.getConstrained(t.S.convert(i$1.center || i$1.locationAtOffset), a$1).center, c$1 = o$1 ? +i$1.zoom : e$1.zoom + si(e$1.center.lat, l$1.lat), h$1 = e$1.clone();
					h$1.setCenter(l$1), h$1.setZoom(c$1), h$1.setBearing(i$1.bearing);
					const u$1 = new t.P(t.ah(e$1.centerPoint.x + i$1.offsetAsPoint.x, 0, e$1.width), t.ah(e$1.centerPoint.y + i$1.offsetAsPoint.y, 0, e$1.height));
					h$1.setLocationAtPoint(l$1, u$1);
					const d$1 = h$1.center;
					St(e$1, d$1);
					const _$1 = function(e$2, i$2, o$2) {
						const r$2 = ii(i$2), a$2 = ii(o$2), s$2 = t.aX(r$2, a$2), n$2 = Math.acos(s$2), l$2 = ei(e$2);
						return n$2 / (2 * Math.PI) * l$2;
					}(e$1, r$1, d$1), p$1 = a$1 + si(r$1.lat, 0), m$1 = c$1 + si(d$1.lat, 0), f$1 = t.af(m$1 - p$1);
					let g$1;
					if ("number" == typeof i$1.minZoom) {
						const o$2 = +i$1.minZoom + si(d$1.lat, 0), r$2 = Math.min(o$2, p$1, m$1) + si(0, d$1.lat), a$2 = e$1.getConstrained(d$1, r$2).zoom + si(d$1.lat, 0);
						g$1 = t.af(a$2 - p$1);
					}
					const v$1 = t.bA(r$1.lng, d$1.lng), b$1 = t.bA(r$1.lat, d$1.lat);
					return {
						easeFunc: (o$2, a$2, l$2, h$2) => {
							const u$2 = ci(r$1, v$1, b$1, l$2);
							n$1 && e$1.interpolatePadding(s$1, i$1.padding, o$2);
							const _$2 = 1 === o$2 ? d$1 : u$2;
							e$1.setCenter(_$2.wrap());
							const m$2 = p$1 + t.ak(a$2);
							e$1.setZoom(1 === o$2 ? c$1 : m$2 + si(0, _$2.lat));
						},
						scaleOfZoom: f$1,
						targetCenter: d$1,
						scaleOfMinZoom: g$1,
						pixelPathLength: _$1
					};
				}
				static solveVectorScale(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = "x" === o$1 ? [
						i$1[0],
						i$1[4],
						i$1[8],
						i$1[12]
					] : [
						i$1[1],
						i$1[5],
						i$1[9],
						i$1[13]
					], s$1 = [
						i$1[3],
						i$1[7],
						i$1[11],
						i$1[15]
					], n$1 = e$1[0] * a$1[0] + e$1[1] * a$1[1] + e$1[2] * a$1[2], l$1 = e$1[0] * s$1[0] + e$1[1] * s$1[1] + e$1[2] * s$1[2], c$1 = t$1[0] * a$1[0] + t$1[1] * a$1[1] + t$1[2] * a$1[2], h$1 = t$1[0] * s$1[0] + t$1[1] * s$1[1] + t$1[2] * s$1[2];
					return c$1 + r$1 * l$1 === n$1 + r$1 * h$1 || s$1[3] * (n$1 - c$1) + a$1[3] * (h$1 - l$1) + n$1 * h$1 == c$1 * l$1 ? null : (c$1 + a$1[3] - r$1 * h$1 - r$1 * s$1[3]) / (c$1 - n$1 - r$1 * h$1 + r$1 * l$1);
				}
				static getLesserNonNegativeNonNull(e$1, t$1) {
					return null !== t$1 && t$1 >= 0 && t$1 < e$1 ? t$1 : e$1;
				}
			}
			class bi {
				constructor(e$1) {
					this._globe = e$1, this._mercatorCameraHelper = new Ot(), this._verticalPerspectiveCameraHelper = new vi();
				}
				get useGlobeControls() {
					return this._globe.useGlobeRendering;
				}
				get currentHelper() {
					return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
				}
				handlePanInertia(e$1, t$1) {
					return this.currentHelper.handlePanInertia(e$1, t$1);
				}
				handleMapControlsRollPitchBearingZoom(e$1, t$1) {
					return this.currentHelper.handleMapControlsRollPitchBearingZoom(e$1, t$1);
				}
				handleMapControlsPan(e$1, t$1, i$1) {
					this.currentHelper.handleMapControlsPan(e$1, t$1, i$1);
				}
				cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1) {
					return this.currentHelper.cameraForBoxAndBearing(e$1, t$1, i$1, o$1, r$1);
				}
				handleJumpToCenterZoom(e$1, t$1) {
					this.currentHelper.handleJumpToCenterZoom(e$1, t$1);
				}
				handleEaseTo(e$1, t$1) {
					return this.currentHelper.handleEaseTo(e$1, t$1);
				}
				handleFlyTo(e$1, t$1) {
					return this.currentHelper.handleFlyTo(e$1, t$1);
				}
			}
			const xi = (e$1, i$1) => t.y(e$1, i$1 && i$1.filter(((e$2) => "source.canvas" !== e$2.identifier))), yi = t.bE();
			class wi extends t.E {
				constructor(e$1, i$1 = {}) {
					var o$1, r$1;
					super(), this._rtlPluginLoaded = () => {
						for (const e$2 in this.sourceCaches) {
							const t$1 = this.sourceCaches[e$2].getSource().type;
							"vector" !== t$1 && "geojson" !== t$1 || this.sourceCaches[e$2].reload();
						}
					}, this.map = e$1, this.dispatcher = new F(k(), e$1._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e$2, t$1) => this.getGlyphs(e$2, t$1))), this.dispatcher.registerMessageHandler("GI", ((e$2, t$1) => this.getImages(e$2, t$1))), this.dispatcher.registerMessageHandler("GDA", ((e$2, t$1) => this.getDashes(e$2, t$1))), this.imageManager = new b(), this.imageManager.setEventedParent(this);
					const a$1 = (null === (o$1 = e$1._container) || void 0 === o$1 ? void 0 : o$1.lang) || "undefined" != typeof document && (null === (r$1 = document.documentElement) || void 0 === r$1 ? void 0 : r$1.lang) || void 0;
					this.glyphManager = new T(e$1._requestManager, i$1.localIdeographFontFamily, a$1), this.lineAtlas = new E(256, 512), this.crossTileSymbolIndex = new vt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", t.bG()), oe().on(ee, this._rtlPluginLoaded), this.on("data", ((e$2) => {
						if ("source" !== e$2.dataType || "metadata" !== e$2.sourceDataType) return;
						const t$1 = this.sourceCaches[e$2.sourceId];
						if (!t$1) return;
						const i$2 = t$1.getSource();
						if (i$2 && i$2.vectorLayerIds) for (const e$3 in this._layers) {
							const t$2 = this._layers[e$3];
							t$2.source === i$2.id && this._validateLayer(t$2);
						}
					}));
				}
				setGlobalStateProperty(e$1, i$1) {
					var o$1, r$1, a$1;
					this._checkLoaded();
					const s$1 = null === i$1 ? null !== (a$1 = null === (r$1 = null === (o$1 = this.stylesheet.state) || void 0 === o$1 ? void 0 : o$1[e$1]) || void 0 === r$1 ? void 0 : r$1.default) && void 0 !== a$1 ? a$1 : null : i$1;
					if (t.bH(s$1, this._globalState[e$1])) return this;
					this._globalState[e$1] = s$1, this._applyGlobalStateChanges([e$1]);
				}
				getGlobalState() {
					return this._globalState;
				}
				setGlobalState(e$1) {
					this._checkLoaded();
					const i$1 = [];
					for (const o$1 in e$1) !t.bH(this._globalState[o$1], e$1[o$1].default) && (i$1.push(o$1), this._globalState[o$1] = e$1[o$1].default);
					this._applyGlobalStateChanges(i$1);
				}
				_applyGlobalStateChanges(e$1) {
					if (0 === e$1.length) return;
					const t$1 = /* @__PURE__ */ new Set(), i$1 = {};
					for (const o$1 of e$1) {
						i$1[o$1] = this._globalState[o$1];
						for (const e$2 in this._layers) {
							const i$2 = this._layers[e$2], r$1 = i$2.getLayoutAffectingGlobalStateRefs(), a$1 = i$2.getPaintAffectingGlobalStateRefs();
							if (r$1.has(o$1) && t$1.add(i$2.source), a$1.has(o$1)) for (const { name: e$3, value: t$2 } of a$1.get(o$1)) this._updatePaintProperty(i$2, e$3, t$2);
						}
					}
					this.dispatcher.broadcast("UGS", i$1);
					for (const e$2 in this.sourceCaches) t$1.has(e$2) && (this._reloadSource(e$2), this._changed = !0);
				}
				loadURL(e$1, i$1 = {}, o$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), i$1.validate = "boolean" != typeof i$1.validate || i$1.validate;
					const r$1 = this.map._requestManager.transformRequest(e$1, "Style");
					this._loadStyleRequest = new AbortController();
					const a$1 = this._loadStyleRequest;
					t.j(r$1, this._loadStyleRequest).then(((e$2) => {
						this._loadStyleRequest = null, this._load(e$2.data, i$1, o$1);
					})).catch(((e$2) => {
						this._loadStyleRequest = null, e$2 && !a$1.signal.aborted && this.fire(new t.k(e$2));
					}));
				}
				loadJSON(e$1, i$1 = {}, o$1) {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s.frameAsync(this._frameRequest).then((() => {
						this._frameRequest = null, i$1.validate = !1 !== i$1.validate, this._load(e$1, i$1, o$1);
					})).catch((() => {}));
				}
				loadEmpty() {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._load(yi, { validate: !1 });
				}
				_load(e$1, i$1, o$1) {
					var r$1, a$1;
					let s$1 = i$1.transformStyle ? i$1.transformStyle(o$1, e$1) : e$1;
					if (!i$1.validate || !xi(this, t.z(s$1))) {
						s$1 = Object.assign({}, s$1), this._loaded = !0, this.stylesheet = s$1;
						for (const e$2 in s$1.sources) this.addSource(e$2, s$1.sources[e$2], { validate: !1 });
						s$1.sprite ? this._loadSprite(s$1.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(s$1.glyphs), this._createLayers(), this.light = new I(this.stylesheet.light), this._setProjectionInternal((null === (r$1 = this.stylesheet.projection) || void 0 === r$1 ? void 0 : r$1.type) || "mercator"), this.sky = new S(this.stylesheet.sky), this.map.setTerrain(null !== (a$1 = this.stylesheet.terrain) && void 0 !== a$1 ? a$1 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
					}
				}
				_createLayers() {
					var e$1;
					const i$1 = t.bI(this.stylesheet.layers);
					this.setGlobalState(null !== (e$1 = this.stylesheet.state) && void 0 !== e$1 ? e$1 : null), this.dispatcher.broadcast("SL", i$1), this._order = i$1.map(((e$2) => e$2.id)), this._layers = {}, this._serializedLayers = null;
					for (const e$2 of i$1) {
						const i$2 = t.bJ(e$2, this._globalState);
						i$2.setEventedParent(this, { layer: { id: e$2.id } }), this._layers[e$2.id] = i$2;
					}
				}
				_loadSprite(e$1, i$1 = !1, o$1 = void 0) {
					let r$1;
					this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(e$2, i$2, o$2, r$2) {
						return t._(this, void 0, void 0, (function* () {
							const a$1 = f(e$2), n$1 = o$2 > 1 ? "@2x" : "", l$1 = {}, c$1 = {};
							for (const { id: e$3, url: o$3 } of a$1) {
								const a$2 = i$2.transformRequest(g(o$3, n$1, ".json"), "SpriteJSON");
								l$1[e$3] = t.j(a$2, r$2);
								const s$1 = i$2.transformRequest(g(o$3, n$1, ".png"), "SpriteImage");
								c$1[e$3] = p.getImage(s$1, r$2);
							}
							return yield Promise.all([...Object.values(l$1), ...Object.values(c$1)]), function(e$3, i$3) {
								return t._(this, void 0, void 0, (function* () {
									const t$1 = {};
									for (const o$3 in e$3) {
										t$1[o$3] = {};
										const r$3 = s.getImageCanvasContext((yield i$3[o$3]).data), a$2 = (yield e$3[o$3]).data;
										for (const e$4 in a$2) {
											const { width: i$4, height: s$1, x: n$2, y: l$2, sdf: c$2, pixelRatio: h$1, stretchX: u$1, stretchY: d$1, content: _$1, textFitWidth: p$1, textFitHeight: m$1 } = a$2[e$4];
											t$1[o$3][e$4] = {
												data: null,
												pixelRatio: h$1,
												sdf: c$2,
												stretchX: u$1,
												stretchY: d$1,
												content: _$1,
												textFitWidth: p$1,
												textFitHeight: m$1,
												spriteData: {
													width: i$4,
													height: s$1,
													x: n$2,
													y: l$2,
													context: r$3
												}
											};
										}
									}
									return t$1;
								}));
							}(l$1, c$1);
						}));
					}(e$1, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e$2) => {
						if (this._spriteRequest = null, e$2) for (const t$1 in e$2) {
							this._spritesImagesIds[t$1] = [];
							const o$2 = this._spritesImagesIds[t$1] ? this._spritesImagesIds[t$1].filter(((t$2) => !(t$2 in e$2))) : [];
							for (const e$3 of o$2) this.imageManager.removeImage(e$3), this._changedImages[e$3] = !0;
							for (const o$3 in e$2[t$1]) {
								const r$2 = "default" === t$1 ? o$3 : `${t$1}:${o$3}`;
								this._spritesImagesIds[t$1].push(r$2), r$2 in this.imageManager.images ? this.imageManager.updateImage(r$2, e$2[t$1][o$3], !1) : this.imageManager.addImage(r$2, e$2[t$1][o$3]), i$1 && (this._changedImages[r$2] = !0);
							}
						}
					})).catch(((e$2) => {
						this._spriteRequest = null, r$1 = e$2, this.fire(new t.k(r$1));
					})).finally((() => {
						this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i$1 && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), o$1 && o$1(r$1);
					}));
				}
				_unloadSprite() {
					for (const e$1 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e$1), this._changedImages[e$1] = !0;
					this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				_validateLayer(e$1) {
					const i$1 = this.sourceCaches[e$1.source];
					if (!i$1) return;
					const o$1 = e$1.sourceLayer;
					if (!o$1) return;
					const r$1 = i$1.getSource();
					("geojson" === r$1.type || r$1.vectorLayerIds && -1 === r$1.vectorLayerIds.indexOf(o$1)) && this.fire(new t.k(/* @__PURE__ */ new Error(`Source layer "${o$1}" does not exist on source "${r$1.id}" as specified by style layer "${e$1.id}".`)));
				}
				loaded() {
					if (!this._loaded) return !1;
					if (Object.keys(this._updatedSources).length) return !1;
					for (const e$1 in this.sourceCaches) if (!this.sourceCaches[e$1].loaded()) return !1;
					return !!this.imageManager.isLoaded();
				}
				_serializeByIds(e$1, i$1 = !1) {
					const o$1 = this._serializedAllLayers();
					if (!e$1 || 0 === e$1.length) return Object.values(i$1 ? t.bK(o$1) : o$1);
					const r$1 = [];
					for (const a$1 of e$1) if (o$1[a$1]) {
						const e$2 = i$1 ? t.bK(o$1[a$1]) : o$1[a$1];
						r$1.push(e$2);
					}
					return r$1;
				}
				_serializedAllLayers() {
					let e$1 = this._serializedLayers;
					if (e$1) return e$1;
					e$1 = this._serializedLayers = {};
					const t$1 = Object.keys(this._layers);
					for (const i$1 of t$1) {
						const t$2 = this._layers[i$1];
						"custom" !== t$2.type && (e$1[i$1] = t$2.serialize());
					}
					return e$1;
				}
				hasTransitions() {
					var e$1, t$1, i$1;
					if (null === (e$1 = this.light) || void 0 === e$1 ? void 0 : e$1.hasTransition()) return !0;
					if (null === (t$1 = this.sky) || void 0 === t$1 ? void 0 : t$1.hasTransition()) return !0;
					if (null === (i$1 = this.projection) || void 0 === i$1 ? void 0 : i$1.hasTransition()) return !0;
					for (const e$2 in this.sourceCaches) if (this.sourceCaches[e$2].hasTransition()) return !0;
					for (const e$2 in this._layers) if (this._layers[e$2].hasTransition()) return !0;
					return !1;
				}
				_checkLoaded() {
					if (!this._loaded) throw new Error("Style is not done loading.");
				}
				update(e$1) {
					if (!this._loaded) return;
					const i$1 = this._changed;
					if (i$1) {
						const t$1 = Object.keys(this._updatedLayers), i$2 = Object.keys(this._removedLayers);
						(t$1.length || i$2.length) && this._updateWorkerLayers(t$1, i$2);
						for (const e$2 in this._updatedSources) {
							const t$2 = this._updatedSources[e$2];
							if ("reload" === t$2) this._reloadSource(e$2);
							else {
								if ("clear" !== t$2) throw new Error(`Invalid action ${t$2}`);
								this._clearSource(e$2);
							}
						}
						this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
						for (const t$2 in this._updatedPaintProps) this._layers[t$2].updateTransitions(e$1);
						this.light.updateTransitions(e$1), this.sky.updateTransitions(e$1), this._resetUpdates();
					}
					const o$1 = {};
					for (const e$2 in this.sourceCaches) {
						const t$1 = this.sourceCaches[e$2];
						o$1[e$2] = t$1.used, t$1.used = !1;
					}
					for (const t$1 of this._order) {
						const i$2 = this._layers[t$1];
						i$2.recalculate(e$1, this._availableImages), !i$2.isHidden(e$1.zoom) && i$2.source && (this.sourceCaches[i$2.source].used = !0);
					}
					for (const e$2 in o$1) {
						const i$2 = this.sourceCaches[e$2];
						!!o$1[e$2] != !!i$2.used && i$2.fire(new t.l("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: e$2
						}));
					}
					this.light.recalculate(e$1), this.sky.recalculate(e$1), this.projection.recalculate(e$1), this.z = e$1.zoom, i$1 && this.fire(new t.l("data", { dataType: "style" }));
				}
				_updateTilesForChangedImages() {
					const e$1 = Object.keys(this._changedImages);
					if (e$1.length) {
						for (const t$1 in this.sourceCaches) this.sourceCaches[t$1].reloadTilesForDependencies(["icons", "patterns"], e$1);
						this._changedImages = {};
					}
				}
				_updateTilesForChangedGlyphs() {
					if (this._glyphsDidChange) {
						for (const e$1 in this.sourceCaches) this.sourceCaches[e$1].reloadTilesForDependencies(["glyphs"], [""]);
						this._glyphsDidChange = !1;
					}
				}
				_updateWorkerLayers(e$1, t$1) {
					this.dispatcher.broadcast("UL", {
						layers: this._serializeByIds(e$1, !1),
						removedIds: t$1
					});
				}
				_resetUpdates() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
				}
				setState(e$1, i$1 = {}) {
					var o$1;
					this._checkLoaded();
					const r$1 = this.serialize();
					if (e$1 = i$1.transformStyle ? i$1.transformStyle(r$1, e$1) : e$1, (null === (o$1 = i$1.validate) || void 0 === o$1 || o$1) && xi(this, t.z(e$1))) return !1;
					(e$1 = t.bK(e$1)).layers = t.bI(e$1.layers);
					const a$1 = t.bL(r$1, e$1), s$1 = this._getOperationsToPerform(a$1);
					if (s$1.unimplemented.length > 0) throw new Error(`Unimplemented: ${s$1.unimplemented.join(", ")}.`);
					if (0 === s$1.operations.length) return !1;
					for (const e$2 of s$1.operations) e$2();
					return this.stylesheet = e$1, this._serializedLayers = null, !0;
				}
				_getOperationsToPerform(e$1) {
					const t$1 = [], i$1 = [];
					for (const o$1 of e$1) switch (o$1.command) {
						case "setCenter":
						case "setZoom":
						case "setBearing":
						case "setPitch":
						case "setRoll": continue;
						case "addLayer":
							t$1.push((() => this.addLayer.apply(this, o$1.args)));
							break;
						case "removeLayer":
							t$1.push((() => this.removeLayer.apply(this, o$1.args)));
							break;
						case "setPaintProperty":
							t$1.push((() => this.setPaintProperty.apply(this, o$1.args)));
							break;
						case "setLayoutProperty":
							t$1.push((() => this.setLayoutProperty.apply(this, o$1.args)));
							break;
						case "setFilter":
							t$1.push((() => this.setFilter.apply(this, o$1.args)));
							break;
						case "addSource":
							t$1.push((() => this.addSource.apply(this, o$1.args)));
							break;
						case "removeSource":
							t$1.push((() => this.removeSource.apply(this, o$1.args)));
							break;
						case "setLayerZoomRange":
							t$1.push((() => this.setLayerZoomRange.apply(this, o$1.args)));
							break;
						case "setLight":
							t$1.push((() => this.setLight.apply(this, o$1.args)));
							break;
						case "setGeoJSONSourceData":
							t$1.push((() => this.setGeoJSONSourceData.apply(this, o$1.args)));
							break;
						case "setGlyphs":
							t$1.push((() => this.setGlyphs.apply(this, o$1.args)));
							break;
						case "setSprite":
							t$1.push((() => this.setSprite.apply(this, o$1.args)));
							break;
						case "setTerrain":
							t$1.push((() => this.map.setTerrain.apply(this, o$1.args)));
							break;
						case "setSky":
							t$1.push((() => this.setSky.apply(this, o$1.args)));
							break;
						case "setProjection":
							this.setProjection.apply(this, o$1.args);
							break;
						case "setGlobalState":
							t$1.push((() => this.setGlobalState.apply(this, o$1.args)));
							break;
						case "setTransition":
							t$1.push((() => {}));
							break;
						default: i$1.push(o$1.command);
					}
					return {
						operations: t$1,
						unimplemented: i$1
					};
				}
				addImage(e$1, i$1) {
					if (this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" already exists.`)));
					this.imageManager.addImage(e$1, i$1), this._afterImageUpdated(e$1);
				}
				updateImage(e$1, t$1) {
					this.imageManager.updateImage(e$1, t$1);
				}
				getImage(e$1) {
					return this.imageManager.getImage(e$1);
				}
				removeImage(e$1) {
					if (!this.getImage(e$1)) return this.fire(new t.k(/* @__PURE__ */ new Error(`An image named "${e$1}" does not exist.`)));
					this.imageManager.removeImage(e$1), this._afterImageUpdated(e$1);
				}
				_afterImageUpdated(e$1) {
					this._availableImages = this.imageManager.listImages(), this._changedImages[e$1] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				listImages() {
					return this._checkLoaded(), this.imageManager.listImages();
				}
				addSource(e$1, i$1, o$1 = {}) {
					if (this._checkLoaded(), void 0 !== this.sourceCaches[e$1]) throw new Error(`Source "${e$1}" already exists.`);
					if (!i$1.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i$1).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(i$1.type) >= 0 && this._validate(t.z.source, `sources.${e$1}`, i$1, null, o$1)) return;
					this.map && this.map._collectResourceTiming && (i$1.collectResourceTiming = !0);
					const r$1 = this.sourceCaches[e$1] = new xe(e$1, i$1, this.dispatcher);
					r$1.style = this, r$1.setEventedParent(this, (() => ({
						isSourceLoaded: r$1.loaded(),
						source: r$1.serialize(),
						sourceId: e$1
					}))), r$1.onAdd(this.map), this._changed = !0;
				}
				removeSource(e$1) {
					if (this._checkLoaded(), void 0 === this.sourceCaches[e$1]) throw new Error("There is no source with this ID");
					for (const i$2 in this._layers) if (this._layers[i$2].source === e$1) return this.fire(new t.k(/* @__PURE__ */ new Error(`Source "${e$1}" cannot be removed while layer "${i$2}" is using it.`)));
					const i$1 = this.sourceCaches[e$1];
					delete this.sourceCaches[e$1], delete this._updatedSources[e$1], i$1.fire(new t.l("data", {
						sourceDataType: "metadata",
						dataType: "source",
						sourceId: e$1
					})), i$1.setEventedParent(null), i$1.onRemove(this.map), this._changed = !0;
				}
				setGeoJSONSourceData(e$1, t$1) {
					if (this._checkLoaded(), void 0 === this.sourceCaches[e$1]) throw new Error(`There is no source with this ID=${e$1}`);
					const i$1 = this.sourceCaches[e$1].getSource();
					if ("geojson" !== i$1.type) throw new Error(`geojsonSource.type is ${i$1.type}, which is !== 'geojson`);
					i$1.setData(t$1), this._changed = !0;
				}
				getSource(e$1) {
					return this.sourceCaches[e$1] && this.sourceCaches[e$1].getSource();
				}
				addLayer(e$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = e$1.id;
					if (this.getLayer(r$1)) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Layer "${r$1}" already exists on this map.`)));
					let a$1;
					if ("custom" === e$1.type) {
						if (xi(this, t.bM(e$1))) return;
						a$1 = t.bJ(e$1, this._globalState);
					} else {
						if ("source" in e$1 && "object" == typeof e$1.source && (this.addSource(r$1, e$1.source), e$1 = t.bK(e$1), e$1 = t.e(e$1, { source: r$1 })), this._validate(t.z.layer, `layers.${r$1}`, e$1, { arrayIndex: -1 }, o$1)) return;
						a$1 = t.bJ(e$1, this._globalState), this._validateLayer(a$1), a$1.setEventedParent(this, { layer: { id: r$1 } });
					}
					const s$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					if (i$1 && -1 === s$1) this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot add layer "${r$1}" before non-existing layer "${i$1}".`)));
					else {
						if (this._order.splice(s$1, 0, r$1), this._layerOrderChanged = !0, this._layers[r$1] = a$1, this._removedLayers[r$1] && a$1.source && "custom" !== a$1.type) {
							const e$2 = this._removedLayers[r$1];
							delete this._removedLayers[r$1], e$2.type !== a$1.type ? this._updatedSources[a$1.source] = "clear" : (this._updatedSources[a$1.source] = "reload", this.sourceCaches[a$1.source].pause());
						}
						this._updateLayer(a$1), a$1.onAdd && a$1.onAdd(this.map);
					}
				}
				moveLayer(e$1, i$1) {
					if (this._checkLoaded(), this._changed = !0, !this._layers[e$1]) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$1}' does not exist in the map's style and cannot be moved.`)));
					if (e$1 === i$1) return;
					const o$1 = this._order.indexOf(e$1);
					this._order.splice(o$1, 1);
					const r$1 = i$1 ? this._order.indexOf(i$1) : this._order.length;
					i$1 && -1 === r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot move layer "${e$1}" before non-existing layer "${i$1}".`))) : (this._order.splice(r$1, 0, e$1), this._layerOrderChanged = !0);
				}
				removeLayer(e$1) {
					this._checkLoaded();
					const i$1 = this._layers[e$1];
					if (!i$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot remove non-existing layer "${e$1}".`)));
					i$1.setEventedParent(null);
					const o$1 = this._order.indexOf(e$1);
					this._order.splice(o$1, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e$1] = i$1, delete this._layers[e$1], this._serializedLayers && delete this._serializedLayers[e$1], delete this._updatedLayers[e$1], delete this._updatedPaintProps[e$1], i$1.onRemove && i$1.onRemove(this.map);
				}
				getLayer(e$1) {
					return this._layers[e$1];
				}
				getLayersOrder() {
					return [...this._order];
				}
				hasLayer(e$1) {
					return e$1 in this._layers;
				}
				setLayerZoomRange(e$1, i$1, o$1) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					r$1 ? r$1.minzoom === i$1 && r$1.maxzoom === o$1 || (null != i$1 && (r$1.minzoom = i$1), null != o$1 && (r$1.maxzoom = o$1), this._updateLayer(r$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot set the zoom range of non-existing layer "${e$1}".`)));
				}
				setFilter(e$1, i$1, o$1 = {}) {
					this._checkLoaded();
					const r$1 = this.getLayer(e$1);
					if (r$1) {
						if (!t.bH(r$1.filter, i$1)) return null == i$1 ? (r$1.setFilter(void 0), void this._updateLayer(r$1)) : void (this._validate(t.z.filter, `layers.${r$1.id}.filter`, i$1, null, o$1) || (r$1.setFilter(t.bK(i$1)), this._updateLayer(r$1)));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot filter non-existing layer "${e$1}".`)));
				}
				getFilter(e$1) {
					return t.bK(this.getLayer(e$1).filter);
				}
				setLayoutProperty(e$1, i$1, o$1, r$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getLayer(e$1);
					a$1 ? t.bH(a$1.getLayoutProperty(i$1), o$1) || (a$1.setLayoutProperty(i$1, o$1, r$1), this._updateLayer(a$1)) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				getLayoutProperty(e$1, i$1) {
					const o$1 = this.getLayer(e$1);
					if (o$1) return o$1.getLayoutProperty(i$1);
					this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot get style of non-existing layer "${e$1}".`)));
				}
				setPaintProperty(e$1, i$1, o$1, r$1 = {}) {
					this._checkLoaded();
					const a$1 = this.getLayer(e$1);
					a$1 ? t.bH(a$1.getPaintProperty(i$1), o$1) || this._updatePaintProperty(a$1, i$1, o$1, r$1) : this.fire(new t.k(/* @__PURE__ */ new Error(`Cannot style non-existing layer "${e$1}".`)));
				}
				_updatePaintProperty(e$1, t$1, i$1, o$1 = {}) {
					e$1.setPaintProperty(t$1, i$1, o$1) && this._updateLayer(e$1), this._changed = !0, this._updatedPaintProps[e$1.id] = !0, this._serializedLayers = null;
				}
				getPaintProperty(e$1, t$1) {
					return this.getLayer(e$1).getPaintProperty(t$1);
				}
				setFeatureState(e$1, i$1) {
					this._checkLoaded();
					const o$1 = e$1.source, r$1 = e$1.sourceLayer, a$1 = this.sourceCaches[o$1];
					if (void 0 === a$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${o$1}' does not exist in the map's style.`)));
					const s$1 = a$1.getSource().type;
					"geojson" === s$1 && r$1 ? this.fire(new t.k(/* @__PURE__ */ new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s$1 || r$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), a$1.setFeatureState(r$1, e$1.id, i$1)) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				removeFeatureState(e$1, i$1) {
					this._checkLoaded();
					const o$1 = e$1.source, r$1 = this.sourceCaches[o$1];
					if (void 0 === r$1) return void this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${o$1}' does not exist in the map's style.`)));
					const a$1 = r$1.getSource().type, s$1 = "vector" === a$1 ? e$1.sourceLayer : void 0;
					"vector" !== a$1 || s$1 ? i$1 && "string" != typeof e$1.id && "number" != typeof e$1.id ? this.fire(new t.k(/* @__PURE__ */ new Error("A feature id is required to remove its specific state property."))) : r$1.removeFeatureState(s$1, e$1.id, i$1) : this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				getFeatureState(e$1) {
					this._checkLoaded();
					const i$1 = e$1.source, o$1 = e$1.sourceLayer, r$1 = this.sourceCaches[i$1];
					if (void 0 !== r$1) return "vector" !== r$1.getSource().type || o$1 ? (void 0 === e$1.id && this.fire(new t.k(/* @__PURE__ */ new Error("The feature id parameter must be provided."))), r$1.getFeatureState(o$1, e$1.id)) : void this.fire(new t.k(/* @__PURE__ */ new Error("The sourceLayer parameter must be provided for vector source types.")));
					this.fire(new t.k(/* @__PURE__ */ new Error(`The source '${i$1}' does not exist in the map's style.`)));
				}
				getTransition() {
					return t.e({
						duration: 300,
						delay: 0
					}, this.stylesheet && this.stylesheet.transition);
				}
				serialize() {
					if (!this._loaded) return;
					const e$1 = t.bN(this.sourceCaches, ((e$2) => e$2.serialize())), i$1 = this._serializeByIds(this._order, !0), o$1 = this.map.getTerrain() || void 0, r$1 = this.stylesheet;
					return t.bO({
						version: r$1.version,
						name: r$1.name,
						metadata: r$1.metadata,
						light: r$1.light,
						sky: r$1.sky,
						center: r$1.center,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						sprite: r$1.sprite,
						glyphs: r$1.glyphs,
						transition: r$1.transition,
						projection: r$1.projection,
						sources: e$1,
						layers: i$1,
						terrain: o$1
					}, ((e$2) => void 0 !== e$2));
				}
				_updateLayer(e$1) {
					this._updatedLayers[e$1.id] = !0, e$1.source && !this._updatedSources[e$1.source] && "raster" !== this.sourceCaches[e$1.source].getSource().type && (this._updatedSources[e$1.source] = "reload", this.sourceCaches[e$1.source].pause()), this._serializedLayers = null, this._changed = !0;
				}
				_flattenAndSortRenderedFeatures(e$1) {
					const t$1 = (e$2) => "fill-extrusion" === this._layers[e$2].type, i$1 = {}, o$1 = [];
					for (let r$2 = this._order.length - 1; r$2 >= 0; r$2--) {
						const a$1 = this._order[r$2];
						if (t$1(a$1)) {
							i$1[a$1] = r$2;
							for (const t$2 of e$1) {
								const e$2 = t$2[a$1];
								if (e$2) for (const t$3 of e$2) o$1.push(t$3);
							}
						}
					}
					o$1.sort(((e$2, t$2) => t$2.intersectionZ - e$2.intersectionZ));
					const r$1 = [];
					for (let a$1 = this._order.length - 1; a$1 >= 0; a$1--) {
						const s$1 = this._order[a$1];
						if (t$1(s$1)) for (let e$2 = o$1.length - 1; e$2 >= 0; e$2--) {
							const t$2 = o$1[e$2].feature;
							if (i$1[t$2.layer.id] < a$1) break;
							r$1.push(t$2), o$1.pop();
						}
						else for (const t$2 of e$1) {
							const e$2 = t$2[s$1];
							if (e$2) for (const t$3 of e$2) r$1.push(t$3.feature);
						}
					}
					return r$1;
				}
				queryRenderedFeatures(e$1, i$1, o$1) {
					i$1 && i$1.filter && this._validate(t.z.filter, "queryRenderedFeatures.filter", i$1.filter, null, i$1);
					const r$1 = {};
					if (i$1 && i$1.layers) {
						if (!(Array.isArray(i$1.layers) || i$1.layers instanceof Set)) return this.fire(new t.k(/* @__PURE__ */ new Error("parameters.layers must be an Array or a Set of strings"))), [];
						for (const e$2 of i$1.layers) {
							const i$2 = this._layers[e$2];
							if (!i$2) return this.fire(new t.k(/* @__PURE__ */ new Error(`The layer '${e$2}' does not exist in the map's style and cannot be queried for features.`))), [];
							r$1[i$2.source] = !0;
						}
					}
					const a$1 = [];
					i$1.availableImages = this._availableImages;
					const s$1 = this._serializedAllLayers(), n$1 = i$1.layers instanceof Set ? i$1.layers : Array.isArray(i$1.layers) ? new Set(i$1.layers) : null, l$1 = Object.assign(Object.assign({}, i$1), {
						layers: n$1,
						globalState: this._globalState
					});
					for (const t$1 in this.sourceCaches) i$1.layers && !r$1[t$1] || a$1.push(j(this.sourceCaches[t$1], this._layers, s$1, e$1, l$1, o$1, this.map.terrain ? (e$2, t$2, i$2) => this.map.terrain.getElevation(e$2, t$2, i$2) : void 0));
					return this.placement && a$1.push(function(e$2, t$1, i$2, o$2, r$2, a$2, s$2) {
						const n$2 = {}, l$2 = a$2.queryRenderedSymbols(o$2), c$1 = [];
						for (const e$3 of Object.keys(l$2).map(Number)) c$1.push(s$2[e$3]);
						c$1.sort(N);
						for (const i$3 of c$1) {
							const o$3 = i$3.featureIndex.lookupSymbolFeatures(l$2[i$3.bucketInstanceId], t$1, i$3.bucketIndex, i$3.sourceLayerIndex, {
								filterSpec: r$2.filter,
								globalState: r$2.globalState
							}, r$2.layers, r$2.availableImages, e$2);
							for (const e$3 in o$3) {
								const t$2 = n$2[e$3] = n$2[e$3] || [], r$3 = o$3[e$3];
								r$3.sort(((e$4, t$3) => {
									const o$4 = i$3.featureSortOrder;
									if (o$4) {
										const i$4 = o$4.indexOf(e$4.featureIndex);
										return o$4.indexOf(t$3.featureIndex) - i$4;
									}
									return t$3.featureIndex - e$4.featureIndex;
								}));
								for (const e$4 of r$3) t$2.push(e$4);
							}
						}
						return function(e$3, t$2, i$3) {
							for (const o$3 in e$3) for (const r$3 of e$3[o$3]) U(r$3, i$3[t$2[o$3].source]);
							return e$3;
						}(n$2, e$2, i$2);
					}(this._layers, s$1, this.sourceCaches, e$1, l$1, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a$1);
				}
				querySourceFeatures(e$1, i$1) {
					null != i$1 && i$1.filter && this._validate(t.z.filter, "querySourceFeatures.filter", i$1.filter, null, i$1);
					const o$1 = this.sourceCaches[e$1];
					return o$1 ? function(e$2, t$1) {
						const i$2 = e$2.getRenderableIds().map(((t$2) => e$2.getTileByID(t$2))), o$2 = [], r$1 = {};
						for (let e$3 = 0; e$3 < i$2.length; e$3++) {
							const a$1 = i$2[e$3], s$1 = a$1.tileID.canonical.key;
							r$1[s$1] || (r$1[s$1] = !0, a$1.querySourceFeatures(o$2, t$1));
						}
						return o$2;
					}(o$1, i$1 ? Object.assign(Object.assign({}, i$1), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
				}
				getLight() {
					return this.light.getLight();
				}
				setLight(e$1, i$1 = {}) {
					this._checkLoaded();
					const o$1 = this.light.getLight();
					let r$1 = !1;
					for (const i$2 in e$1) if (!t.bH(e$1[i$2], o$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const a$1 = {
						now: s.now(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.light.setLight(e$1, i$1), this.light.updateTransitions(a$1);
				}
				getProjection() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.projection;
				}
				setProjection(e$1) {
					if (this._checkLoaded(), this.projection) {
						if (this.projection.name === e$1.type) return;
						this.projection.destroy(), delete this.projection;
					}
					this.stylesheet.projection = e$1, this._setProjectionInternal(e$1.type);
				}
				getSky() {
					var e$1;
					return null === (e$1 = this.stylesheet) || void 0 === e$1 ? void 0 : e$1.sky;
				}
				setSky(e$1, i$1 = {}) {
					this._checkLoaded();
					const o$1 = this.getSky();
					let r$1 = !1;
					if (!e$1 && !o$1) return;
					if (e$1 && !o$1) r$1 = !0;
					else if (!e$1 && o$1) r$1 = !0;
					else for (const i$2 in e$1) if (!t.bH(e$1[i$2], o$1[i$2])) {
						r$1 = !0;
						break;
					}
					if (!r$1) return;
					const a$1 = {
						now: s.now(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.stylesheet.sky = e$1, this.sky.setSky(e$1, i$1), this.sky.updateTransitions(a$1);
				}
				_setProjectionInternal(e$1) {
					const i$1 = function(e$2) {
						if (Array.isArray(e$2)) {
							const t$1 = new Jt({ type: e$2 });
							return {
								projection: t$1,
								transform: new gi(),
								cameraHelper: new bi(t$1)
							};
						}
						switch (e$2) {
							case "mercator": return {
								projection: new It(),
								transform: new Lt(),
								cameraHelper: new Ot()
							};
							case "globe": {
								const e$3 = new Jt({ type: [
									"interpolate",
									["linear"],
									["zoom"],
									11,
									"vertical-perspective",
									12,
									"mercator"
								] });
								return {
									projection: e$3,
									transform: new gi(),
									cameraHelper: new bi(e$3)
								};
							}
							case "vertical-perspective": return {
								projection: new Yt(),
								transform: new fi(),
								cameraHelper: new vi()
							};
							default: return t.w(`Unknown projection name: ${e$2}. Falling back to mercator projection.`), {
								projection: new It(),
								transform: new Lt(),
								cameraHelper: new Ot()
							};
						}
					}(e$1);
					this.projection = i$1.projection, this.map.migrateProjection(i$1.transform, i$1.cameraHelper);
					for (const e$2 in this.sourceCaches) this.sourceCaches[e$2].reload();
				}
				_validate(e$1, i$1, o$1, r$1, a$1 = {}) {
					return (!a$1 || !1 !== a$1.validate) && xi(this, e$1.call(t.z, t.e({
						key: i$1,
						style: this.serialize(),
						value: o$1,
						styleSpec: t.v
					}, r$1)));
				}
				_remove(e$1 = !0) {
					this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe().off(ee, this._rtlPluginLoaded);
					for (const e$2 in this._layers) this._layers[e$2].setEventedParent(null);
					for (const e$2 in this.sourceCaches) {
						const t$1 = this.sourceCaches[e$2];
						t$1.setEventedParent(null), t$1.onRemove(this.map);
					}
					this.imageManager.setEventedParent(null), this.setEventedParent(null), e$1 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e$1);
				}
				_clearSource(e$1) {
					this.sourceCaches[e$1].clearTiles();
				}
				_reloadSource(e$1) {
					this.sourceCaches[e$1].resume(), this.sourceCaches[e$1].reload();
				}
				_updateSources(e$1) {
					for (const t$1 in this.sourceCaches) this.sourceCaches[t$1].update(e$1, this.map.terrain);
				}
				_generateCollisionBoxes() {
					for (const e$1 in this.sourceCaches) this._reloadSource(e$1);
				}
				_updatePlacement(e$1, t$1, i$1, o$1, r$1 = !1) {
					let a$1 = !1, n$1 = !1;
					const l$1 = {};
					for (const t$2 of this._order) {
						const i$2 = this._layers[t$2];
						if ("symbol" !== i$2.type) continue;
						if (!l$1[i$2.source]) {
							const e$2 = this.sourceCaches[i$2.source];
							l$1[i$2.source] = e$2.getRenderableIds(!0).map(((t$3) => e$2.getTileByID(t$3))).sort(((e$3, t$3) => t$3.tileID.overscaledZ - e$3.tileID.overscaledZ || (e$3.tileID.isLessThan(t$3.tileID) ? -1 : 1)));
						}
						const o$2 = this.crossTileSymbolIndex.addLayer(i$2, l$1[i$2.source], e$1.center.lng);
						a$1 = a$1 || o$2;
					}
					if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r$1 = r$1 || this._layerOrderChanged || 0 === i$1) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.now(), e$1.zoom)) && (this.pauseablePlacement = new _t(e$1, this.map.terrain, this._order, r$1, t$1, i$1, o$1, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l$1), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.now()), n$1 = !0), a$1 && this.pauseablePlacement.placement.setStale()), n$1 || a$1) for (const e$2 of this._order) {
						const t$2 = this._layers[e$2];
						"symbol" === t$2.type && this.placement.updateLayerOpacities(t$2, l$1[t$2.source]);
					}
					return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.now());
				}
				_releaseSymbolFadeTiles() {
					for (const e$1 in this.sourceCaches) this.sourceCaches[e$1].releaseSymbolFadeTiles();
				}
				getImages(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.imageManager.getImages(i$1.icons);
						this._updateTilesForChangedImages();
						const t$1 = this.sourceCaches[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, i$1.icons), e$2;
					}));
				}
				getGlyphs(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = yield this.glyphManager.getGlyphs(i$1.stacks), t$1 = this.sourceCaches[i$1.source];
						return t$1 && t$1.setDependencies(i$1.tileID.key, i$1.type, [""]), e$2;
					}));
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs || null;
				}
				setGlyphs(e$1, i$1 = {}) {
					this._checkLoaded(), e$1 && this._validate(t.z.glyphs, "glyphs", e$1, null, i$1) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e$1, this.glyphManager.entries = {}, this.glyphManager.setURL(e$1));
				}
				getDashes(e$1, i$1) {
					return t._(this, void 0, void 0, (function* () {
						const e$2 = {};
						for (const [t$1, o$1] of Object.entries(i$1.dashes)) e$2[t$1] = this.lineAtlas.getDash(o$1.dasharray, o$1.round);
						return e$2;
					}));
				}
				addSprite(e$1, i$1, o$1 = {}, r$1) {
					this._checkLoaded();
					const a$1 = [{
						id: e$1,
						url: i$1
					}], s$1 = [...f(this.stylesheet.sprite), ...a$1];
					this._validate(t.z.sprite, "sprite", s$1, null, o$1) || (this.stylesheet.sprite = s$1, this._loadSprite(a$1, !0, r$1));
				}
				removeSprite(e$1) {
					this._checkLoaded();
					const i$1 = f(this.stylesheet.sprite);
					if (i$1.find(((t$1) => t$1.id === e$1))) {
						if (this._spritesImagesIds[e$1]) for (const t$1 of this._spritesImagesIds[e$1]) this.imageManager.removeImage(t$1), this._changedImages[t$1] = !0;
						i$1.splice(i$1.findIndex(((t$1) => t$1.id === e$1)), 1), this.stylesheet.sprite = i$1.length > 0 ? i$1 : void 0, delete this._spritesImagesIds[e$1], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
					} else this.fire(new t.k(/* @__PURE__ */ new Error(`Sprite "${e$1}" doesn't exists on this map.`)));
				}
				getSprite() {
					return f(this.stylesheet.sprite);
				}
				setSprite(e$1, i$1 = {}, o$1) {
					this._checkLoaded(), e$1 && this._validate(t.z.sprite, "sprite", e$1, null, i$1) || (this.stylesheet.sprite = e$1, e$1 ? this._loadSprite(e$1, !0, o$1) : (this._unloadSprite(), o$1 && o$1(null)));
				}
			}
			var Ti = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			class Pi {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
				}
				bind(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
					this.context = e$1;
					let c$1 = this.boundPaintVertexBuffers.length !== o$1.length;
					for (let e$2 = 0; !c$1 && e$2 < o$1.length; e$2++) this.boundPaintVertexBuffers[e$2] !== o$1[e$2] && (c$1 = !0);
					!this.vao || this.boundProgram !== t$1 || this.boundLayoutVertexBuffer !== i$1 || c$1 || this.boundIndexBuffer !== r$1 || this.boundVertexOffset !== a$1 || this.boundDynamicVertexBuffer !== s$1 || this.boundDynamicVertexBuffer2 !== n$1 || this.boundDynamicVertexBuffer3 !== l$1 ? this.freshBind(t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) : (e$1.bindVertexArray.set(this.vao), s$1 && s$1.bind(), r$1 && r$1.dynamicDraw && r$1.bind(), n$1 && n$1.bind(), l$1 && l$1.bind());
				}
				freshBind(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1) {
					const l$1 = e$1.numAttributes, c$1 = this.context, h$1 = c$1.gl;
					this.vao && this.destroy(), this.vao = c$1.createVertexArray(), c$1.bindVertexArray.set(this.vao), this.boundProgram = e$1, this.boundLayoutVertexBuffer = t$1, this.boundPaintVertexBuffers = i$1, this.boundIndexBuffer = o$1, this.boundVertexOffset = r$1, this.boundDynamicVertexBuffer = a$1, this.boundDynamicVertexBuffer2 = s$1, this.boundDynamicVertexBuffer3 = n$1, t$1.enableAttributes(h$1, e$1);
					for (const t$2 of i$1) t$2.enableAttributes(h$1, e$1);
					a$1 && a$1.enableAttributes(h$1, e$1), s$1 && s$1.enableAttributes(h$1, e$1), n$1 && n$1.enableAttributes(h$1, e$1), t$1.bind(), t$1.setVertexAttribPointers(h$1, e$1, r$1);
					for (const t$2 of i$1) t$2.bind(), t$2.setVertexAttribPointers(h$1, e$1, r$1);
					a$1 && (a$1.bind(), a$1.setVertexAttribPointers(h$1, e$1, r$1)), o$1 && o$1.bind(), s$1 && (s$1.bind(), s$1.setVertexAttribPointers(h$1, e$1, r$1)), n$1 && (n$1.bind(), n$1.setVertexAttribPointers(h$1, e$1, r$1)), c$1.currentNumAttributes = l$1;
				}
				destroy() {
					this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
				}
			}
			const Ci = (e$1, i$1, o$1, r$1, a$1) => ({
				u_texture: 0,
				u_ele_delta: e$1,
				u_fog_matrix: i$1,
				u_fog_color: o$1 ? o$1.properties.get("fog-color") : t.bf.white,
				u_fog_ground_blend: o$1 ? o$1.properties.get("fog-ground-blend") : 1,
				u_fog_ground_blend_opacity: a$1 ? 0 : o$1 ? o$1.calculateFogBlendOpacity(r$1) : 0,
				u_horizon_color: o$1 ? o$1.properties.get("horizon-color") : t.bf.white,
				u_horizon_fog_blend: o$1 ? o$1.properties.get("horizon-fog-blend") : 1,
				u_is_globe_mode: a$1 ? 1 : 0
			}), Ii = {
				mainMatrix: "u_projection_matrix",
				tileMercatorCoords: "u_projection_tile_mercator_coords",
				clippingPlane: "u_projection_clipping_plane",
				projectionTransition: "u_projection_transition",
				fallbackMatrix: "u_projection_fallback_matrix"
			};
			function Mi(e$1) {
				const t$1 = [];
				for (let i$1 = 0; i$1 < e$1.length; i$1++) {
					if (null === e$1[i$1]) continue;
					const o$1 = e$1[i$1].split(" ");
					t$1.push(o$1.pop());
				}
				return t$1;
			}
			class Si {
				constructor(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1 = []) {
					const h$1 = e$1.gl;
					this.program = h$1.createProgram();
					const u$1 = Mi(i$1.staticAttributes), d$1 = o$1 ? o$1.getBinderAttributes() : [], _$1 = u$1.concat(d$1), p$1 = xt.prelude.staticUniforms ? Mi(xt.prelude.staticUniforms) : [], m$1 = n$1.staticUniforms ? Mi(n$1.staticUniforms) : [], f$1 = i$1.staticUniforms ? Mi(i$1.staticUniforms) : [], g$1 = o$1 ? o$1.getBinderUniforms() : [], v$1 = p$1.concat(m$1).concat(f$1).concat(g$1), b$1 = [];
					for (const e$2 of v$1) b$1.indexOf(e$2) < 0 && b$1.push(e$2);
					const x$1 = o$1 ? o$1.defines() : [];
					qt(h$1) && x$1.unshift("#version 300 es"), a$1 && x$1.push("#define OVERDRAW_INSPECTOR;"), s$1 && x$1.push("#define TERRAIN3D;"), l$1 && x$1.push(l$1), c$1 && x$1.push(...c$1);
					let y$1 = x$1.concat(xt.prelude.fragmentSource, n$1.fragmentSource, i$1.fragmentSource).join("\n"), w$1 = x$1.concat(xt.prelude.vertexSource, n$1.vertexSource, i$1.vertexSource).join("\n");
					qt(h$1) || (y$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
					}(y$1), w$1 = function(e$2) {
						return e$2.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
					}(w$1));
					const T$1 = h$1.createShader(h$1.FRAGMENT_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(T$1, y$1), h$1.compileShader(T$1), !h$1.getShaderParameter(T$1, h$1.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h$1.getShaderInfoLog(T$1)}`);
					h$1.attachShader(this.program, T$1);
					const P$1 = h$1.createShader(h$1.VERTEX_SHADER);
					if (h$1.isContextLost()) return void (this.failedToCreate = !0);
					if (h$1.shaderSource(P$1, w$1), h$1.compileShader(P$1), !h$1.getShaderParameter(P$1, h$1.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h$1.getShaderInfoLog(P$1)}`);
					h$1.attachShader(this.program, P$1), this.attributes = {};
					const C$1 = {};
					this.numAttributes = _$1.length;
					for (let e$2 = 0; e$2 < this.numAttributes; e$2++) _$1[e$2] && (h$1.bindAttribLocation(this.program, e$2, _$1[e$2]), this.attributes[_$1[e$2]] = e$2);
					if (h$1.linkProgram(this.program), !h$1.getProgramParameter(this.program, h$1.LINK_STATUS)) throw new Error(`Program failed to link: ${h$1.getProgramInfoLog(this.program)}`);
					h$1.deleteShader(P$1), h$1.deleteShader(T$1);
					for (let e$2 = 0; e$2 < b$1.length; e$2++) {
						const t$1 = b$1[e$2];
						if (t$1 && !C$1[t$1]) {
							const e$3 = h$1.getUniformLocation(this.program, t$1);
							e$3 && (C$1[t$1] = e$3);
						}
					}
					this.fixedUniforms = r$1(e$1, C$1), this.terrainUniforms = ((e$2, i$2) => ({
						u_depth: new t.bP(e$2, i$2.u_depth),
						u_terrain: new t.bP(e$2, i$2.u_terrain),
						u_terrain_dim: new t.bg(e$2, i$2.u_terrain_dim),
						u_terrain_matrix: new t.bR(e$2, i$2.u_terrain_matrix),
						u_terrain_unpack: new t.bS(e$2, i$2.u_terrain_unpack),
						u_terrain_exaggeration: new t.bg(e$2, i$2.u_terrain_exaggeration)
					}))(e$1, C$1), this.projectionUniforms = ((e$2, i$2) => ({
						u_projection_matrix: new t.bR(e$2, i$2.u_projection_matrix),
						u_projection_tile_mercator_coords: new t.bS(e$2, i$2.u_projection_tile_mercator_coords),
						u_projection_clipping_plane: new t.bS(e$2, i$2.u_projection_clipping_plane),
						u_projection_transition: new t.bg(e$2, i$2.u_projection_transition),
						u_projection_fallback_matrix: new t.bR(e$2, i$2.u_projection_fallback_matrix)
					}))(e$1, C$1), this.binderUniforms = o$1 ? o$1.getUniforms(e$1, C$1) : [];
				}
				draw(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1, m$1, f$1, g$1, v$1) {
					const b$1 = e$1.gl;
					if (this.failedToCreate) return;
					if (e$1.program.set(this.program), e$1.setDepthMode(i$1), e$1.setStencilMode(o$1), e$1.setColorMode(r$1), e$1.setCullFace(a$1), n$1) {
						e$1.activeTexture.set(b$1.TEXTURE2), b$1.bindTexture(b$1.TEXTURE_2D, n$1.depthTexture), e$1.activeTexture.set(b$1.TEXTURE3), b$1.bindTexture(b$1.TEXTURE_2D, n$1.texture);
						for (const e$2 in this.terrainUniforms) this.terrainUniforms[e$2].set(n$1[e$2]);
					}
					if (l$1) for (const e$2 in l$1) this.projectionUniforms[Ii[e$2]].set(l$1[e$2]);
					if (s$1) for (const e$2 in this.fixedUniforms) this.fixedUniforms[e$2].set(s$1[e$2]);
					m$1 && m$1.setUniforms(e$1, this.binderUniforms, _$1, { zoom: p$1 });
					let x$1 = 0;
					switch (t$1) {
						case b$1.LINES:
							x$1 = 2;
							break;
						case b$1.TRIANGLES:
							x$1 = 3;
							break;
						case b$1.LINE_STRIP: x$1 = 1;
					}
					for (const i$2 of d$1.get()) {
						const o$2 = i$2.vaos || (i$2.vaos = {});
						(o$2[c$1] || (o$2[c$1] = new Pi())).bind(e$1, this, h$1, m$1 ? m$1.getPaintVertexBuffers() : [], u$1, i$2.vertexOffset, f$1, g$1, v$1), b$1.drawElements(t$1, i$2.primitiveLength * x$1, b$1.UNSIGNED_SHORT, i$2.primitiveOffset * x$1 * 2);
					}
				}
			}
			function Ei(e$1, i$1, o$1) {
				const r$1 = 1 / t.aC(o$1, 1, i$1.transform.tileZoom), a$1 = Math.pow(2, o$1.tileID.overscaledZ), s$1 = o$1.tileSize * Math.pow(2, i$1.transform.tileZoom) / a$1, n$1 = s$1 * (o$1.tileID.canonical.x + o$1.tileID.wrap * a$1), l$1 = s$1 * o$1.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: o$1.imageAtlasTexture.size,
					u_scale: [
						r$1,
						e$1.fromScale,
						e$1.toScale
					],
					u_fade: e$1.t,
					u_pixel_coord_upper: [n$1 >> 16, l$1 >> 16],
					u_pixel_coord_lower: [65535 & n$1, 65535 & l$1]
				};
			}
			const Ri = (e$1, i$1, o$1, r$1) => {
				const a$1 = e$1.style.light, s$1 = a$1.properties.get("position"), n$1 = [
					s$1.x,
					s$1.y,
					s$1.z
				], l$1 = t.bV();
				"viewport" === a$1.properties.get("anchor") && t.bW(l$1, e$1.transform.bearingInRadians), t.bX(n$1, n$1, l$1);
				const c$1 = e$1.transform.transformLightDirection(n$1), h$1 = a$1.properties.get("color");
				return {
					u_lightpos: n$1,
					u_lightpos_globe: c$1,
					u_lightintensity: a$1.properties.get("intensity"),
					u_lightcolor: [
						h$1.r,
						h$1.g,
						h$1.b
					],
					u_vertical_gradient: +i$1,
					u_opacity: o$1,
					u_fill_translate: r$1
				};
			}, zi = (e$1, i$1, o$1, r$1, a$1, s$1, n$1) => t.e(Ri(e$1, i$1, o$1, r$1), Ei(s$1, e$1, n$1), { u_height_factor: -Math.pow(2, a$1.overscaledZ) / n$1.tileSize / 8 }), Di = (e$1, i$1, o$1, r$1) => t.e(Ei(i$1, e$1, o$1), { u_fill_translate: r$1 }), Ai = (e$1, t$1) => ({
				u_world: e$1,
				u_fill_translate: t$1
			}), Li = (e$1, i$1, o$1, r$1, a$1) => t.e(Di(e$1, i$1, o$1, a$1), { u_world: r$1 }), ki = (e$1, i$1, o$1, r$1, a$1) => {
				const s$1 = e$1.transform;
				let n$1, l$1, c$1 = 0;
				if ("map" === o$1.paint.get("circle-pitch-alignment")) {
					const e$2 = t.aC(i$1, 1, s$1.zoom);
					n$1 = !0, l$1 = [e$2, e$2], c$1 = e$2 / (t.$ * Math.pow(2, i$1.tileID.overscaledZ)) * 2 * Math.PI * a$1;
				} else n$1 = !1, l$1 = s$1.pixelsToGLUnits;
				return {
					u_camera_to_center_distance: s$1.cameraToCenterDistance,
					u_scale_with_map: +("map" === o$1.paint.get("circle-pitch-scale")),
					u_pitch_with_map: +n$1,
					u_device_pixel_ratio: e$1.pixelRatio,
					u_extrude_scale: l$1,
					u_globe_extrude_scale: c$1,
					u_translate: r$1
				};
			}, Fi = (e$1) => ({ u_pixel_extrude_scale: [1 / e$1.width, 1 / e$1.height] }), Bi = (e$1) => ({ u_viewport_size: [e$1.width, e$1.height] }), Oi = (e$1, t$1 = 1) => ({
				u_color: e$1,
				u_overlay: 0,
				u_overlay_scale: t$1
			}), ji = (e$1, i$1, o$1, r$1) => {
				const a$1 = t.aC(e$1, 1, i$1) / (t.$ * Math.pow(2, e$1.tileID.overscaledZ)) * 2 * Math.PI * r$1;
				return {
					u_extrude_scale: t.aC(e$1, 1, i$1),
					u_intensity: o$1,
					u_globe_extrude_scale: a$1
				};
			}, Ni = (e$1, i$1, o$1, r$1) => {
				const a$1 = t.L();
				t.bY(a$1, 0, e$1.width, e$1.height, 0, 0, 1);
				const s$1 = e$1.context.gl;
				return {
					u_matrix: a$1,
					u_world: [s$1.drawingBufferWidth, s$1.drawingBufferHeight],
					u_image: o$1,
					u_color_ramp: r$1,
					u_opacity: i$1.paint.get("heatmap-opacity")
				};
			}, Ui = (e$1, t$1, i$1) => {
				const o$1 = i$1.paint.get("hillshade-accent-color");
				let r$1;
				switch (i$1.paint.get("hillshade-method")) {
					case "basic":
						r$1 = 4;
						break;
					case "combined":
						r$1 = 1;
						break;
					case "igor":
						r$1 = 2;
						break;
					case "multidirectional":
						r$1 = 3;
						break;
					default: r$1 = 0;
				}
				const a$1 = i$1.getIlluminationProperties();
				for (let t$2 = 0; t$2 < a$1.directionRadians.length; t$2++) "viewport" === i$1.paint.get("hillshade-illumination-anchor") && (a$1.directionRadians[t$2] += e$1.transform.bearingInRadians);
				return {
					u_image: 0,
					u_latrange: Gi(0, t$1.tileID),
					u_exaggeration: i$1.paint.get("hillshade-exaggeration"),
					u_altitudes: a$1.altitudeRadians,
					u_azimuths: a$1.directionRadians,
					u_accent: o$1,
					u_method: r$1,
					u_highlights: a$1.highlightColor,
					u_shadows: a$1.shadowColor
				};
			}, Zi = (e$1, i$1) => {
				const o$1 = i$1.stride, r$1 = t.L();
				return t.bY(r$1, 0, t.$, -t.$, 0, 0, 1), t.M(r$1, r$1, [
					0,
					-t.$,
					0
				]), {
					u_matrix: r$1,
					u_image: 1,
					u_dimension: [o$1, o$1],
					u_zoom: e$1.overscaledZ,
					u_unpack: i$1.getUnpackVector()
				};
			};
			function Gi(e$1, i$1) {
				const o$1 = Math.pow(2, i$1.canonical.z), r$1 = i$1.canonical.y;
				return [new t.a1(0, r$1 / o$1).toLngLat().lat, new t.a1(0, (r$1 + 1) / o$1).toLngLat().lat];
			}
			const Vi = (e$1, t$1, i$1 = 0) => ({
				u_image: 0,
				u_unpack: t$1.getUnpackVector(),
				u_dimension: [t$1.stride, t$1.stride],
				u_elevation_stops: 1,
				u_color_stops: 4,
				u_color_ramp_size: i$1,
				u_opacity: e$1.paint.get("color-relief-opacity")
			}), $i = (e$1, i$1, o$1, r$1) => {
				const a$1 = e$1.transform;
				return {
					u_translation: Ki(e$1, i$1, o$1),
					u_ratio: r$1 / t.aC(i$1, 1, a$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_units_to_pixels: [1 / a$1.pixelsToGLUnits[0], 1 / a$1.pixelsToGLUnits[1]]
				};
			}, qi = (e$1, i$1, o$1, r$1, a$1) => t.e($i(e$1, i$1, o$1, r$1), {
				u_image: 0,
				u_image_height: a$1
			}), Wi = (e$1, i$1, o$1, r$1, a$1) => {
				const s$1 = e$1.transform, n$1 = Xi(i$1, s$1);
				return {
					u_translation: Ki(e$1, i$1, o$1),
					u_texsize: i$1.imageAtlasTexture.size,
					u_ratio: r$1 / t.aC(i$1, 1, s$1.zoom),
					u_device_pixel_ratio: e$1.pixelRatio,
					u_image: 0,
					u_scale: [
						n$1,
						a$1.fromScale,
						a$1.toScale
					],
					u_fade: a$1.t,
					u_units_to_pixels: [1 / s$1.pixelsToGLUnits[0], 1 / s$1.pixelsToGLUnits[1]]
				};
			}, Hi = (e$1, i$1, o$1, r$1, a$1) => {
				const s$1 = Xi(i$1, e$1.transform);
				return t.e($i(e$1, i$1, o$1, r$1), {
					u_tileratio: s$1,
					u_crossfade_from: a$1.fromScale,
					u_crossfade_to: a$1.toScale,
					u_image: 0,
					u_mix: a$1.t,
					u_lineatlas_width: e$1.lineAtlas.width,
					u_lineatlas_height: e$1.lineAtlas.height
				});
			};
			function Xi(e$1, i$1) {
				return 1 / t.aC(e$1, 1, i$1.tileZoom);
			}
			function Ki(e$1, i$1, o$1) {
				return t.aD(e$1.transform, i$1, o$1.paint.get("line-translate"), o$1.paint.get("line-translate-anchor"));
			}
			const Yi = (e$1, t$1, i$1, o$1, r$1) => {
				return {
					u_tl_parent: e$1,
					u_scale_parent: t$1,
					u_buffer_scale: 1,
					u_fade_t: i$1.mix,
					u_opacity: i$1.opacity * o$1.paint.get("raster-opacity"),
					u_image0: 0,
					u_image1: 1,
					u_brightness_low: o$1.paint.get("raster-brightness-min"),
					u_brightness_high: o$1.paint.get("raster-brightness-max"),
					u_saturation_factor: (s$1 = o$1.paint.get("raster-saturation"), s$1 > 0 ? 1 - 1 / (1.001 - s$1) : -s$1),
					u_contrast_factor: (a$1 = o$1.paint.get("raster-contrast"), a$1 > 0 ? 1 / (1 - a$1) : 1 + a$1),
					u_spin_weights: Qi(o$1.paint.get("raster-hue-rotate")),
					u_coords_top: [
						r$1[0].x,
						r$1[0].y,
						r$1[1].x,
						r$1[1].y
					],
					u_coords_bottom: [
						r$1[3].x,
						r$1[3].y,
						r$1[2].x,
						r$1[2].y
					]
				};
				var a$1, s$1;
			};
			function Qi(e$1) {
				e$1 *= Math.PI / 180;
				const t$1 = Math.sin(e$1), i$1 = Math.cos(e$1);
				return [
					(2 * i$1 + 1) / 3,
					(-Math.sqrt(3) * t$1 - i$1 + 1) / 3,
					(Math.sqrt(3) * t$1 - i$1 + 1) / 3
				];
			}
			const Ji = (e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) => {
				const _$1 = s$1.transform;
				return {
					u_is_size_zoom_constant: +("constant" === e$1 || "source" === e$1),
					u_is_size_feature_constant: +("constant" === e$1 || "camera" === e$1),
					u_size_t: t$1 ? t$1.uSizeT : 0,
					u_size: t$1 ? t$1.uSize : 0,
					u_camera_to_center_distance: _$1.cameraToCenterDistance,
					u_pitch: _$1.pitch / 360 * 2 * Math.PI,
					u_rotate_symbol: +i$1,
					u_aspect_ratio: _$1.width / _$1.height,
					u_fade_change: s$1.options.fadeDuration ? s$1.symbolFadeChange : 1,
					u_label_plane_matrix: n$1,
					u_coord_matrix: l$1,
					u_is_text: +h$1,
					u_pitch_with_map: +o$1,
					u_is_along_line: r$1,
					u_is_variable_anchor: a$1,
					u_texsize: u$1,
					u_texture: 0,
					u_translation: c$1,
					u_pitched_scale: d$1
				};
			}, eo = (e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1, p$1) => {
				const m$1 = n$1.transform;
				return t.e(Ji(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, p$1), {
					u_gamma_scale: r$1 ? Math.cos(m$1.pitch * Math.PI / 180) * m$1.cameraToCenterDistance : 1,
					u_device_pixel_ratio: n$1.pixelRatio,
					u_is_halo: 1
				});
			}, to = (e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) => t.e(eo(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, !0, u$1, 0, _$1), {
				u_texsize_icon: d$1,
				u_texture_icon: 1
			}), io = (e$1, t$1) => ({
				u_opacity: e$1,
				u_color: t$1
			}), oo = (e$1, i$1, o$1, r$1, a$1) => t.e(function(e$2, i$2, o$2, r$2) {
				const a$2 = o$2.imageManager.getPattern(e$2.from.toString()), s$1 = o$2.imageManager.getPattern(e$2.to.toString()), { width: n$1, height: l$1 } = o$2.imageManager.getPixelSize(), c$1 = Math.pow(2, r$2.tileID.overscaledZ), h$1 = r$2.tileSize * Math.pow(2, o$2.transform.tileZoom) / c$1, u$1 = h$1 * (r$2.tileID.canonical.x + r$2.tileID.wrap * c$1), d$1 = h$1 * r$2.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl_a: a$2.tl,
					u_pattern_br_a: a$2.br,
					u_pattern_tl_b: s$1.tl,
					u_pattern_br_b: s$1.br,
					u_texsize: [n$1, l$1],
					u_mix: i$2.t,
					u_pattern_size_a: a$2.displaySize,
					u_pattern_size_b: s$1.displaySize,
					u_scale_a: i$2.fromScale,
					u_scale_b: i$2.toScale,
					u_tile_units_to_pixels: 1 / t.aC(r$2, 1, o$2.transform.tileZoom),
					u_pixel_coord_upper: [u$1 >> 16, d$1 >> 16],
					u_pixel_coord_lower: [65535 & u$1, 65535 & d$1]
				};
			}(o$1, a$1, i$1, r$1), { u_opacity: e$1 }), ro = (e$1, t$1) => {}, ao = {
				fillExtrusion: (e$1, i$1) => ({
					u_lightpos: new t.bT(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.bT(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bg(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.bT(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bg(e$1, i$1.u_vertical_gradient),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillExtrusionPattern: (e$1, i$1) => ({
					u_lightpos: new t.bT(e$1, i$1.u_lightpos),
					u_lightpos_globe: new t.bT(e$1, i$1.u_lightpos_globe),
					u_lightintensity: new t.bg(e$1, i$1.u_lightintensity),
					u_lightcolor: new t.bT(e$1, i$1.u_lightcolor),
					u_vertical_gradient: new t.bg(e$1, i$1.u_vertical_gradient),
					u_height_factor: new t.bg(e$1, i$1.u_height_factor),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate),
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade)
				}),
				fill: (e$1, i$1) => ({ u_fill_translate: new t.bU(e$1, i$1.u_fill_translate) }),
				fillPattern: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillOutline: (e$1, i$1) => ({
					u_world: new t.bU(e$1, i$1.u_world),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				fillOutlinePattern: (e$1, i$1) => ({
					u_world: new t.bU(e$1, i$1.u_world),
					u_image: new t.bP(e$1, i$1.u_image),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade),
					u_fill_translate: new t.bU(e$1, i$1.u_fill_translate)
				}),
				circle: (e$1, i$1) => ({
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_scale_with_map: new t.bP(e$1, i$1.u_scale_with_map),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_extrude_scale: new t.bU(e$1, i$1.u_extrude_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_globe_extrude_scale: new t.bg(e$1, i$1.u_globe_extrude_scale),
					u_translate: new t.bU(e$1, i$1.u_translate)
				}),
				collisionBox: (e$1, i$1) => ({ u_pixel_extrude_scale: new t.bU(e$1, i$1.u_pixel_extrude_scale) }),
				collisionCircle: (e$1, i$1) => ({ u_viewport_size: new t.bU(e$1, i$1.u_viewport_size) }),
				debug: (e$1, i$1) => ({
					u_color: new t.bQ(e$1, i$1.u_color),
					u_overlay: new t.bP(e$1, i$1.u_overlay),
					u_overlay_scale: new t.bg(e$1, i$1.u_overlay_scale)
				}),
				depth: ro,
				clippingMask: ro,
				heatmap: (e$1, i$1) => ({
					u_extrude_scale: new t.bg(e$1, i$1.u_extrude_scale),
					u_intensity: new t.bg(e$1, i$1.u_intensity),
					u_globe_extrude_scale: new t.bg(e$1, i$1.u_globe_extrude_scale)
				}),
				heatmapTexture: (e$1, i$1) => ({
					u_matrix: new t.bR(e$1, i$1.u_matrix),
					u_world: new t.bU(e$1, i$1.u_world),
					u_image: new t.bP(e$1, i$1.u_image),
					u_color_ramp: new t.bP(e$1, i$1.u_color_ramp),
					u_opacity: new t.bg(e$1, i$1.u_opacity)
				}),
				hillshade: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_latrange: new t.bU(e$1, i$1.u_latrange),
					u_exaggeration: new t.bg(e$1, i$1.u_exaggeration),
					u_altitudes: new t.b_(e$1, i$1.u_altitudes),
					u_azimuths: new t.b_(e$1, i$1.u_azimuths),
					u_accent: new t.bQ(e$1, i$1.u_accent),
					u_method: new t.bP(e$1, i$1.u_method),
					u_shadows: new t.bZ(e$1, i$1.u_shadows),
					u_highlights: new t.bZ(e$1, i$1.u_highlights)
				}),
				hillshadePrepare: (e$1, i$1) => ({
					u_matrix: new t.bR(e$1, i$1.u_matrix),
					u_image: new t.bP(e$1, i$1.u_image),
					u_dimension: new t.bU(e$1, i$1.u_dimension),
					u_zoom: new t.bg(e$1, i$1.u_zoom),
					u_unpack: new t.bS(e$1, i$1.u_unpack)
				}),
				colorRelief: (e$1, i$1) => ({
					u_image: new t.bP(e$1, i$1.u_image),
					u_unpack: new t.bS(e$1, i$1.u_unpack),
					u_dimension: new t.bU(e$1, i$1.u_dimension),
					u_elevation_stops: new t.bP(e$1, i$1.u_elevation_stops),
					u_color_stops: new t.bP(e$1, i$1.u_color_stops),
					u_color_ramp_size: new t.bP(e$1, i$1.u_color_ramp_size),
					u_opacity: new t.bg(e$1, i$1.u_opacity)
				}),
				line: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels)
				}),
				lineGradient: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_image: new t.bP(e$1, i$1.u_image),
					u_image_height: new t.bg(e$1, i$1.u_image_height)
				}),
				linePattern: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_image: new t.bP(e$1, i$1.u_image),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_scale: new t.bT(e$1, i$1.u_scale),
					u_fade: new t.bg(e$1, i$1.u_fade)
				}),
				lineSDF: (e$1, i$1) => ({
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_ratio: new t.bg(e$1, i$1.u_ratio),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_units_to_pixels: new t.bU(e$1, i$1.u_units_to_pixels),
					u_image: new t.bP(e$1, i$1.u_image),
					u_mix: new t.bg(e$1, i$1.u_mix),
					u_tileratio: new t.bg(e$1, i$1.u_tileratio),
					u_crossfade_from: new t.bg(e$1, i$1.u_crossfade_from),
					u_crossfade_to: new t.bg(e$1, i$1.u_crossfade_to),
					u_lineatlas_width: new t.bg(e$1, i$1.u_lineatlas_width),
					u_lineatlas_height: new t.bg(e$1, i$1.u_lineatlas_height)
				}),
				raster: (e$1, i$1) => ({
					u_tl_parent: new t.bU(e$1, i$1.u_tl_parent),
					u_scale_parent: new t.bg(e$1, i$1.u_scale_parent),
					u_buffer_scale: new t.bg(e$1, i$1.u_buffer_scale),
					u_fade_t: new t.bg(e$1, i$1.u_fade_t),
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_image0: new t.bP(e$1, i$1.u_image0),
					u_image1: new t.bP(e$1, i$1.u_image1),
					u_brightness_low: new t.bg(e$1, i$1.u_brightness_low),
					u_brightness_high: new t.bg(e$1, i$1.u_brightness_high),
					u_saturation_factor: new t.bg(e$1, i$1.u_saturation_factor),
					u_contrast_factor: new t.bg(e$1, i$1.u_contrast_factor),
					u_spin_weights: new t.bT(e$1, i$1.u_spin_weights),
					u_coords_top: new t.bS(e$1, i$1.u_coords_top),
					u_coords_bottom: new t.bS(e$1, i$1.u_coords_bottom)
				}),
				symbolIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				symbolSDF: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_gamma_scale: new t.bg(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.bP(e$1, i$1.u_is_halo),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				symbolTextAndIcon: (e$1, i$1) => ({
					u_is_size_zoom_constant: new t.bP(e$1, i$1.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bP(e$1, i$1.u_is_size_feature_constant),
					u_size_t: new t.bg(e$1, i$1.u_size_t),
					u_size: new t.bg(e$1, i$1.u_size),
					u_camera_to_center_distance: new t.bg(e$1, i$1.u_camera_to_center_distance),
					u_pitch: new t.bg(e$1, i$1.u_pitch),
					u_rotate_symbol: new t.bP(e$1, i$1.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e$1, i$1.u_aspect_ratio),
					u_fade_change: new t.bg(e$1, i$1.u_fade_change),
					u_label_plane_matrix: new t.bR(e$1, i$1.u_label_plane_matrix),
					u_coord_matrix: new t.bR(e$1, i$1.u_coord_matrix),
					u_is_text: new t.bP(e$1, i$1.u_is_text),
					u_pitch_with_map: new t.bP(e$1, i$1.u_pitch_with_map),
					u_is_along_line: new t.bP(e$1, i$1.u_is_along_line),
					u_is_variable_anchor: new t.bP(e$1, i$1.u_is_variable_anchor),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_texsize_icon: new t.bU(e$1, i$1.u_texsize_icon),
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_texture_icon: new t.bP(e$1, i$1.u_texture_icon),
					u_gamma_scale: new t.bg(e$1, i$1.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e$1, i$1.u_device_pixel_ratio),
					u_is_halo: new t.bP(e$1, i$1.u_is_halo),
					u_translation: new t.bU(e$1, i$1.u_translation),
					u_pitched_scale: new t.bg(e$1, i$1.u_pitched_scale)
				}),
				background: (e$1, i$1) => ({
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_color: new t.bQ(e$1, i$1.u_color)
				}),
				backgroundPattern: (e$1, i$1) => ({
					u_opacity: new t.bg(e$1, i$1.u_opacity),
					u_image: new t.bP(e$1, i$1.u_image),
					u_pattern_tl_a: new t.bU(e$1, i$1.u_pattern_tl_a),
					u_pattern_br_a: new t.bU(e$1, i$1.u_pattern_br_a),
					u_pattern_tl_b: new t.bU(e$1, i$1.u_pattern_tl_b),
					u_pattern_br_b: new t.bU(e$1, i$1.u_pattern_br_b),
					u_texsize: new t.bU(e$1, i$1.u_texsize),
					u_mix: new t.bg(e$1, i$1.u_mix),
					u_pattern_size_a: new t.bU(e$1, i$1.u_pattern_size_a),
					u_pattern_size_b: new t.bU(e$1, i$1.u_pattern_size_b),
					u_scale_a: new t.bg(e$1, i$1.u_scale_a),
					u_scale_b: new t.bg(e$1, i$1.u_scale_b),
					u_pixel_coord_upper: new t.bU(e$1, i$1.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bU(e$1, i$1.u_pixel_coord_lower),
					u_tile_units_to_pixels: new t.bg(e$1, i$1.u_tile_units_to_pixels)
				}),
				terrain: (e$1, i$1) => ({
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_ele_delta: new t.bg(e$1, i$1.u_ele_delta),
					u_fog_matrix: new t.bR(e$1, i$1.u_fog_matrix),
					u_fog_color: new t.bQ(e$1, i$1.u_fog_color),
					u_fog_ground_blend: new t.bg(e$1, i$1.u_fog_ground_blend),
					u_fog_ground_blend_opacity: new t.bg(e$1, i$1.u_fog_ground_blend_opacity),
					u_horizon_color: new t.bQ(e$1, i$1.u_horizon_color),
					u_horizon_fog_blend: new t.bg(e$1, i$1.u_horizon_fog_blend),
					u_is_globe_mode: new t.bg(e$1, i$1.u_is_globe_mode)
				}),
				terrainDepth: (e$1, i$1) => ({ u_ele_delta: new t.bg(e$1, i$1.u_ele_delta) }),
				terrainCoords: (e$1, i$1) => ({
					u_texture: new t.bP(e$1, i$1.u_texture),
					u_terrain_coords_id: new t.bg(e$1, i$1.u_terrain_coords_id),
					u_ele_delta: new t.bg(e$1, i$1.u_ele_delta)
				}),
				projectionErrorMeasurement: (e$1, i$1) => ({
					u_input: new t.bg(e$1, i$1.u_input),
					u_output_expected: new t.bg(e$1, i$1.u_output_expected)
				}),
				atmosphere: (e$1, i$1) => ({
					u_sun_pos: new t.bT(e$1, i$1.u_sun_pos),
					u_atmosphere_blend: new t.bg(e$1, i$1.u_atmosphere_blend),
					u_globe_position: new t.bT(e$1, i$1.u_globe_position),
					u_globe_radius: new t.bg(e$1, i$1.u_globe_radius),
					u_inv_proj_matrix: new t.bR(e$1, i$1.u_inv_proj_matrix)
				}),
				sky: (e$1, i$1) => ({
					u_sky_color: new t.bQ(e$1, i$1.u_sky_color),
					u_horizon_color: new t.bQ(e$1, i$1.u_horizon_color),
					u_horizon: new t.bU(e$1, i$1.u_horizon),
					u_horizon_normal: new t.bU(e$1, i$1.u_horizon_normal),
					u_sky_horizon_blend: new t.bg(e$1, i$1.u_sky_horizon_blend),
					u_sky_blend: new t.bg(e$1, i$1.u_sky_blend)
				})
			};
			class so {
				constructor(e$1, t$1, i$1) {
					this.context = e$1;
					const o$1 = e$1.gl;
					this.buffer = o$1.createBuffer(), this.dynamicDraw = Boolean(i$1), this.context.unbindVAO(), e$1.bindElementBuffer.set(this.buffer), o$1.bufferData(o$1.ELEMENT_ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? o$1.DYNAMIC_DRAW : o$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e$1) {
					const t$1 = this.context.gl;
					if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
					this.context.unbindVAO(), this.bind(), t$1.bufferSubData(t$1.ELEMENT_ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			const no = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class lo {
				constructor(e$1, t$1, i$1, o$1) {
					this.length = t$1.length, this.attributes = i$1, this.itemSize = t$1.bytesPerElement, this.dynamicDraw = o$1, this.context = e$1;
					const r$1 = e$1.gl;
					this.buffer = r$1.createBuffer(), e$1.bindVertexBuffer.set(this.buffer), r$1.bufferData(r$1.ARRAY_BUFFER, t$1.arrayBuffer, this.dynamicDraw ? r$1.DYNAMIC_DRAW : r$1.STATIC_DRAW), this.dynamicDraw || delete t$1.arrayBuffer;
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e$1) {
					if (e$1.length !== this.length) throw new Error(`Length of new data is ${e$1.length}, which doesn't match current length of ${this.length}`);
					const t$1 = this.context.gl;
					this.bind(), t$1.bufferSubData(t$1.ARRAY_BUFFER, 0, e$1.arrayBuffer);
				}
				enableAttributes(e$1, t$1) {
					for (let i$1 = 0; i$1 < this.attributes.length; i$1++) {
						const o$1 = t$1.attributes[this.attributes[i$1].name];
						void 0 !== o$1 && e$1.enableVertexAttribArray(o$1);
					}
				}
				setVertexAttribPointers(e$1, t$1, i$1) {
					for (let o$1 = 0; o$1 < this.attributes.length; o$1++) {
						const r$1 = this.attributes[o$1], a$1 = t$1.attributes[r$1.name];
						void 0 !== a$1 && e$1.vertexAttribPointer(a$1, r$1.components, e$1[no[r$1.type]], !1, this.itemSize, r$1.offset + this.itemSize * (i$1 || 0));
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class co {
				constructor(e$1) {
					this.gl = e$1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e$1) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class ho extends co {
				getDefault() {
					return t.bf.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.clearColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class uo extends co {
				getDefault() {
					return 1;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearDepth(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class _o extends co {
				getDefault() {
					return 0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.clearStencil(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class po extends co {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.colorMask(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class mo extends co {
				getDefault() {
					return !0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class fo extends co {
				getDefault() {
					return 255;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.stencilMask(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class go extends co {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.func !== t$1.func || e$1.ref !== t$1.ref || e$1.mask !== t$1.mask || this.dirty) && (this.gl.stencilFunc(e$1.func, e$1.ref, e$1.mask), this.current = e$1, this.dirty = !1);
				}
			}
			class vo extends co {
				getDefault() {
					const e$1 = this.gl;
					return [
						e$1.KEEP,
						e$1.KEEP,
						e$1.KEEP
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || this.dirty) && (this.gl.stencilOp(e$1[0], e$1[1], e$1[2]), this.current = e$1, this.dirty = !1);
				}
			}
			class bo extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.STENCIL_TEST) : t$1.disable(t$1.STENCIL_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class xo extends co {
				getDefault() {
					return [0, 1];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.depthRange(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class yo extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.DEPTH_TEST) : t$1.disable(t$1.DEPTH_TEST), this.current = e$1, this.dirty = !1;
				}
			}
			class wo extends co {
				getDefault() {
					return this.gl.LESS;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.depthFunc(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class To extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.BLEND) : t$1.disable(t$1.BLEND), this.current = e$1, this.dirty = !1;
				}
			}
			class Po extends co {
				getDefault() {
					const e$1 = this.gl;
					return [e$1.ONE, e$1.ZERO];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || this.dirty) && (this.gl.blendFunc(e$1[0], e$1[1]), this.current = e$1, this.dirty = !1);
				}
			}
			class Co extends co {
				getDefault() {
					return t.bf.transparent;
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1.r !== t$1.r || e$1.g !== t$1.g || e$1.b !== t$1.b || e$1.a !== t$1.a || this.dirty) && (this.gl.blendColor(e$1.r, e$1.g, e$1.b, e$1.a), this.current = e$1, this.dirty = !1);
				}
			}
			class Io extends co {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.blendEquation(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Mo extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					e$1 ? t$1.enable(t$1.CULL_FACE) : t$1.disable(t$1.CULL_FACE), this.current = e$1, this.dirty = !1;
				}
			}
			class So extends co {
				getDefault() {
					return this.gl.BACK;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.cullFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Eo extends co {
				getDefault() {
					return this.gl.CCW;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.frontFace(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Ro extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.useProgram(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class zo extends co {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e$1) {
					(e$1 !== this.current || this.dirty) && (this.gl.activeTexture(e$1), this.current = e$1, this.dirty = !1);
				}
			}
			class Do extends co {
				getDefault() {
					const e$1 = this.gl;
					return [
						0,
						0,
						e$1.drawingBufferWidth,
						e$1.drawingBufferHeight
					];
				}
				set(e$1) {
					const t$1 = this.current;
					(e$1[0] !== t$1[0] || e$1[1] !== t$1[1] || e$1[2] !== t$1[2] || e$1[3] !== t$1[3] || this.dirty) && (this.gl.viewport(e$1[0], e$1[1], e$1[2], e$1[3]), this.current = e$1, this.dirty = !1);
				}
			}
			class Ao extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindFramebuffer(t$1.FRAMEBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Lo extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindRenderbuffer(t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class ko extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindTexture(t$1.TEXTURE_2D, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Fo extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Bo extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					const t$1 = this.gl;
					t$1.bindBuffer(t$1.ELEMENT_ARRAY_BUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Oo extends co {
				getDefault() {
					return null;
				}
				set(e$1) {
					var t$1;
					if (e$1 === this.current && !this.dirty) return;
					const i$1 = this.gl;
					qt(i$1) ? i$1.bindVertexArray(e$1) : null === (t$1 = i$1.getExtension("OES_vertex_array_object")) || void 0 === t$1 || t$1.bindVertexArrayOES(e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class jo extends co {
				getDefault() {
					return 4;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_ALIGNMENT, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class No extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Uo extends co {
				getDefault() {
					return !1;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					const t$1 = this.gl;
					t$1.pixelStorei(t$1.UNPACK_FLIP_Y_WEBGL, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class Zo extends co {
				constructor(e$1, t$1) {
					super(e$1), this.context = e$1, this.parent = t$1;
				}
				getDefault() {
					return null;
				}
			}
			class Go extends Zo {
				setDirty() {
					this.dirty = !0;
				}
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferTexture2D(t$1.FRAMEBUFFER, t$1.COLOR_ATTACHMENT0, t$1.TEXTURE_2D, e$1, 0), this.current = e$1, this.dirty = !1;
				}
			}
			class Vo extends Zo {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			class $o extends Zo {
				set(e$1) {
					if (e$1 === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					const t$1 = this.gl;
					t$1.framebufferRenderbuffer(t$1.FRAMEBUFFER, t$1.DEPTH_STENCIL_ATTACHMENT, t$1.RENDERBUFFER, e$1), this.current = e$1, this.dirty = !1;
				}
			}
			const qo = "Framebuffer is not complete";
			class Wo {
				constructor(e$1, t$1, i$1, o$1, r$1) {
					this.context = e$1, this.width = t$1, this.height = i$1;
					const a$1 = e$1.gl, s$1 = this.framebuffer = a$1.createFramebuffer();
					if (this.colorAttachment = new Go(e$1, s$1), o$1) this.depthAttachment = r$1 ? new $o(e$1, s$1) : new Vo(e$1, s$1);
					else if (r$1) throw new Error("Stencil cannot be set without depth");
					if (a$1.checkFramebufferStatus(a$1.FRAMEBUFFER) !== a$1.FRAMEBUFFER_COMPLETE) throw new Error(qo);
				}
				destroy() {
					const e$1 = this.context.gl, t$1 = this.colorAttachment.get();
					if (t$1 && e$1.deleteTexture(t$1), this.depthAttachment) {
						const t$2 = this.depthAttachment.get();
						t$2 && e$1.deleteRenderbuffer(t$2);
					}
					e$1.deleteFramebuffer(this.framebuffer);
				}
			}
			class Ho {
				constructor(e$1) {
					var t$1, i$1;
					if (this.gl = e$1, this.clearColor = new ho(this), this.clearDepth = new uo(this), this.clearStencil = new _o(this), this.colorMask = new po(this), this.depthMask = new mo(this), this.stencilMask = new fo(this), this.stencilFunc = new go(this), this.stencilOp = new vo(this), this.stencilTest = new bo(this), this.depthRange = new xo(this), this.depthTest = new yo(this), this.depthFunc = new wo(this), this.blend = new To(this), this.blendFunc = new Po(this), this.blendColor = new Co(this), this.blendEquation = new Io(this), this.cullFace = new Mo(this), this.cullFaceSide = new So(this), this.frontFace = new Eo(this), this.program = new Ro(this), this.activeTexture = new zo(this), this.viewport = new Do(this), this.bindFramebuffer = new Ao(this), this.bindRenderbuffer = new Lo(this), this.bindTexture = new ko(this), this.bindVertexBuffer = new Fo(this), this.bindElementBuffer = new Bo(this), this.bindVertexArray = new Oo(this), this.pixelStoreUnpack = new jo(this), this.pixelStoreUnpackPremultiplyAlpha = new No(this), this.pixelStoreUnpackFlipY = new Uo(this), this.extTextureFilterAnisotropic = e$1.getExtension("EXT_texture_filter_anisotropic") || e$1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e$1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e$1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e$1.getParameter(e$1.MAX_TEXTURE_SIZE), qt(e$1)) {
						this.HALF_FLOAT = e$1.HALF_FLOAT;
						const o$1 = e$1.getExtension("EXT_color_buffer_half_float");
						this.RGBA16F = null !== (t$1 = e$1.RGBA16F) && void 0 !== t$1 ? t$1 : null == o$1 ? void 0 : o$1.RGBA16F_EXT, this.RGB16F = null !== (i$1 = e$1.RGB16F) && void 0 !== i$1 ? i$1 : null == o$1 ? void 0 : o$1.RGB16F_EXT, e$1.getExtension("EXT_color_buffer_float");
					} else {
						e$1.getExtension("EXT_color_buffer_half_float"), e$1.getExtension("OES_texture_half_float_linear");
						const t$2 = e$1.getExtension("OES_texture_half_float");
						this.HALF_FLOAT = null == t$2 ? void 0 : t$2.HALF_FLOAT_OES;
					}
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e$1, t$1) {
					return new so(this, e$1, t$1);
				}
				createVertexBuffer(e$1, t$1, i$1) {
					return new lo(this, e$1, t$1, i$1);
				}
				createRenderbuffer(e$1, t$1, i$1) {
					const o$1 = this.gl, r$1 = o$1.createRenderbuffer();
					return this.bindRenderbuffer.set(r$1), o$1.renderbufferStorage(o$1.RENDERBUFFER, e$1, t$1, i$1), this.bindRenderbuffer.set(null), r$1;
				}
				createFramebuffer(e$1, t$1, i$1, o$1) {
					return new Wo(this, e$1, t$1, i$1, o$1);
				}
				clear({ color: e$1, depth: t$1, stencil: i$1 }) {
					const o$1 = this.gl;
					let r$1 = 0;
					e$1 && (r$1 |= o$1.COLOR_BUFFER_BIT, this.clearColor.set(e$1), this.colorMask.set([
						!0,
						!0,
						!0,
						!0
					])), void 0 !== t$1 && (r$1 |= o$1.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t$1), this.depthMask.set(!0)), void 0 !== i$1 && (r$1 |= o$1.STENCIL_BUFFER_BIT, this.clearStencil.set(i$1), this.stencilMask.set(255)), o$1.clear(r$1);
				}
				setCullFace(e$1) {
					!1 === e$1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e$1.mode), this.frontFace.set(e$1.frontFace));
				}
				setDepthMode(e$1) {
					e$1.func !== this.gl.ALWAYS || e$1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e$1.func), this.depthMask.set(e$1.mask), this.depthRange.set(e$1.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e$1) {
					e$1.test.func !== this.gl.ALWAYS || e$1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e$1.mask), this.stencilOp.set([
						e$1.fail,
						e$1.depthFail,
						e$1.pass
					]), this.stencilFunc.set({
						func: e$1.test.func,
						ref: e$1.ref,
						mask: e$1.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(e$1) {
					t.bH(e$1.blendFunction, jt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e$1.blendFunction), this.blendColor.set(e$1.blendColor)), this.colorMask.set(e$1.mask);
				}
				createVertexArray() {
					var e$1;
					return qt(this.gl) ? this.gl.createVertexArray() : null === (e$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e$1 ? void 0 : e$1.createVertexArrayOES();
				}
				deleteVertexArray(e$1) {
					var t$1;
					return qt(this.gl) ? this.gl.deleteVertexArray(e$1) : null === (t$1 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t$1 ? void 0 : t$1.deleteVertexArrayOES(e$1);
				}
				unbindVAO() {
					this.bindVertexArray.set(null);
				}
			}
			let Xo;
			function Ko(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = e$1.transform, l$1 = s$1.gl, c$1 = e$1.useProgram("collisionBox"), h$1 = [];
				let u$1 = 0, d$1 = 0;
				for (let t$1 = 0; t$1 < r$1.length; t$1++) {
					const _$2 = r$1[t$1], p$2 = i$1.getTile(_$2).getBucket(o$1);
					if (!p$2) continue;
					const m$2 = a$1 ? p$2.textCollisionBox : p$2.iconCollisionBox, f$2 = p$2.collisionCircleArray;
					f$2.length > 0 && (h$1.push({
						circleArray: f$2,
						circleOffset: d$1,
						coord: _$2
					}), u$1 += f$2.length / 4, d$1 = u$1), m$2 && c$1.draw(s$1, l$1.LINES, Zt.disabled, Vt.disabled, e$1.colorModeForRenderPass(), Ut.disabled, Fi(e$1.transform), e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(_$2), n$1.getProjectionData({
						overscaledTileID: _$2,
						applyGlobeMatrix: !0,
						applyTerrainMatrix: !0
					}), o$1.id, m$2.layoutVertexBuffer, m$2.indexBuffer, m$2.segments, null, e$1.transform.zoom, null, null, m$2.collisionVertexBuffer);
				}
				if (!a$1 || !h$1.length) return;
				const _$1 = e$1.useProgram("collisionCircle"), p$1 = new t.b$();
				p$1.resize(4 * u$1), p$1._trim();
				let m$1 = 0;
				for (const e$2 of h$1) for (let t$1 = 0; t$1 < e$2.circleArray.length / 4; t$1++) {
					const i$2 = 4 * t$1, o$2 = e$2.circleArray[i$2 + 0], r$2 = e$2.circleArray[i$2 + 1], a$2 = e$2.circleArray[i$2 + 2], s$2 = e$2.circleArray[i$2 + 3];
					p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 0), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 1), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 2), p$1.emplace(m$1++, o$2, r$2, a$2, s$2, 3);
				}
				(!Xo || Xo.length < 2 * u$1) && (Xo = function(e$2) {
					const i$2 = 2 * e$2, o$2 = new t.c1();
					o$2.resize(i$2), o$2._trim();
					for (let e$3 = 0; e$3 < i$2; e$3++) {
						const t$1 = 6 * e$3;
						o$2.uint16[t$1 + 0] = 4 * e$3 + 0, o$2.uint16[t$1 + 1] = 4 * e$3 + 1, o$2.uint16[t$1 + 2] = 4 * e$3 + 2, o$2.uint16[t$1 + 3] = 4 * e$3 + 2, o$2.uint16[t$1 + 4] = 4 * e$3 + 3, o$2.uint16[t$1 + 5] = 4 * e$3 + 0;
					}
					return o$2;
				}(u$1));
				const f$1 = s$1.createIndexBuffer(Xo, !0), g$1 = s$1.createVertexBuffer(p$1, t.c0.members, !0);
				for (const i$2 of h$1) {
					const r$2 = Bi(e$1.transform);
					_$1.draw(s$1, l$1.TRIANGLES, Zt.disabled, Vt.disabled, e$1.colorModeForRenderPass(), Ut.disabled, r$2, e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(i$2.coord), null, o$1.id, g$1, f$1, t.aM.simpleSegment(0, 2 * i$2.circleOffset, i$2.circleArray.length, i$2.circleArray.length / 2), null, e$1.transform.zoom, null, null, null);
				}
				g$1.destroy(), f$1.destroy();
			}
			const Yo = t.ag(new Float32Array(16));
			function Qo(e$1, i$1, o$1, r$1, a$1, s$1) {
				const { horizontalAlign: n$1, verticalAlign: l$1 } = t.aH(e$1);
				return new t.P((-(n$1 - .5) * i$1 / a$1 + r$1[0]) * s$1, (-(l$1 - .5) * o$1 / a$1 + r$1[1]) * s$1);
			}
			function Jo(e$1, i$1, o$1, r$1, a$1, s$1) {
				const n$1 = i$1.tileAnchorPoint.add(new t.P(i$1.translation[0], i$1.translation[1]));
				if (i$1.pitchWithMap) {
					let e$2 = r$1.mult(s$1);
					o$1 || (e$2 = e$2.rotate(-a$1));
					const t$1 = n$1.add(e$2);
					return Ee(t$1.x, t$1.y, i$1.pitchedLabelPlaneMatrix, i$1.getElevation).point;
				}
				if (o$1) {
					const t$1 = Oe(i$1.tileAnchorPoint.x + 1, i$1.tileAnchorPoint.y, i$1).point.sub(e$1), o$2 = Math.atan(t$1.y / t$1.x) + (t$1.x < 0 ? Math.PI : 0);
					return e$1.add(r$1.rotate(o$2));
				}
				return e$1.add(r$1);
			}
			function er(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1) {
				const _$1 = e$1.text.placedSymbolArray, p$1 = e$1.text.dynamicLayoutVertexArray, m$1 = e$1.icon.dynamicLayoutVertexArray, f$1 = {};
				p$1.clear();
				for (let m$2 = 0; m$2 < _$1.length; m$2++) {
					const g$1 = _$1.get(m$2), v$1 = g$1.hidden || !g$1.crossTileID || e$1.allowVerticalPlacement && !g$1.placedOrientation ? null : r$1[g$1.crossTileID];
					if (v$1) {
						const r$2 = new t.P(g$1.anchorX, g$1.anchorY), _$2 = {
							getElevation: d$1,
							width: a$1.width,
							height: a$1.height,
							pitchedLabelPlaneMatrix: s$1,
							pitchWithMap: o$1,
							transform: a$1,
							tileAnchorPoint: r$2,
							translation: h$1,
							unwrappedTileID: u$1
						}, m$3 = o$1 ? Ne(r$2.x, r$2.y, _$2) : Oe(r$2.x, r$2.y, _$2), b$1 = Re(a$1.cameraToCenterDistance, m$3.signedDistanceFromCamera);
						let x$1 = t.ap(e$1.textSizeData, l$1, g$1) * b$1 / t.aB;
						o$1 && (x$1 *= e$1.tilePixelRatio / n$1);
						const { width: y$1, height: w$1, anchor: T$1, textOffset: P$1, textBoxScale: C$1 } = v$1, I$1 = Qo(T$1, y$1, w$1, P$1, C$1, x$1), M$1 = a$1.getPitchedTextCorrection(r$2.x + h$1[0], r$2.y + h$1[1], u$1), S$1 = Jo(m$3.point, _$2, i$1, I$1, -a$1.bearingInRadians, M$1), E$1 = e$1.allowVerticalPlacement && g$1.placedOrientation === t.ao.vertical ? Math.PI / 2 : 0;
						for (let e$2 = 0; e$2 < g$1.numGlyphs; e$2++) t.av(p$1, S$1, E$1);
						c$1 && g$1.associatedIconIndex >= 0 && (f$1[g$1.associatedIconIndex] = {
							shiftedAnchor: S$1,
							angle: E$1
						});
					} else $e(g$1.numGlyphs, p$1);
				}
				if (c$1) {
					m$1.clear();
					const i$2 = e$1.icon.placedSymbolArray;
					for (let e$2 = 0; e$2 < i$2.length; e$2++) {
						const o$2 = i$2.get(e$2);
						if (o$2.hidden) $e(o$2.numGlyphs, m$1);
						else {
							const i$3 = f$1[e$2];
							if (i$3) for (let e$3 = 0; e$3 < o$2.numGlyphs; e$3++) t.av(m$1, i$3.shiftedAnchor, i$3.angle);
							else $e(o$2.numGlyphs, m$1);
						}
					}
					e$1.icon.dynamicLayoutVertexBuffer.updateData(m$1);
				}
				e$1.text.dynamicLayoutVertexBuffer.updateData(p$1);
			}
			function tr(e$1, t$1, i$1) {
				return i$1.iconsInText && t$1 ? "symbolTextAndIcon" : e$1 ? "symbolSDF" : "symbolIcon";
			}
			function ir(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1, u$1, d$1, _$1) {
				const p$1 = e$1.context, m$1 = p$1.gl, f$1 = e$1.transform, g$1 = "map" === l$1, v$1 = "map" === c$1, b$1 = "viewport" !== l$1 && "point" !== o$1.layout.get("symbol-placement"), x$1 = g$1 && !v$1 && !b$1, y$1 = !o$1.layout.get("symbol-sort-key").isConstant();
				let w$1 = !1;
				const T$1 = e$1.getDepthModeForSublayer(0, Zt.ReadOnly), P$1 = o$1._unevaluatedLayout.hasValue("text-variable-anchor") || o$1._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C$1 = [], I$1 = f$1.getCircleRadiusCorrection();
				for (const l$2 of r$1) {
					const r$2 = i$1.getTile(l$2), c$2 = r$2.getBucket(o$1);
					if (!c$2) continue;
					const u$2 = a$1 ? c$2.text : c$2.icon;
					if (!u$2 || !u$2.segments.get().length || !u$2.hasVisibleVertices) continue;
					const d$2 = u$2.programConfigurations.get(o$1.id), p$2 = a$1 || c$2.sdfIcons, T$2 = a$1 ? c$2.textSizeData : c$2.iconSizeData, M$1 = v$1 || 0 !== f$1.pitch, S$1 = e$1.useProgram(tr(p$2, a$1, c$2), d$2), E$1 = t.an(T$2, f$1.zoom), R$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(l$2);
					let z$1, D$1, A$1, L$1, k$1 = [0, 0], F$1 = null;
					if (a$1) D$1 = r$2.glyphAtlasTexture, A$1 = m$1.LINEAR, z$1 = r$2.glyphAtlasTexture.size, c$2.iconsInText && (k$1 = r$2.imageAtlasTexture.size, F$1 = r$2.imageAtlasTexture, L$1 = M$1 || e$1.options.rotating || e$1.options.zooming || "composite" === T$2.kind || "camera" === T$2.kind ? m$1.LINEAR : m$1.NEAREST);
					else {
						const t$1 = 1 !== o$1.layout.get("icon-size").constantOr(0) || c$2.iconsNeedLinear;
						D$1 = r$2.imageAtlasTexture, A$1 = p$2 || e$1.options.rotating || e$1.options.zooming || t$1 || M$1 ? m$1.LINEAR : m$1.NEAREST, z$1 = r$2.imageAtlasTexture.size;
					}
					const B$1 = t.aC(r$2, 1, e$1.transform.zoom), O$1 = Ie(g$1, e$1.transform, B$1), j$1 = t.L();
					t.aq(j$1, O$1);
					const N$1 = Me(v$1, g$1, e$1.transform, B$1), U$1 = t.aD(f$1, r$2, s$1, n$1), Z$1 = f$1.getProjectionData({
						overscaledTileID: l$2,
						applyGlobeMatrix: !_$1,
						applyTerrainMatrix: !0
					}), G$1 = P$1 && c$2.hasTextData(), V$1 = "none" !== o$1.layout.get("icon-text-fit") && G$1 && c$2.hasIconData();
					if (b$1) {
						const t$1 = e$1.style.map.terrain ? (t$2, i$3) => e$1.style.map.terrain.getElevation(l$2, t$2, i$3) : null, i$2 = "map" === o$1.layout.get("text-rotation-alignment");
						De(c$2, e$1, a$1, O$1, j$1, v$1, h$1, i$2, l$2.toUnwrapped(), f$1.width, f$1.height, U$1, t$1);
					}
					const $$1 = a$1 && P$1 || V$1, q$1 = b$1 || $$1 ? Yo : v$1 ? O$1 : e$1.transform.clipSpaceToPixelsMatrix, W$1 = p$2 && 0 !== o$1.paint.get(a$1 ? "text-halo-width" : "icon-halo-width").constantOr(1);
					let H$1;
					H$1 = p$2 ? c$2.iconsInText ? to(T$2.kind, E$1, x$1, v$1, b$1, $$1, e$1, q$1, N$1, U$1, z$1, k$1, I$1) : eo(T$2.kind, E$1, x$1, v$1, b$1, $$1, e$1, q$1, N$1, U$1, a$1, z$1, 0, I$1) : Ji(T$2.kind, E$1, x$1, v$1, b$1, $$1, e$1, q$1, N$1, U$1, a$1, z$1, I$1);
					const X$1 = {
						program: S$1,
						buffers: u$2,
						uniformValues: H$1,
						projectionData: Z$1,
						atlasTexture: D$1,
						atlasTextureIcon: F$1,
						atlasInterpolation: A$1,
						atlasInterpolationIcon: L$1,
						isSDF: p$2,
						hasHalo: W$1
					};
					if (y$1 && c$2.canOverlap) {
						w$1 = !0;
						const e$2 = u$2.segments.get();
						for (const i$2 of e$2) C$1.push({
							segments: new t.aM([i$2]),
							sortKey: i$2.sortKey,
							state: X$1,
							terrainData: R$1
						});
					} else C$1.push({
						segments: u$2.segments,
						sortKey: 0,
						state: X$1,
						terrainData: R$1
					});
				}
				w$1 && C$1.sort(((e$2, t$1) => e$2.sortKey - t$1.sortKey));
				for (const t$1 of C$1) {
					const i$2 = t$1.state;
					if (p$1.activeTexture.set(m$1.TEXTURE0), i$2.atlasTexture.bind(i$2.atlasInterpolation, m$1.CLAMP_TO_EDGE), i$2.atlasTextureIcon && (p$1.activeTexture.set(m$1.TEXTURE1), i$2.atlasTextureIcon && i$2.atlasTextureIcon.bind(i$2.atlasInterpolationIcon, m$1.CLAMP_TO_EDGE)), i$2.isSDF) {
						const r$2 = i$2.uniformValues;
						i$2.hasHalo && (r$2.u_is_halo = 1, or(i$2.buffers, t$1.segments, o$1, e$1, i$2.program, T$1, u$1, d$1, r$2, i$2.projectionData, t$1.terrainData)), r$2.u_is_halo = 0;
					}
					or(i$2.buffers, t$1.segments, o$1, e$1, i$2.program, T$1, u$1, d$1, i$2.uniformValues, i$2.projectionData, t$1.terrainData);
				}
			}
			function or(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1, h$1) {
				const u$1 = o$1.context;
				r$1.draw(u$1, u$1.gl.TRIANGLES, a$1, s$1, n$1, Ut.backCCW, l$1, h$1, c$1, i$1.id, e$1.layoutVertexBuffer, e$1.indexBuffer, t$1, i$1.paint, o$1.transform.zoom, e$1.programConfigurations.get(i$1.id), e$1.dynamicLayoutVertexBuffer, e$1.opacityVertexBuffer);
			}
			function rr(e$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = s$1.gl, l$1 = Vt.disabled, c$1 = new jt([n$1.ONE, n$1.ONE], t.bf.transparent, [
					!0,
					!0,
					!0,
					!0
				]), h$1 = i$1.getBucket(o$1);
				if (!h$1) return;
				const u$1 = r$1.key;
				let d$1 = o$1.heatmapFbos.get(u$1);
				d$1 || (d$1 = sr(s$1, i$1.tileSize, i$1.tileSize), o$1.heatmapFbos.set(u$1, d$1)), s$1.bindFramebuffer.set(d$1.framebuffer), s$1.viewport.set([
					0,
					0,
					i$1.tileSize,
					i$1.tileSize
				]), s$1.clear({ color: t.bf.transparent });
				const _$1 = h$1.programConfigurations.get(o$1.id), p$1 = e$1.useProgram("heatmap", _$1, !a$1), m$1 = e$1.transform.getProjectionData({
					overscaledTileID: i$1.tileID,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				}), f$1 = e$1.style.map.terrain.getTerrainData(r$1);
				p$1.draw(s$1, n$1.TRIANGLES, Zt.disabled, l$1, c$1, Ut.disabled, ji(i$1, e$1.transform.zoom, o$1.paint.get("heatmap-intensity"), 1), f$1, m$1, o$1.id, h$1.layoutVertexBuffer, h$1.indexBuffer, h$1.segments, o$1.paint, e$1.transform.zoom, _$1);
			}
			function ar(e$1, t$1, i$1, o$1, r$1) {
				const a$1 = e$1.context, s$1 = a$1.gl, n$1 = e$1.transform;
				a$1.setColorMode(e$1.colorModeForRenderPass());
				const l$1 = nr(a$1, t$1), c$1 = i$1.key, h$1 = t$1.heatmapFbos.get(c$1);
				if (!h$1) return;
				a$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, h$1.colorAttachment.get()), a$1.activeTexture.set(s$1.TEXTURE1), l$1.bind(s$1.LINEAR, s$1.CLAMP_TO_EDGE);
				const u$1 = n$1.getProjectionData({
					overscaledTileID: i$1,
					applyTerrainMatrix: r$1,
					applyGlobeMatrix: !o$1
				});
				e$1.useProgram("heatmapTexture").draw(a$1, s$1.TRIANGLES, Zt.disabled, Vt.disabled, e$1.colorModeForRenderPass(), Ut.disabled, Ni(e$1, t$1, 0, 1), null, u$1, t$1.id, e$1.rasterBoundsBuffer, e$1.quadTriangleIndexBuffer, e$1.rasterBoundsSegments, t$1.paint, n$1.zoom), h$1.destroy(), t$1.heatmapFbos.delete(c$1);
			}
			function sr(e$1, t$1, i$1) {
				var o$1, r$1;
				const a$1 = e$1.gl, s$1 = a$1.createTexture();
				a$1.bindTexture(a$1.TEXTURE_2D, s$1), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_S, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_WRAP_T, a$1.CLAMP_TO_EDGE), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MIN_FILTER, a$1.LINEAR), a$1.texParameteri(a$1.TEXTURE_2D, a$1.TEXTURE_MAG_FILTER, a$1.LINEAR);
				const n$1 = null !== (o$1 = e$1.HALF_FLOAT) && void 0 !== o$1 ? o$1 : a$1.UNSIGNED_BYTE, l$1 = null !== (r$1 = e$1.RGBA16F) && void 0 !== r$1 ? r$1 : a$1.RGBA;
				a$1.texImage2D(a$1.TEXTURE_2D, 0, l$1, t$1, i$1, 0, a$1.RGBA, n$1, null);
				const c$1 = e$1.createFramebuffer(t$1, i$1, !1, !1);
				return c$1.colorAttachment.set(s$1), c$1;
			}
			function nr(e$1, i$1) {
				return i$1.colorRampTexture || (i$1.colorRampTexture = new t.T(e$1, i$1.colorRamp, e$1.gl.RGBA)), i$1.colorRampTexture;
			}
			function lr(e$1, t$1, i$1, o$1, r$1) {
				if (!i$1 || !o$1 || !o$1.imageAtlas) return;
				const a$1 = o$1.imageAtlas.patternPositions;
				let s$1 = a$1[i$1.to.toString()], n$1 = a$1[i$1.from.toString()];
				if (!s$1 && n$1 && (s$1 = n$1), !n$1 && s$1 && (n$1 = s$1), !s$1 || !n$1) {
					const e$2 = r$1.getPaintProperty(t$1);
					s$1 = a$1[e$2], n$1 = a$1[e$2];
				}
				s$1 && n$1 && e$1.setConstantPatternPositions(s$1, n$1);
			}
			function cr(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = e$1.context.gl, h$1 = "fill-pattern", u$1 = o$1.paint.get(h$1), d$1 = u$1 && u$1.constantOr(1), _$1 = o$1.getCrossfadeParameters();
				let p$1, m$1, f$1, g$1, v$1;
				const b$1 = e$1.transform, x$1 = o$1.paint.get("fill-translate"), y$1 = o$1.paint.get("fill-translate-anchor");
				n$1 ? (m$1 = d$1 && !o$1.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p$1 = c$1.LINES) : (m$1 = d$1 ? "fillPattern" : "fill", p$1 = c$1.TRIANGLES);
				const w$1 = u$1.constantOr(null);
				for (const u$2 of r$1) {
					const r$2 = i$1.getTile(u$2);
					if (d$1 && !r$2.patternsLoaded()) continue;
					const T$1 = r$2.getBucket(o$1);
					if (!T$1) continue;
					const P$1 = T$1.programConfigurations.get(o$1.id), C$1 = e$1.useProgram(m$1, P$1), I$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(u$2);
					d$1 && (e$1.context.activeTexture.set(c$1.TEXTURE0), r$2.imageAtlasTexture.bind(c$1.LINEAR, c$1.CLAMP_TO_EDGE), P$1.updatePaintBuffers(_$1)), lr(P$1, h$1, w$1, r$2, o$1);
					const M$1 = b$1.getProjectionData({
						overscaledTileID: u$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					}), S$1 = t.aD(b$1, r$2, x$1, y$1);
					if (n$1) {
						g$1 = T$1.indexBuffer2, v$1 = T$1.segments2;
						const t$1 = [c$1.drawingBufferWidth, c$1.drawingBufferHeight];
						f$1 = "fillOutlinePattern" === m$1 && d$1 ? Li(e$1, _$1, r$2, t$1, S$1) : Ai(t$1, S$1);
					} else g$1 = T$1.indexBuffer, v$1 = T$1.segments, f$1 = d$1 ? Di(e$1, _$1, r$2, S$1) : { u_fill_translate: S$1 };
					const E$1 = e$1.stencilModeForClipping(u$2);
					C$1.draw(e$1.context, p$1, a$1, E$1, s$1, Ut.backCCW, f$1, I$1, M$1, o$1.id, T$1.layoutVertexBuffer, g$1, v$1, o$1.paint, e$1.transform.zoom, P$1);
				}
			}
			function hr(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				const c$1 = e$1.context, h$1 = c$1.gl, u$1 = "fill-extrusion-pattern", d$1 = o$1.paint.get(u$1), _$1 = d$1.constantOr(1), p$1 = o$1.getCrossfadeParameters(), m$1 = o$1.paint.get("fill-extrusion-opacity"), f$1 = d$1.constantOr(null), g$1 = e$1.transform;
				for (const d$2 of r$1) {
					const r$2 = i$1.getTile(d$2), v$1 = r$2.getBucket(o$1);
					if (!v$1) continue;
					const b$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(d$2), x$1 = v$1.programConfigurations.get(o$1.id), y$1 = e$1.useProgram(_$1 ? "fillExtrusionPattern" : "fillExtrusion", x$1);
					_$1 && (e$1.context.activeTexture.set(h$1.TEXTURE0), r$2.imageAtlasTexture.bind(h$1.LINEAR, h$1.CLAMP_TO_EDGE), x$1.updatePaintBuffers(p$1));
					const w$1 = g$1.getProjectionData({
						overscaledTileID: d$2,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					lr(x$1, u$1, f$1, r$2, o$1);
					const T$1 = t.aD(g$1, r$2, o$1.paint.get("fill-extrusion-translate"), o$1.paint.get("fill-extrusion-translate-anchor")), P$1 = o$1.paint.get("fill-extrusion-vertical-gradient"), C$1 = _$1 ? zi(e$1, P$1, m$1, T$1, d$2, p$1, r$2) : Ri(e$1, P$1, m$1, T$1);
					y$1.draw(c$1, c$1.gl.TRIANGLES, a$1, s$1, n$1, Ut.backCCW, C$1, b$1, w$1, o$1.id, v$1.layoutVertexBuffer, v$1.indexBuffer, v$1.segments, o$1.paint, e$1.transform.zoom, x$1, e$1.style.map.terrain && v$1.centroidVertexBuffer);
				}
			}
			function ur(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1) {
				var c$1;
				const h$1 = e$1.style.projection, u$1 = e$1.context, d$1 = e$1.transform, _$1 = u$1.gl, p$1 = [`#define NUM_ILLUMINATION_SOURCES ${i$1.paint.get("hillshade-highlight-color").values.length}`], m$1 = e$1.useProgram("hillshade", null, !1, p$1), f$1 = !e$1.options.moving;
				for (const p$2 of o$1) {
					const o$2 = t$1.getTile(p$2), g$1 = o$2.fbo;
					if (!g$1) continue;
					const v$1 = h$1.getMeshFromTileID(u$1, p$2.canonical, n$1, !0, "raster"), b$1 = null === (c$1 = e$1.style.map.terrain) || void 0 === c$1 ? void 0 : c$1.getTerrainData(p$2);
					u$1.activeTexture.set(_$1.TEXTURE0), _$1.bindTexture(_$1.TEXTURE_2D, g$1.colorAttachment.get());
					const x$1 = d$1.getProjectionData({
						overscaledTileID: p$2,
						aligned: f$1,
						applyGlobeMatrix: !l$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(u$1, _$1.TRIANGLES, a$1, r$1[p$2.overscaledZ], s$1, Ut.backCCW, Ui(e$1, o$2, i$1), b$1, x$1, i$1.id, v$1.vertexBuffer, v$1.indexBuffer, v$1.segments);
				}
			}
			function dr(e$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1, c$1) {
				var h$1;
				const u$1 = e$1.style.projection, d$1 = e$1.context, _$1 = e$1.transform, p$1 = d$1.gl, m$1 = e$1.useProgram("colorRelief"), f$1 = !e$1.options.moving;
				let g$1 = !0, v$1 = 0;
				for (const b$1 of r$1) {
					const r$2 = i$1.getTile(b$1), x$1 = r$2.dem;
					if (g$1) {
						const e$2 = p$1.getParameter(p$1.MAX_TEXTURE_SIZE), { elevationTexture: t$1, colorTexture: i$2 } = o$1.getColorRampTextures(d$1, e$2, x$1.getUnpackVector());
						d$1.activeTexture.set(p$1.TEXTURE1), t$1.bind(p$1.NEAREST, p$1.CLAMP_TO_EDGE), d$1.activeTexture.set(p$1.TEXTURE4), i$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE), g$1 = !1, v$1 = t$1.size[0];
					}
					if (!x$1 || !x$1.data) continue;
					const y$1 = x$1.stride, w$1 = x$1.getPixels();
					if (d$1.activeTexture.set(p$1.TEXTURE0), d$1.pixelStoreUnpackPremultiplyAlpha.set(!1), r$2.demTexture = r$2.demTexture || e$1.getTileTexture(y$1), r$2.demTexture) {
						const e$2 = r$2.demTexture;
						e$2.update(w$1, { premultiply: !1 }), e$2.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					} else r$2.demTexture = new t.T(d$1, w$1, p$1.RGBA, { premultiply: !1 }), r$2.demTexture.bind(p$1.LINEAR, p$1.CLAMP_TO_EDGE);
					const T$1 = u$1.getMeshFromTileID(d$1, b$1.canonical, l$1, !0, "raster"), P$1 = null === (h$1 = e$1.style.map.terrain) || void 0 === h$1 ? void 0 : h$1.getTerrainData(b$1), C$1 = _$1.getProjectionData({
						overscaledTileID: b$1,
						aligned: f$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					});
					m$1.draw(d$1, p$1.TRIANGLES, s$1, a$1[b$1.overscaledZ], n$1, Ut.backCCW, Vi(o$1, r$2.dem, v$1), P$1, C$1, o$1.id, T$1.vertexBuffer, T$1.indexBuffer, T$1.segments);
				}
			}
			const _r = [
				new t.P(0, 0),
				new t.P(t.$, 0),
				new t.P(t.$, t.$),
				new t.P(0, t.$)
			];
			function pr(e$1, t$1, i$1, o$1, r$1, a$1, s$1, n$1, l$1 = !1, c$1 = !1) {
				const h$1 = o$1[o$1.length - 1].overscaledZ, u$1 = e$1.context, d$1 = u$1.gl, _$1 = e$1.useProgram("raster"), p$1 = e$1.transform, m$1 = e$1.style.projection, f$1 = e$1.colorModeForRenderPass(), g$1 = !e$1.options.moving;
				for (const v$1 of o$1) {
					const o$2 = e$1.getDepthModeForSublayer(v$1.overscaledZ - h$1, 1 === i$1.paint.get("raster-opacity") ? Zt.ReadWrite : Zt.ReadOnly, d$1.LESS), b$1 = t$1.getTile(v$1);
					b$1.registerFadeDuration(i$1.paint.get("raster-fade-duration"));
					const x$1 = t$1.findLoadedParent(v$1, 0), y$1 = t$1.findLoadedSibling(v$1), w$1 = mr(b$1, x$1 || y$1 || null, t$1, i$1, e$1.transform, e$1.style.map.terrain);
					let T$1, P$1;
					const C$1 = "nearest" === i$1.paint.get("raster-resampling") ? d$1.NEAREST : d$1.LINEAR;
					u$1.activeTexture.set(d$1.TEXTURE0), b$1.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), u$1.activeTexture.set(d$1.TEXTURE1), x$1 ? (x$1.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), T$1 = Math.pow(2, x$1.tileID.overscaledZ - b$1.tileID.overscaledZ), P$1 = [b$1.tileID.canonical.x * T$1 % 1, b$1.tileID.canonical.y * T$1 % 1]) : b$1.texture.bind(C$1, d$1.CLAMP_TO_EDGE, d$1.LINEAR_MIPMAP_NEAREST), b$1.texture.useMipmap && u$1.extTextureFilterAnisotropic && e$1.transform.pitch > 20 && d$1.texParameterf(d$1.TEXTURE_2D, u$1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u$1.extTextureFilterAnisotropicMax);
					const I$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(v$1), M$1 = p$1.getProjectionData({
						overscaledTileID: v$1,
						aligned: g$1,
						applyGlobeMatrix: !c$1,
						applyTerrainMatrix: !0
					}), S$1 = Yi(P$1 || [0, 0], T$1 || 1, w$1, i$1, n$1), E$1 = m$1.getMeshFromTileID(u$1, v$1.canonical, a$1, s$1, "raster");
					_$1.draw(u$1, d$1.TRIANGLES, o$2, r$1 ? r$1[v$1.overscaledZ] : Vt.disabled, f$1, l$1 ? Ut.frontCCW : Ut.backCCW, S$1, I$1, M$1, i$1.id, E$1.vertexBuffer, E$1.indexBuffer, E$1.segments);
				}
			}
			function mr(e$1, i$1, o$1, r$1, a$1, n$1) {
				const l$1 = r$1.paint.get("raster-fade-duration");
				if (!n$1 && l$1 > 0) {
					const r$2 = s.now(), n$2 = (r$2 - e$1.timeAdded) / l$1, c$1 = i$1 ? (r$2 - i$1.timeAdded) / l$1 : -1, h$1 = o$1.getSource(), u$1 = ge(a$1, {
						tileSize: h$1.tileSize,
						roundZoom: h$1.roundZoom
					}), d$1 = !i$1 || Math.abs(i$1.tileID.overscaledZ - u$1) > Math.abs(e$1.tileID.overscaledZ - u$1), _$1 = d$1 && e$1.refreshedUponExpiration ? 1 : t.ah(d$1 ? n$2 : 1 - c$1, 0, 1);
					return e$1.refreshedUponExpiration && n$2 >= 1 && (e$1.refreshedUponExpiration = !1), i$1 ? {
						opacity: 1,
						mix: 1 - _$1
					} : {
						opacity: _$1,
						mix: 0
					};
				}
				return {
					opacity: 1,
					mix: 0
				};
			}
			const fr = new t.bf(1, 0, 0, 1), gr = new t.bf(0, 1, 0, 1), vr = new t.bf(0, 0, 1, 1), br = new t.bf(1, 0, 1, 1), xr = new t.bf(0, 1, 1, 1);
			function yr(e$1, t$1, i$1, o$1) {
				Tr(e$1, 0, t$1 + i$1 / 2, e$1.transform.width, i$1, o$1);
			}
			function wr(e$1, t$1, i$1, o$1) {
				Tr(e$1, t$1 - i$1 / 2, 0, i$1, e$1.transform.height, o$1);
			}
			function Tr(e$1, t$1, i$1, o$1, r$1, a$1) {
				const s$1 = e$1.context, n$1 = s$1.gl;
				n$1.enable(n$1.SCISSOR_TEST), n$1.scissor(t$1 * e$1.pixelRatio, i$1 * e$1.pixelRatio, o$1 * e$1.pixelRatio, r$1 * e$1.pixelRatio), s$1.clear({ color: a$1 }), n$1.disable(n$1.SCISSOR_TEST);
			}
			function Pr(e$1, i$1, o$1) {
				const r$1 = e$1.context, a$1 = r$1.gl, s$1 = e$1.useProgram("debug"), n$1 = Zt.disabled, l$1 = Vt.disabled, c$1 = e$1.colorModeForRenderPass(), h$1 = "$debug", u$1 = e$1.style.map.terrain && e$1.style.map.terrain.getTerrainData(o$1);
				r$1.activeTexture.set(a$1.TEXTURE0);
				const d$1 = i$1.getTileByID(o$1.key).latestRawTileData, _$1 = Math.floor((d$1 && d$1.byteLength || 0) / 1024), p$1 = i$1.getTile(o$1).tileSize, m$1 = 512 / Math.min(p$1, 512) * (o$1.overscaledZ / e$1.transform.zoom) * .5;
				let f$1 = o$1.canonical.toString();
				o$1.overscaledZ !== o$1.canonical.z && (f$1 += ` => ${o$1.overscaledZ}`), function(e$2, t$1) {
					e$2.initDebugOverlayCanvas();
					const i$2 = e$2.debugOverlayCanvas, o$2 = e$2.context.gl, r$2 = e$2.debugOverlayCanvas.getContext("2d");
					r$2.clearRect(0, 0, i$2.width, i$2.height), r$2.shadowColor = "white", r$2.shadowBlur = 2, r$2.lineWidth = 1.5, r$2.strokeStyle = "white", r$2.textBaseline = "top", r$2.font = "bold 36px Open Sans, sans-serif", r$2.fillText(t$1, 5, 5), r$2.strokeText(t$1, 5, 5), e$2.debugOverlayTexture.update(i$2), e$2.debugOverlayTexture.bind(o$2.LINEAR, o$2.CLAMP_TO_EDGE);
				}(e$1, `${f$1} ${_$1}kB`);
				const g$1 = e$1.transform.getProjectionData({
					overscaledTileID: o$1,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				});
				s$1.draw(r$1, a$1.TRIANGLES, n$1, l$1, jt.alphaBlended, Ut.disabled, Oi(t.bf.transparent, m$1), null, g$1, h$1, e$1.debugBuffer, e$1.quadTriangleIndexBuffer, e$1.debugSegments), s$1.draw(r$1, a$1.LINE_STRIP, n$1, l$1, c$1, Ut.disabled, Oi(t.bf.red), u$1, g$1, h$1, e$1.debugBuffer, e$1.tileBorderIndexBuffer, e$1.debugSegments);
			}
			function Cr(e$1, t$1, i$1, o$1) {
				const { isRenderingGlobe: r$1 } = o$1, a$1 = e$1.context, s$1 = a$1.gl, n$1 = e$1.transform, l$1 = e$1.colorModeForRenderPass(), c$1 = e$1.getDepthModeFor3D(), h$1 = e$1.useProgram("terrain");
				a$1.bindFramebuffer.set(null), a$1.viewport.set([
					0,
					0,
					e$1.width,
					e$1.height
				]);
				for (const o$2 of i$1) {
					const i$2 = t$1.getTerrainMesh(o$2.tileID), u$1 = e$1.renderToTexture.getTexture(o$2), d$1 = t$1.getTerrainData(o$2.tileID);
					a$1.activeTexture.set(s$1.TEXTURE0), s$1.bindTexture(s$1.TEXTURE_2D, u$1.texture);
					const _$1 = t$1.getMeshFrameDelta(n$1.zoom), p$1 = n$1.calculateFogMatrix(o$2.tileID.toUnwrapped()), m$1 = Ci(_$1, p$1, e$1.style.sky, n$1.pitch, r$1), f$1 = n$1.getProjectionData({
						overscaledTileID: o$2.tileID,
						applyTerrainMatrix: !1,
						applyGlobeMatrix: !0
					});
					h$1.draw(a$1, s$1.TRIANGLES, c$1, Vt.disabled, l$1, Ut.backCCW, m$1, d$1, f$1, "terrain", i$2.vertexBuffer, i$2.indexBuffer, i$2.segments);
				}
			}
			function Ir(e$1, i$1) {
				if (!i$1.mesh) {
					const o$1 = new t.aL();
					o$1.emplaceBack(-1, -1), o$1.emplaceBack(1, -1), o$1.emplaceBack(1, 1), o$1.emplaceBack(-1, 1);
					const r$1 = new t.aN();
					r$1.emplaceBack(0, 1, 2), r$1.emplaceBack(0, 2, 3), i$1.mesh = new wt(e$1.createVertexBuffer(o$1, Tt.members), e$1.createIndexBuffer(r$1), t.aM.simpleSegment(0, 0, o$1.length, r$1.length));
				}
				return i$1.mesh;
			}
			class Mr {
				constructor(e$1, i$1) {
					this.context = new Ho(e$1), this.transform = i$1, this._tileTextures = {}, this.terrainFacilitator = {
						dirty: !0,
						matrix: t.ag(new Float64Array(16)),
						renderTime: 0
					}, this.setup(), this.numSublayers = xe.maxUnderzooming + xe.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vt();
				}
				resize(e$1, t$1, i$1) {
					if (this.width = Math.floor(e$1 * i$1), this.height = Math.floor(t$1 * i$1), this.pixelRatio = i$1, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (const e$2 of this.style._order) this.style._layers[e$2].resize();
				}
				setup() {
					const e$1 = this.context, i$1 = new t.aL();
					i$1.emplaceBack(0, 0), i$1.emplaceBack(t.$, 0), i$1.emplaceBack(0, t.$), i$1.emplaceBack(t.$, t.$), this.tileExtentBuffer = e$1.createVertexBuffer(i$1, Tt.members), this.tileExtentSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const o$1 = new t.aL();
					o$1.emplaceBack(0, 0), o$1.emplaceBack(t.$, 0), o$1.emplaceBack(0, t.$), o$1.emplaceBack(t.$, t.$), this.debugBuffer = e$1.createVertexBuffer(o$1, Tt.members), this.debugSegments = t.aM.simpleSegment(0, 0, 4, 5);
					const r$1 = new t.c6();
					r$1.emplaceBack(0, 0, 0, 0), r$1.emplaceBack(t.$, 0, t.$, 0), r$1.emplaceBack(0, t.$, 0, t.$), r$1.emplaceBack(t.$, t.$, t.$, t.$), this.rasterBoundsBuffer = e$1.createVertexBuffer(r$1, Ti.members), this.rasterBoundsSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const a$1 = new t.aL();
					a$1.emplaceBack(0, 0), a$1.emplaceBack(t.$, 0), a$1.emplaceBack(0, t.$), a$1.emplaceBack(t.$, t.$), this.rasterBoundsBufferPosOnly = e$1.createVertexBuffer(a$1, Tt.members), this.rasterBoundsSegmentsPosOnly = t.aM.simpleSegment(0, 0, 4, 5);
					const s$1 = new t.aL();
					s$1.emplaceBack(0, 0), s$1.emplaceBack(1, 0), s$1.emplaceBack(0, 1), s$1.emplaceBack(1, 1), this.viewportBuffer = e$1.createVertexBuffer(s$1, Tt.members), this.viewportSegments = t.aM.simpleSegment(0, 0, 4, 2);
					const n$1 = new t.c7();
					n$1.emplaceBack(0), n$1.emplaceBack(1), n$1.emplaceBack(3), n$1.emplaceBack(2), n$1.emplaceBack(0), this.tileBorderIndexBuffer = e$1.createIndexBuffer(n$1);
					const l$1 = new t.aN();
					l$1.emplaceBack(1, 0, 2), l$1.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e$1.createIndexBuffer(l$1);
					const c$1 = this.context.gl;
					this.stencilClearMode = new Vt({
						func: c$1.ALWAYS,
						mask: 0
					}, 0, 255, c$1.ZERO, c$1.ZERO, c$1.ZERO), this.tileExtentMesh = new wt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
				}
				clearStencil() {
					const e$1 = this.context, i$1 = e$1.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0;
					const o$1 = t.L();
					t.bY(o$1, 0, this.width, this.height, 0, 0, 1), t.N(o$1, o$1, [
						i$1.drawingBufferWidth,
						i$1.drawingBufferHeight,
						0
					]);
					const r$1 = {
						mainMatrix: o$1,
						tileMercatorCoords: [
							0,
							0,
							1,
							1
						],
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: o$1
					};
					this.useProgram("clippingMask", null, !0).draw(e$1, i$1.TRIANGLES, Zt.disabled, this.stencilClearMode, jt.disabled, Ut.disabled, null, null, r$1, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				_renderTileClippingMasks(e$1, t$1, i$1) {
					if (this.currentStencilSource === e$1.source || !e$1.isTileClipped() || !t$1 || !t$1.length) return;
					this.currentStencilSource = e$1.source, this.nextStencilID + t$1.length > 256 && this.clearStencil();
					const o$1 = this.context;
					o$1.setColorMode(jt.disabled), o$1.setDepthMode(Zt.disabled);
					const r$1 = {};
					for (const e$2 of t$1) r$1[e$2.key] = this.nextStencilID++;
					this._renderTileMasks(r$1, t$1, i$1, !0), this._renderTileMasks(r$1, t$1, i$1, !1), this._tileClippingMaskIDs = r$1;
				}
				_renderTileMasks(e$1, t$1, i$1, o$1) {
					const r$1 = this.context, a$1 = r$1.gl, s$1 = this.style.projection, n$1 = this.transform, l$1 = this.useProgram("clippingMask");
					for (const c$1 of t$1) {
						const t$2 = e$1[c$1.key], h$1 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c$1), u$1 = s$1.getMeshFromTileID(this.context, c$1.canonical, o$1, !0, "stencil"), d$1 = n$1.getProjectionData({
							overscaledTileID: c$1,
							applyGlobeMatrix: !i$1,
							applyTerrainMatrix: !0
						});
						l$1.draw(r$1, a$1.TRIANGLES, Zt.disabled, new Vt({
							func: a$1.ALWAYS,
							mask: 0
						}, t$2, 255, a$1.KEEP, a$1.KEEP, a$1.REPLACE), jt.disabled, i$1 ? Ut.disabled : Ut.backCCW, null, h$1, d$1, "$clipping", u$1.vertexBuffer, u$1.indexBuffer, u$1.segments);
					}
				}
				_renderTilesDepthBuffer() {
					const e$1 = this.context, t$1 = e$1.gl, i$1 = this.style.projection, o$1 = this.transform, r$1 = this.useProgram("depth"), a$1 = this.getDepthModeFor3D(), s$1 = ve(o$1, { tileSize: o$1.tileSize });
					for (const n$1 of s$1) {
						const s$2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n$1), l$1 = i$1.getMeshFromTileID(this.context, n$1.canonical, !0, !0, "raster"), c$1 = o$1.getProjectionData({
							overscaledTileID: n$1,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						});
						r$1.draw(e$1, t$1.TRIANGLES, a$1, Vt.disabled, jt.disabled, Ut.backCCW, null, s$2, c$1, "$clipping", l$1.vertexBuffer, l$1.indexBuffer, l$1.segments);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					const e$1 = this.nextStencilID++, t$1 = this.context.gl;
					return new Vt({
						func: t$1.NOTEQUAL,
						mask: 255
					}, e$1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				stencilModeForClipping(e$1) {
					const t$1 = this.context.gl;
					return new Vt({
						func: t$1.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e$1.key], 0, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
				}
				getStencilConfigForOverlapAndUpdateStencilID(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), o$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - o$1 + 1;
					if (r$1 > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + r$1 > 256 && this.clearStencil();
						const e$2 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + o$1] = new Vt({
							func: t$1.GEQUAL,
							mask: 255
						}, i$2 + this.nextStencilID, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID += r$1, [e$2, i$1];
					}
					return [{ [o$1]: Vt.disabled }, i$1];
				}
				stencilConfigForOverlapTwoPass(e$1) {
					const t$1 = this.context.gl, i$1 = e$1.sort(((e$2, t$2) => t$2.overscaledZ - e$2.overscaledZ)), o$1 = i$1[i$1.length - 1].overscaledZ, r$1 = i$1[0].overscaledZ - o$1 + 1;
					if (this.clearStencil(), r$1 > 1) {
						const e$2 = {}, a$1 = {};
						for (let i$2 = 0; i$2 < r$1; i$2++) e$2[i$2 + o$1] = new Vt({
							func: t$1.GREATER,
							mask: 255
						}, r$1 + 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE), a$1[i$2 + o$1] = new Vt({
							func: t$1.GREATER,
							mask: 255
						}, 1 + i$2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE);
						return this.nextStencilID = 2 * r$1 + 1, [
							e$2,
							a$1,
							i$1
						];
					}
					return this.nextStencilID = 3, [
						{ [o$1]: new Vt({
							func: t$1.GREATER,
							mask: 255
						}, 2, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						{ [o$1]: new Vt({
							func: t$1.GREATER,
							mask: 255
						}, 1, 255, t$1.KEEP, t$1.KEEP, t$1.REPLACE) },
						i$1
					];
				}
				colorModeForRenderPass() {
					const e$1 = this.context.gl;
					if (this._showOverdrawInspector) {
						const i$1 = 1 / 8;
						return new jt([e$1.CONSTANT_COLOR, e$1.ONE], new t.bf(i$1, i$1, i$1, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return "opaque" === this.renderPass ? jt.unblended : jt.alphaBlended;
				}
				getDepthModeForSublayer(e$1, t$1, i$1) {
					if (!this.opaquePassEnabledForLayer()) return Zt.disabled;
					const o$1 = 1 - ((1 + this.currentLayer) * this.numSublayers + e$1) * this.depthEpsilon;
					return new Zt(i$1 || this.context.gl.LEQUAL, t$1, [o$1, o$1]);
				}
				getDepthModeFor3D() {
					return new Zt(this.context.gl.LEQUAL, Zt.ReadWrite, this.depthRangeFor3D);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				render(e$1, i$1) {
					var o$1, r$1;
					this.style = e$1, this.options = i$1, this.lineAtlas = e$1.lineAtlas, this.imageManager = e$1.imageManager, this.glyphManager = e$1.glyphManager, this.symbolFadeChange = e$1.placement.symbolFadeChange(s.now()), this.imageManager.beginFrame();
					const a$1 = this.style._order, n$1 = this.style.sourceCaches, l$1 = {}, c$1 = {}, h$1 = {}, u$1 = {
						isRenderingToTexture: !1,
						isRenderingGlobe: (null === (o$1 = e$1.projection) || void 0 === o$1 ? void 0 : o$1.transitionState) > 0
					};
					for (const e$2 in n$1) {
						const t$1 = n$1[e$2];
						t$1.used && t$1.prepare(this.context), l$1[e$2] = t$1.getVisibleCoordinates(!1), c$1[e$2] = l$1[e$2].slice().reverse(), h$1[e$2] = t$1.getVisibleCoordinates(!0).reverse();
					}
					this.opaquePassCutoff = Infinity;
					for (let e$2 = 0; e$2 < a$1.length; e$2++) if (this.style._layers[a$1[e$2]].is3D()) {
						this.opaquePassCutoff = e$2;
						break;
					}
					this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
					for (const e$2 of a$1) {
						const t$1 = this.style._layers[e$2];
						if (!t$1.hasOffscreenPass() || t$1.isHidden(this.transform.zoom)) continue;
						const i$2 = c$1[t$1.source];
						("custom" === t$1.type || i$2.length) && this.renderLayer(this, n$1[t$1.source], t$1, i$2, u$1);
					}
					if (null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.updateGPUdependent({
						context: this.context,
						useProgram: (e$2) => this.useProgram(e$2)
					}), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.bindFramebuffer.set(null), this.context.clear({
						color: i$1.showOverdrawInspector ? t.bf.black : t.bf.transparent,
						depth: 1
					}), this.clearStencil(), this.style.sky && function(e$2, t$1) {
						const i$2 = e$2.context, o$2 = i$2.gl, r$2 = ((e$3, t$2, i$3) => {
							const o$3 = Math.cos(t$2.rollInRadians), r$3 = Math.sin(t$2.rollInRadians), a$3 = he(t$2), s$2 = t$2.getProjectionData({
								overscaledTileID: null,
								applyGlobeMatrix: !0,
								applyTerrainMatrix: !0
							}).projectionTransition;
							return {
								u_sky_color: e$3.properties.get("sky-color"),
								u_horizon_color: e$3.properties.get("horizon-color"),
								u_horizon: [(t$2.width / 2 - a$3 * r$3) * i$3, (t$2.height / 2 + a$3 * o$3) * i$3],
								u_horizon_normal: [-r$3, o$3],
								u_sky_horizon_blend: e$3.properties.get("sky-horizon-blend") * t$2.height / 2 * i$3,
								u_sky_blend: s$2
							};
						})(t$1, e$2.style.map.transform, e$2.pixelRatio), a$2 = new Zt(o$2.LEQUAL, Zt.ReadWrite, [0, 1]), s$1 = Vt.disabled, n$2 = e$2.colorModeForRenderPass(), l$2 = e$2.useProgram("sky"), c$2 = Ir(i$2, t$1);
						l$2.draw(i$2, o$2.TRIANGLES, a$2, s$1, n$2, Ut.disabled, r$2, null, void 0, "sky", c$2.vertexBuffer, c$2.indexBuffer, c$2.segments);
					}(this, this.style.sky), this._showOverdrawInspector = i$1.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e$1._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a$1.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						const e$2 = this.style._layers[a$1[this.currentLayer]], t$1 = n$1[e$2.source], i$2 = l$1[e$2.source];
						this._renderTileClippingMasks(e$2, i$2, !1), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					this.renderPass = "translucent";
					let d$1 = !1;
					for (this.currentLayer = 0; this.currentLayer < a$1.length; this.currentLayer++) {
						const e$2 = this.style._layers[a$1[this.currentLayer]], t$1 = n$1[e$2.source];
						if (this.renderToTexture && this.renderToTexture.renderLayer(e$2, u$1)) continue;
						this.opaquePassEnabledForLayer() || d$1 || (d$1 = !0, u$1.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
						const i$2 = ("symbol" === e$2.type ? h$1 : c$1)[e$2.source];
						this._renderTileClippingMasks(e$2, l$1[e$2.source], !!this.renderToTexture), this.renderLayer(this, t$1, e$2, i$2, u$1);
					}
					if (u$1.isRenderingGlobe && function(e$2, i$2, o$2) {
						const r$2 = e$2.context, a$2 = r$2.gl, s$1 = e$2.useProgram("atmosphere"), n$2 = new Zt(a$2.LEQUAL, Zt.ReadOnly, [0, 1]), l$2 = e$2.transform, c$2 = function(e$3, i$3) {
							const o$3 = e$3.properties.get("position"), r$3 = [
								-o$3.x,
								-o$3.y,
								-o$3.z
							], a$3 = t.ag(new Float64Array(16));
							return "map" === e$3.properties.get("anchor") && (t.b6(a$3, a$3, i$3.rollInRadians), t.b7(a$3, a$3, -i$3.pitchInRadians), t.b6(a$3, a$3, i$3.bearingInRadians), t.b7(a$3, a$3, i$3.center.lat * Math.PI / 180), t.bz(a$3, a$3, -i$3.center.lng * Math.PI / 180)), t.c5(r$3, r$3, a$3), r$3;
						}(o$2, e$2.transform), h$2 = l$2.getProjectionData({
							overscaledTileID: null,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						}), u$2 = i$2.properties.get("atmosphere-blend") * h$2.projectionTransition;
						if (0 === u$2) return;
						const d$2 = oi(l$2.worldSize, l$2.center.lat), _$1 = l$2.inverseProjectionMatrix, p$1 = new Float64Array(4);
						p$1[3] = 1, t.aw(p$1, p$1, l$2.modelViewProjectionMatrix), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1, t.aw(p$1, p$1, _$1), p$1[0] /= p$1[3], p$1[1] /= p$1[3], p$1[2] /= p$1[3], p$1[3] = 1;
						const m$1 = ((e$3, t$1, i$3, o$3, r$3) => ({
							u_sun_pos: e$3,
							u_atmosphere_blend: t$1,
							u_globe_position: i$3,
							u_globe_radius: o$3,
							u_inv_proj_matrix: r$3
						}))(c$2, u$2, [
							p$1[0],
							p$1[1],
							p$1[2]
						], d$2, _$1), f$1 = Ir(r$2, i$2);
						s$1.draw(r$2, a$2.TRIANGLES, n$2, Vt.disabled, jt.alphaBlended, Ut.disabled, m$1, null, null, "atmosphere", f$1.vertexBuffer, f$1.indexBuffer, f$1.segments);
					}(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
						const e$2 = function(e$3, t$1) {
							let i$2 = null;
							const o$2 = Object.values(e$3._layers).flatMap(((i$3) => i$3.source && !i$3.isHidden(t$1) ? [e$3.sourceCaches[i$3.source]] : [])), r$2 = o$2.filter(((e$4) => "vector" === e$4.getSource().type)), a$2 = o$2.filter(((e$4) => "vector" !== e$4.getSource().type)), s$1 = (e$4) => {
								(!i$2 || i$2.getSource().maxzoom < e$4.getSource().maxzoom) && (i$2 = e$4);
							};
							return r$2.forEach(((e$4) => s$1(e$4))), i$2 || a$2.forEach(((e$4) => s$1(e$4))), i$2;
						}(this.style, this.transform.zoom);
						e$2 && function(e$3, t$1, i$2) {
							for (let o$2 = 0; o$2 < i$2.length; o$2++) Pr(e$3, t$1, i$2[o$2]);
						}(this, e$2, e$2.getVisibleCoordinates());
					}
					this.options.showPadding && function(e$2) {
						const t$1 = e$2.transform.padding;
						yr(e$2, e$2.transform.height - (t$1.top || 0), 3, fr), yr(e$2, t$1.bottom || 0, 3, gr), wr(e$2, t$1.left || 0, 3, vr), wr(e$2, e$2.transform.width - (t$1.right || 0), 3, br);
						const i$2 = e$2.transform.centerPoint;
						(function(e$3, t$2, i$3, o$2) {
							Tr(e$3, t$2 - 1, i$3 - 10, 2, 20, o$2), Tr(e$3, t$2 - 10, i$3 - 1, 20, 2, o$2);
						})(e$2, i$2.x, e$2.transform.height - i$2.y, xr);
					}(this), this.context.setDefault();
				}
				maybeDrawDepthAndCoords(e$1) {
					if (!this.style || !this.style.map || !this.style.map.terrain) return;
					const i$1 = this.terrainFacilitator.matrix, o$1 = this.transform.modelViewProjectionMatrix;
					let r$1 = this.terrainFacilitator.dirty;
					r$1 || (r$1 = e$1 ? !t.c8(i$1, o$1) : !t.c9(i$1, o$1)), r$1 || (r$1 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), r$1 && (t.ca(i$1, o$1), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e$2, i$2) {
						const o$2 = e$2.context, r$2 = o$2.gl, a$1 = e$2.transform, s$1 = jt.unblended, n$1 = new Zt(r$2.LEQUAL, Zt.ReadWrite, [0, 1]), l$1 = i$2.sourceCache.getRenderableTiles(), c$1 = e$2.useProgram("terrainDepth");
						o$2.bindFramebuffer.set(i$2.getFramebuffer("depth").framebuffer), o$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), o$2.clear({
							color: t.bf.transparent,
							depth: 1
						});
						for (const e$3 of l$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), l$2 = i$2.getTerrainData(e$3.tileID), h$1 = a$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							}), u$1 = { u_ele_delta: i$2.getMeshFrameDelta(a$1.zoom) };
							c$1.draw(o$2, r$2.TRIANGLES, n$1, Vt.disabled, s$1, Ut.backCCW, u$1, l$2, h$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments);
						}
						o$2.bindFramebuffer.set(null), o$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain), function(e$2, i$2) {
						const o$2 = e$2.context, r$2 = o$2.gl, a$1 = e$2.transform, s$1 = jt.unblended, n$1 = new Zt(r$2.LEQUAL, Zt.ReadWrite, [0, 1]), l$1 = i$2.getCoordsTexture(), c$1 = i$2.sourceCache.getRenderableTiles(), h$1 = e$2.useProgram("terrainCoords");
						o$2.bindFramebuffer.set(i$2.getFramebuffer("coords").framebuffer), o$2.viewport.set([
							0,
							0,
							e$2.width / devicePixelRatio,
							e$2.height / devicePixelRatio
						]), o$2.clear({
							color: t.bf.transparent,
							depth: 1
						}), i$2.coordsIndex = [];
						for (const e$3 of c$1) {
							const t$1 = i$2.getTerrainMesh(e$3.tileID), c$2 = i$2.getTerrainData(e$3.tileID);
							o$2.activeTexture.set(r$2.TEXTURE0), r$2.bindTexture(r$2.TEXTURE_2D, l$1.texture);
							const u$1 = {
								u_terrain_coords_id: (255 - i$2.coordsIndex.length) / 255,
								u_texture: 0,
								u_ele_delta: i$2.getMeshFrameDelta(a$1.zoom)
							}, d$1 = a$1.getProjectionData({
								overscaledTileID: e$3.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							});
							h$1.draw(o$2, r$2.TRIANGLES, n$1, Vt.disabled, s$1, Ut.backCCW, u$1, c$2, d$1, "terrain", t$1.vertexBuffer, t$1.indexBuffer, t$1.segments), i$2.coordsIndex.push(e$3.tileID.key);
						}
						o$2.bindFramebuffer.set(null), o$2.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
					}(this, this.style.map.terrain));
				}
				renderLayer(e$1, i$1, o$1, r$1, a$1) {
					o$1.isHidden(this.transform.zoom) || ("background" === o$1.type || "custom" === o$1.type || (r$1 || []).length) && (this.id = o$1.id, t.cb(o$1) ? function(e$2, i$2, o$2, r$2, a$2, s$1) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: n$1 } = s$1, l$1 = Vt.disabled, c$1 = e$2.colorModeForRenderPass();
						(o$2._unevaluatedLayout.hasValue("text-variable-anchor") || o$2._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e$3, i$3, o$3, r$3, a$3, s$2, n$2, l$2, c$2) {
							const h$1 = i$3.transform, u$1 = i$3.style.map.terrain, d$1 = "map" === a$3, _$1 = "map" === s$2;
							for (const a$4 of e$3) {
								const e$4 = r$3.getTile(a$4), s$3 = e$4.getBucket(o$3);
								if (!s$3 || !s$3.text || !s$3.text.segments.get().length) continue;
								const p$1 = t.an(s$3.textSizeData, h$1.zoom), m$1 = t.aC(e$4, 1, i$3.transform.zoom), f$1 = Ie(d$1, i$3.transform, m$1), g$1 = "none" !== o$3.layout.get("icon-text-fit") && s$3.hasIconData();
								if (p$1) {
									const i$4 = Math.pow(2, h$1.zoom - e$4.tileID.overscaledZ), o$4 = u$1 ? (e$5, t$1) => u$1.getElevation(a$4, e$5, t$1) : null;
									er(s$3, d$1, _$1, c$2, h$1, f$1, i$4, p$1, g$1, t.aD(h$1, e$4, n$2, l$2), a$4.toUnwrapped(), o$4);
								}
							}
						}(r$2, e$2, o$2, i$2, o$2.layout.get("text-rotation-alignment"), o$2.layout.get("text-pitch-alignment"), o$2.paint.get("text-translate"), o$2.paint.get("text-translate-anchor"), a$2), 0 !== o$2.paint.get("icon-opacity").constantOr(1) && ir(e$2, i$2, o$2, r$2, !1, o$2.paint.get("icon-translate"), o$2.paint.get("icon-translate-anchor"), o$2.layout.get("icon-rotation-alignment"), o$2.layout.get("icon-pitch-alignment"), o$2.layout.get("icon-keep-upright"), l$1, c$1, n$1), 0 !== o$2.paint.get("text-opacity").constantOr(1) && ir(e$2, i$2, o$2, r$2, !0, o$2.paint.get("text-translate"), o$2.paint.get("text-translate-anchor"), o$2.layout.get("text-rotation-alignment"), o$2.layout.get("text-pitch-alignment"), o$2.layout.get("text-keep-upright"), l$1, c$1, n$1), i$2.map.showCollisionBoxes && (Ko(e$2, i$2, o$2, r$2, !0), Ko(e$2, i$2, o$2, r$2, !1));
					}(e$1, i$1, o$1, r$1, this.style.placement.variableOffsets, a$1) : t.cc(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = o$2.paint.get("circle-opacity"), l$1 = o$2.paint.get("circle-stroke-width"), c$1 = o$2.paint.get("circle-stroke-opacity"), h$1 = !o$2.layout.get("circle-sort-key").isConstant();
						if (0 === n$1.constantOr(1) && (0 === l$1.constantOr(1) || 0 === c$1.constantOr(1))) return;
						const u$1 = e$2.context, d$1 = u$1.gl, _$1 = e$2.transform, p$1 = e$2.getDepthModeForSublayer(0, Zt.ReadOnly), m$1 = Vt.disabled, f$1 = e$2.colorModeForRenderPass(), g$1 = [], v$1 = _$1.getCircleRadiusCorrection();
						for (let a$3 = 0; a$3 < r$2.length; a$3++) {
							const n$2 = r$2[a$3], l$2 = i$2.getTile(n$2), c$2 = l$2.getBucket(o$2);
							if (!c$2) continue;
							const u$2 = o$2.paint.get("circle-translate"), d$2 = o$2.paint.get("circle-translate-anchor"), p$2 = t.aD(_$1, l$2, u$2, d$2), m$2 = c$2.programConfigurations.get(o$2.id), f$2 = e$2.useProgram("circle", m$2), b$1 = c$2.layoutVertexBuffer, x$1 = c$2.indexBuffer, y$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(n$2), w$1 = {
								programConfiguration: m$2,
								program: f$2,
								layoutVertexBuffer: b$1,
								indexBuffer: x$1,
								uniformValues: ki(e$2, l$2, o$2, p$2, v$1),
								terrainData: y$1,
								projectionData: _$1.getProjectionData({
									overscaledTileID: n$2,
									applyGlobeMatrix: !s$1,
									applyTerrainMatrix: !0
								})
							};
							if (h$1) {
								const e$3 = c$2.segments.get();
								for (const i$3 of e$3) g$1.push({
									segments: new t.aM([i$3]),
									sortKey: i$3.sortKey,
									state: w$1
								});
							} else g$1.push({
								segments: c$2.segments,
								sortKey: 0,
								state: w$1
							});
						}
						h$1 && g$1.sort(((e$3, t$1) => e$3.sortKey - t$1.sortKey));
						for (const t$1 of g$1) {
							const { programConfiguration: i$3, program: r$3, layoutVertexBuffer: a$3, indexBuffer: s$2, uniformValues: n$2, terrainData: l$2, projectionData: c$2 } = t$1.state;
							r$3.draw(u$1, d$1.TRIANGLES, p$1, m$1, f$1, Ut.backCCW, n$2, l$2, c$2, o$2.id, a$3, s$2, t$1.segments, o$2.paint, e$2.transform.zoom, i$3);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cd(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if (0 === o$2.paint.get("heatmap-opacity")) return;
						const s$1 = e$2.context, { isRenderingToTexture: n$1, isRenderingGlobe: l$1 } = a$2;
						if (e$2.style.map.terrain) {
							for (const t$1 of r$2) {
								const r$3 = i$2.getTile(t$1);
								i$2.hasRenderableParent(t$1) || ("offscreen" === e$2.renderPass ? rr(e$2, r$3, o$2, t$1, l$1) : "translucent" === e$2.renderPass && ar(e$2, o$2, t$1, n$1, l$1));
							}
							s$1.viewport.set([
								0,
								0,
								e$2.width,
								e$2.height
							]);
						} else "offscreen" === e$2.renderPass ? function(e$3, i$3, o$3, r$3) {
							const a$3 = e$3.context, s$2 = a$3.gl, n$2 = e$3.transform, l$2 = Vt.disabled, c$1 = new jt([s$2.ONE, s$2.ONE], t.bf.transparent, [
								!0,
								!0,
								!0,
								!0
							]);
							(function(e$4, i$4, o$4) {
								const r$4 = e$4.gl;
								e$4.activeTexture.set(r$4.TEXTURE1), e$4.viewport.set([
									0,
									0,
									i$4.width / 4,
									i$4.height / 4
								]);
								let a$4 = o$4.heatmapFbos.get(t.c2);
								a$4 ? (r$4.bindTexture(r$4.TEXTURE_2D, a$4.colorAttachment.get()), e$4.bindFramebuffer.set(a$4.framebuffer)) : (a$4 = sr(e$4, i$4.width / 4, i$4.height / 4), o$4.heatmapFbos.set(t.c2, a$4));
							})(a$3, e$3, o$3), a$3.clear({ color: t.bf.transparent });
							for (let t$1 = 0; t$1 < r$3.length; t$1++) {
								const h$1 = r$3[t$1];
								if (i$3.hasRenderableParent(h$1)) continue;
								const u$1 = i$3.getTile(h$1), d$1 = u$1.getBucket(o$3);
								if (!d$1) continue;
								const _$1 = d$1.programConfigurations.get(o$3.id), p$1 = e$3.useProgram("heatmap", _$1), m$1 = n$2.getProjectionData({
									overscaledTileID: h$1,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !1
								}), f$1 = n$2.getCircleRadiusCorrection();
								p$1.draw(a$3, s$2.TRIANGLES, Zt.disabled, l$2, c$1, Ut.backCCW, ji(u$1, n$2.zoom, o$3.paint.get("heatmap-intensity"), f$1), null, m$1, o$3.id, d$1.layoutVertexBuffer, d$1.indexBuffer, d$1.segments, o$3.paint, n$2.zoom, _$1);
							}
							a$3.viewport.set([
								0,
								0,
								e$3.width,
								e$3.height
							]);
						}(e$2, i$2, o$2, r$2) : "translucent" === e$2.renderPass && function(e$3, i$3) {
							const o$3 = e$3.context, r$3 = o$3.gl;
							o$3.setColorMode(e$3.colorModeForRenderPass());
							const a$3 = i$3.heatmapFbos.get(t.c2);
							a$3 && (o$3.activeTexture.set(r$3.TEXTURE0), r$3.bindTexture(r$3.TEXTURE_2D, a$3.colorAttachment.get()), o$3.activeTexture.set(r$3.TEXTURE1), nr(o$3, i$3).bind(r$3.LINEAR, r$3.CLAMP_TO_EDGE), e$3.useProgram("heatmapTexture").draw(o$3, r$3.TRIANGLES, Zt.disabled, Vt.disabled, e$3.colorModeForRenderPass(), Ut.disabled, Ni(e$3, i$3, 0, 1), null, null, i$3.id, e$3.viewportBuffer, e$3.quadTriangleIndexBuffer, e$3.viewportSegments, i$3.paint, e$3.transform.zoom));
						}(e$2, o$2);
					}(e$1, i$1, o$1, r$1, a$1) : t.ce(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = o$2.paint.get("line-opacity"), l$1 = o$2.paint.get("line-width");
						if (0 === n$1.constantOr(1) || 0 === l$1.constantOr(1)) return;
						const c$1 = e$2.getDepthModeForSublayer(0, Zt.ReadOnly), h$1 = e$2.colorModeForRenderPass(), u$1 = o$2.paint.get("line-dasharray"), d$1 = u$1.constantOr(1), _$1 = o$2.paint.get("line-pattern"), p$1 = _$1.constantOr(1), m$1 = o$2.paint.get("line-gradient"), f$1 = o$2.getCrossfadeParameters(), g$1 = p$1 ? "linePattern" : d$1 ? "lineSDF" : m$1 ? "lineGradient" : "line", v$1 = e$2.context, b$1 = v$1.gl, x$1 = e$2.transform;
						let y$1 = !0;
						for (const a$3 of r$2) {
							const r$3 = i$2.getTile(a$3);
							if (p$1 && !r$3.patternsLoaded()) continue;
							const n$2 = r$3.getBucket(o$2);
							if (!n$2) continue;
							const l$2 = n$2.programConfigurations.get(o$2.id), w$1 = e$2.context.program.get(), T$1 = e$2.useProgram(g$1, l$2), P$1 = y$1 || T$1.program !== w$1, C$1 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(a$3), I$1 = _$1.constantOr(null), M$1 = u$1 && u$1.constantOr(null);
							if (I$1 && r$3.imageAtlas) {
								const e$3 = r$3.imageAtlas, t$1 = e$3.patternPositions[I$1.to.toString()], i$3 = e$3.patternPositions[I$1.from.toString()];
								t$1 && i$3 && l$2.setConstantPatternPositions(t$1, i$3);
							} else if (M$1) {
								const t$1 = "round" === o$2.layout.get("line-cap"), i$3 = e$2.lineAtlas.getDash(M$1.to, t$1), r$4 = e$2.lineAtlas.getDash(M$1.from, t$1);
								l$2.setConstantDashPositions(i$3, r$4);
							}
							const S$1 = x$1.getProjectionData({
								overscaledTileID: a$3,
								applyGlobeMatrix: !s$1,
								applyTerrainMatrix: !0
							}), E$1 = x$1.getPixelScale(), R$1 = p$1 ? Wi(e$2, r$3, o$2, E$1, f$1) : d$1 ? Hi(e$2, r$3, o$2, E$1, f$1) : m$1 ? qi(e$2, r$3, o$2, E$1, n$2.lineClipsArray.length) : $i(e$2, r$3, o$2, E$1);
							if (p$1) v$1.activeTexture.set(b$1.TEXTURE0), r$3.imageAtlasTexture.bind(b$1.LINEAR, b$1.CLAMP_TO_EDGE), l$2.updatePaintBuffers(f$1);
							else if (d$1) (P$1 || e$2.lineAtlas.dirty) && (v$1.activeTexture.set(b$1.TEXTURE0), e$2.lineAtlas.bind(v$1)), l$2.updatePaintBuffers(f$1);
							else if (m$1) {
								const r$4 = n$2.gradients[o$2.id];
								let s$2 = r$4.texture;
								if (o$2.gradientVersion !== r$4.version) {
									let l$3 = 256;
									if (o$2.stepInterpolant) {
										const o$3 = i$2.getSource().maxzoom, r$5 = a$3.canonical.z === o$3 ? Math.ceil(1 << e$2.transform.maxZoom - a$3.canonical.z) : 1;
										l$3 = t.ah(t.c3(n$2.maxLineLength / t.$ * 1024 * r$5), 256, v$1.maxTextureSize);
									}
									r$4.gradient = t.c4({
										expression: o$2.gradientExpression(),
										evaluationKey: "lineProgress",
										resolution: l$3,
										image: r$4.gradient || void 0,
										clips: n$2.lineClipsArray
									}), r$4.texture ? r$4.texture.update(r$4.gradient) : r$4.texture = new t.T(v$1, r$4.gradient, b$1.RGBA), r$4.version = o$2.gradientVersion, s$2 = r$4.texture;
								}
								v$1.activeTexture.set(b$1.TEXTURE0), s$2.bind(o$2.stepInterpolant ? b$1.NEAREST : b$1.LINEAR, b$1.CLAMP_TO_EDGE);
							}
							const z$1 = e$2.stencilModeForClipping(a$3);
							T$1.draw(v$1, b$1.TRIANGLES, c$1, z$1, h$1, Ut.disabled, R$1, C$1, S$1, o$2.id, n$2.layoutVertexBuffer, n$2.indexBuffer, n$2.segments, o$2.paint, e$2.transform.zoom, l$2, n$2.layoutVertexBuffer2), y$1 = !1;
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cf(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						const s$1 = o$2.paint.get("fill-color"), n$1 = o$2.paint.get("fill-opacity");
						if (0 === n$1.constantOr(1)) return;
						const { isRenderingToTexture: l$1 } = a$2, c$1 = e$2.colorModeForRenderPass(), h$1 = o$2.paint.get("fill-pattern"), u$1 = e$2.opaquePassEnabledForLayer() && !h$1.constantOr(1) && 1 === s$1.constantOr(t.bf.transparent).a && 1 === n$1.constantOr(0) ? "opaque" : "translucent";
						if (e$2.renderPass === u$1) {
							const t$1 = e$2.getDepthModeForSublayer(1, "opaque" === e$2.renderPass ? Zt.ReadWrite : Zt.ReadOnly);
							cr(e$2, i$2, o$2, r$2, t$1, c$1, !1, l$1);
						}
						if ("translucent" === e$2.renderPass && o$2.paint.get("fill-antialias")) {
							const t$1 = e$2.getDepthModeForSublayer(o$2.getPaintProperty("fill-outline-color") ? 2 : 0, Zt.ReadOnly);
							cr(e$2, i$2, o$2, r$2, t$1, c$1, !0, l$1);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cg(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						const a$2 = i$2.paint.get("fill-extrusion-opacity");
						if (0 === a$2) return;
						const { isRenderingToTexture: s$1 } = r$2;
						if ("translucent" === e$2.renderPass) {
							const r$3 = new Zt(e$2.context.gl.LEQUAL, Zt.ReadWrite, e$2.depthRangeFor3D);
							if (1 !== a$2 || i$2.paint.get("fill-extrusion-pattern").constantOr(1)) hr(e$2, t$1, i$2, o$2, r$3, Vt.disabled, jt.disabled, s$1), hr(e$2, t$1, i$2, o$2, r$3, e$2.stencilModeFor3D(), e$2.colorModeForRenderPass(), s$1);
							else {
								const a$3 = e$2.colorModeForRenderPass();
								hr(e$2, t$1, i$2, o$2, r$3, Vt.disabled, a$3, s$1);
							}
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ch(o$1) ? function(e$2, i$2, o$2, r$2, a$2) {
						if ("offscreen" !== e$2.renderPass && "translucent" !== e$2.renderPass) return;
						const { isRenderingToTexture: s$1 } = a$2, n$1 = e$2.context, l$1 = e$2.style.projection.useSubdivision, c$1 = e$2.getDepthModeForSublayer(0, Zt.ReadOnly), h$1 = e$2.colorModeForRenderPass();
						if ("offscreen" === e$2.renderPass) (function(e$3, i$3, o$3, r$3, a$3, s$2, n$2) {
							const l$2 = e$3.context, c$2 = l$2.gl;
							for (const h$2 of o$3) {
								const o$4 = i$3.getTile(h$2), u$1 = o$4.dem;
								if (!u$1 || !u$1.data) continue;
								if (!o$4.needsHillshadePrepare) continue;
								const d$1 = u$1.dim, _$1 = u$1.stride, p$1 = u$1.getPixels();
								if (l$2.activeTexture.set(c$2.TEXTURE1), l$2.pixelStoreUnpackPremultiplyAlpha.set(!1), o$4.demTexture = o$4.demTexture || e$3.getTileTexture(_$1), o$4.demTexture) {
									const e$4 = o$4.demTexture;
									e$4.update(p$1, { premultiply: !1 }), e$4.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								} else o$4.demTexture = new t.T(l$2, p$1, c$2.RGBA, { premultiply: !1 }), o$4.demTexture.bind(c$2.NEAREST, c$2.CLAMP_TO_EDGE);
								l$2.activeTexture.set(c$2.TEXTURE0);
								let m$1 = o$4.fbo;
								if (!m$1) {
									const e$4 = new t.T(l$2, {
										width: d$1,
										height: d$1,
										data: null
									}, c$2.RGBA);
									e$4.bind(c$2.LINEAR, c$2.CLAMP_TO_EDGE), m$1 = o$4.fbo = l$2.createFramebuffer(d$1, d$1, !0, !1), m$1.colorAttachment.set(e$4.texture);
								}
								l$2.bindFramebuffer.set(m$1.framebuffer), l$2.viewport.set([
									0,
									0,
									d$1,
									d$1
								]), e$3.useProgram("hillshadePrepare").draw(l$2, c$2.TRIANGLES, a$3, s$2, n$2, Ut.disabled, Zi(o$4.tileID, u$1), null, null, r$3.id, e$3.rasterBoundsBuffer, e$3.quadTriangleIndexBuffer, e$3.rasterBoundsSegments), o$4.needsHillshadePrepare = !1;
							}
						})(e$2, i$2, r$2, o$2, c$1, Vt.disabled, h$1), n$1.viewport.set([
							0,
							0,
							e$2.width,
							e$2.height
						]);
						else if ("translucent" === e$2.renderPass) if (l$1) {
							const [t$1, a$3, n$2] = e$2.stencilConfigForOverlapTwoPass(r$2);
							ur(e$2, i$2, o$2, n$2, t$1, c$1, h$1, !1, s$1), ur(e$2, i$2, o$2, n$2, a$3, c$1, h$1, !0, s$1);
						} else {
							const [t$1, a$3] = e$2.getStencilConfigForOverlapAndUpdateStencilID(r$2);
							ur(e$2, i$2, o$2, a$3, t$1, c$1, h$1, !1, s$1);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ci(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (!o$2.length) return;
						const { isRenderingToTexture: a$2 } = r$2, s$1 = e$2.style.projection.useSubdivision, n$1 = e$2.getDepthModeForSublayer(0, Zt.ReadOnly), l$1 = e$2.colorModeForRenderPass();
						if (s$1) {
							const [r$3, s$2, c$1] = e$2.stencilConfigForOverlapTwoPass(o$2);
							dr(e$2, t$1, i$2, c$1, r$3, n$1, l$1, !1, a$2), dr(e$2, t$1, i$2, c$1, s$2, n$1, l$1, !0, a$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(o$2);
							dr(e$2, t$1, i$2, s$2, r$3, n$1, l$1, !1, a$2);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.cj(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						if ("translucent" !== e$2.renderPass) return;
						if (0 === i$2.paint.get("raster-opacity")) return;
						if (!o$2.length) return;
						const { isRenderingToTexture: a$2 } = r$2, s$1 = t$1.getSource(), n$1 = e$2.style.projection.useSubdivision;
						if (s$1 instanceof X) pr(e$2, t$1, i$2, o$2, null, !1, !1, s$1.tileCoords, s$1.flippedWindingOrder, a$2);
						else if (n$1) {
							const [r$3, s$2, n$2] = e$2.stencilConfigForOverlapTwoPass(o$2);
							pr(e$2, t$1, i$2, n$2, r$3, !1, !0, _r, !1, a$2), pr(e$2, t$1, i$2, n$2, s$2, !0, !0, _r, !1, a$2);
						} else {
							const [r$3, s$2] = e$2.getStencilConfigForOverlapAndUpdateStencilID(o$2);
							pr(e$2, t$1, i$2, s$2, r$3, !1, !0, _r, !1, a$2);
						}
					}(e$1, i$1, o$1, r$1, a$1) : t.ck(o$1) ? function(e$2, t$1, i$2, o$2, r$2) {
						const a$2 = i$2.paint.get("background-color"), s$1 = i$2.paint.get("background-opacity");
						if (0 === s$1) return;
						const { isRenderingToTexture: n$1 } = r$2, l$1 = e$2.context, c$1 = l$1.gl, h$1 = e$2.style.projection, u$1 = e$2.transform, d$1 = u$1.tileSize, _$1 = i$2.paint.get("background-pattern");
						if (e$2.isPatternMissing(_$1)) return;
						const p$1 = !_$1 && 1 === a$2.a && 1 === s$1 && e$2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
						if (e$2.renderPass !== p$1) return;
						const m$1 = Vt.disabled, f$1 = e$2.getDepthModeForSublayer(0, "opaque" === p$1 ? Zt.ReadWrite : Zt.ReadOnly), g$1 = e$2.colorModeForRenderPass(), v$1 = e$2.useProgram(_$1 ? "backgroundPattern" : "background"), b$1 = o$2 || ve(u$1, {
							tileSize: d$1,
							terrain: e$2.style.map.terrain
						});
						_$1 && (l$1.activeTexture.set(c$1.TEXTURE0), e$2.imageManager.bind(e$2.context));
						const x$1 = i$2.getCrossfadeParameters();
						for (const t$2 of b$1) {
							const o$3 = u$1.getProjectionData({
								overscaledTileID: t$2,
								applyGlobeMatrix: !n$1,
								applyTerrainMatrix: !0
							}), r$3 = _$1 ? oo(s$1, e$2, _$1, {
								tileID: t$2,
								tileSize: d$1
							}, x$1) : io(s$1, a$2), p$2 = e$2.style.map.terrain && e$2.style.map.terrain.getTerrainData(t$2), b$2 = h$1.getMeshFromTileID(l$1, t$2.canonical, !1, !0, "raster");
							v$1.draw(l$1, c$1.TRIANGLES, f$1, m$1, g$1, Ut.backCCW, r$3, p$2, o$3, i$2.id, b$2.vertexBuffer, b$2.indexBuffer, b$2.segments);
						}
					}(e$1, 0, o$1, r$1, a$1) : t.cl(o$1) && function(e$2, t$1, i$2, o$2) {
						const { isRenderingGlobe: r$2 } = o$2, a$2 = e$2.context, s$1 = i$2.implementation, n$1 = e$2.style.projection, l$1 = e$2.transform, c$1 = l$1.getProjectionDataForCustomLayer(r$2), h$1 = {
							farZ: l$1.farZ,
							nearZ: l$1.nearZ,
							fov: l$1.fov * Math.PI / 180,
							modelViewProjectionMatrix: l$1.modelViewProjectionMatrix,
							projectionMatrix: l$1.projectionMatrix,
							shaderData: {
								variantName: n$1.shaderVariantName,
								vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${n$1.shaderPreludeCode.vertexSource}`,
								define: n$1.shaderDefine
							},
							defaultProjectionData: c$1
						}, u$1 = s$1.renderingMode ? s$1.renderingMode : "2d";
						if ("offscreen" === e$2.renderPass) {
							const t$2 = s$1.prerender;
							t$2 && (e$2.setCustomLayerDefaults(), a$2.setColorMode(e$2.colorModeForRenderPass()), t$2.call(s$1, a$2.gl, h$1), a$2.setDirty(), e$2.setBaseState());
						} else if ("translucent" === e$2.renderPass) {
							e$2.setCustomLayerDefaults(), a$2.setColorMode(e$2.colorModeForRenderPass()), a$2.setStencilMode(Vt.disabled);
							const t$2 = "3d" === u$1 ? e$2.getDepthModeFor3D() : e$2.getDepthModeForSublayer(0, Zt.ReadOnly);
							a$2.setDepthMode(t$2), s$1.render(a$2.gl, h$1), a$2.setDirty(), e$2.setBaseState(), a$2.bindFramebuffer.set(null);
						}
					}(e$1, 0, o$1, a$1));
				}
				saveTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1.size[0]];
					t$1 ? t$1.push(e$1) : this._tileTextures[e$1.size[0]] = [e$1];
				}
				getTileTexture(e$1) {
					const t$1 = this._tileTextures[e$1];
					return t$1 && t$1.length > 0 ? t$1.pop() : null;
				}
				isPatternMissing(e$1) {
					if (!e$1) return !1;
					if (!e$1.from || !e$1.to) return !0;
					const t$1 = this.imageManager.getPattern(e$1.from.toString()), i$1 = this.imageManager.getPattern(e$1.to.toString());
					return !t$1 || !i$1;
				}
				useProgram(e$1, t$1, i$1 = !1, o$1 = []) {
					this.cache = this.cache || {};
					const r$1 = !!this.style.map.terrain, a$1 = this.style.projection, s$1 = i$1 ? xt.projectionMercator : a$1.shaderPreludeCode, n$1 = i$1 ? Pt : a$1.shaderDefine, l$1 = e$1 + (t$1 ? t$1.cacheKey : "") + `/${i$1 ? Ct : a$1.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r$1 ? "/terrain" : "") + (o$1 ? `/${o$1.join("/")}` : "");
					return this.cache[l$1] || (this.cache[l$1] = new Si(this.context, xt[e$1], t$1, ao[e$1], this._showOverdrawInspector, r$1, s$1, n$1, o$1)), this.cache[l$1];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					const e$1 = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e$1.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
				}
				destroy() {
					this.debugOverlayTexture && this.debugOverlayTexture.destroy();
				}
				overLimit() {
					const { drawingBufferWidth: e$1, drawingBufferHeight: t$1 } = this.context.gl;
					return this.width !== e$1 || this.height !== t$1;
				}
			}
			function Sr(e$1, t$1) {
				let i$1, o$1 = !1, r$1 = null, a$1 = null;
				const s$1 = () => {
					r$1 = null, o$1 && (e$1.apply(a$1, i$1), r$1 = setTimeout(s$1, t$1), o$1 = !1);
				};
				return (...e$2) => (o$1 = !0, a$1 = this, i$1 = e$2, r$1 || s$1(), r$1);
			}
			class Er {
				constructor(e$1) {
					this._getCurrentHash = () => {
						const e$2 = window.location.hash.replace("#", "");
						if (this._hashName) {
							let t$1;
							return e$2.split("&").map(((e$3) => e$3.split("="))).forEach(((e$3) => {
								e$3[0] === this._hashName && (t$1 = e$3);
							})), (t$1 && t$1[1] || "").split("/");
						}
						return e$2.split("/");
					}, this._onHashChange = () => {
						const e$2 = this._getCurrentHash();
						if (!this._isValidHash(e$2)) return !1;
						const t$1 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e$2[3] || 0) : this._map.getBearing();
						return this._map.jumpTo({
							center: [+e$2[2], +e$2[1]],
							zoom: +e$2[0],
							bearing: t$1,
							pitch: +(e$2[4] || 0)
						}), !0;
					}, this._updateHashUnthrottled = () => {
						const e$2 = window.location.href.replace(/(#.*)?$/, this.getHashString());
						window.history.replaceState(window.history.state, null, e$2);
					}, this._removeHash = () => {
						const e$2 = this._getCurrentHash();
						if (0 === e$2.length) return;
						const t$1 = e$2.join("/");
						let i$1 = t$1;
						i$1.split("&").length > 0 && (i$1 = i$1.split("&")[0]), this._hashName && (i$1 = `${this._hashName}=${t$1}`);
						let o$1 = window.location.hash.replace(i$1, "");
						o$1.startsWith("#&") ? o$1 = o$1.slice(0, 1) + o$1.slice(2) : "#" === o$1 && (o$1 = "");
						let r$1 = window.location.href.replace(/(#.+)?$/, o$1);
						r$1 = r$1.replace("&&", "&"), window.history.replaceState(window.history.state, null, r$1);
					}, this._updateHash = Sr(this._updateHashUnthrottled, 300), this._hashName = e$1 && encodeURIComponent(e$1);
				}
				addTo(e$1) {
					return this._map = e$1, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
				}
				remove() {
					return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
				}
				getHashString(e$1) {
					const t$1 = this._map.getCenter(), i$1 = Math.round(100 * this._map.getZoom()) / 100, o$1 = Math.ceil((i$1 * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r$1 = Math.pow(10, o$1), a$1 = Math.round(t$1.lng * r$1) / r$1, s$1 = Math.round(t$1.lat * r$1) / r$1, n$1 = this._map.getBearing(), l$1 = this._map.getPitch();
					let c$1 = "";
					if (c$1 += e$1 ? `/${a$1}/${s$1}/${i$1}` : `${i$1}/${s$1}/${a$1}`, (n$1 || l$1) && (c$1 += "/" + Math.round(10 * n$1) / 10), l$1 && (c$1 += `/${Math.round(l$1)}`), this._hashName) {
						const e$2 = this._hashName;
						let t$2 = !1;
						const i$2 = window.location.hash.slice(1).split("&").map(((i$3) => {
							const o$2 = i$3.split("=")[0];
							return o$2 === e$2 ? (t$2 = !0, `${o$2}=${c$1}`) : i$3;
						})).filter(((e$3) => e$3));
						return t$2 || i$2.push(`${e$2}=${c$1}`), `#${i$2.join("&")}`;
					}
					return `#${c$1}`;
				}
				_isValidHash(e$1) {
					if (e$1.length < 3 || e$1.some(isNaN)) return !1;
					try {
						new t.S(+e$1[2], +e$1[1]);
					} catch (e$2) {
						return !1;
					}
					const i$1 = +e$1[0], o$1 = +(e$1[3] || 0), r$1 = +(e$1[4] || 0);
					return i$1 >= this._map.getMinZoom() && i$1 <= this._map.getMaxZoom() && o$1 >= -180 && o$1 <= 180 && r$1 >= this._map.getMinPitch() && r$1 <= this._map.getMaxPitch();
				}
			}
			const Rr = {
				linearity: .3,
				easing: t.cm(0, 0, .3, 1)
			}, zr = t.e({
				deceleration: 2500,
				maxSpeed: 1400
			}, Rr), Dr = t.e({
				deceleration: 20,
				maxSpeed: 1400
			}, Rr), Ar = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Rr), Lr = t.e({
				deceleration: 1e3,
				maxSpeed: 90
			}, Rr), kr = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Rr);
			class Fr {
				constructor(e$1) {
					this._map = e$1, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(e$1) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: s.now(),
						settings: e$1
					});
				}
				_drainInertiaBuffer() {
					const e$1 = this._inertiaBuffer, t$1 = s.now();
					for (; e$1.length > 0 && t$1 - e$1[0].time > 160;) e$1.shift();
				}
				_onMoveEnd(e$1) {
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					const i$1 = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						roll: 0,
						pan: new t.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (const { settings: e$2 } of this._inertiaBuffer) i$1.zoom += e$2.zoomDelta || 0, i$1.bearing += e$2.bearingDelta || 0, i$1.pitch += e$2.pitchDelta || 0, i$1.roll += e$2.rollDelta || 0, e$2.panDelta && i$1.pan._add(e$2.panDelta), e$2.around && (i$1.around = e$2.around), e$2.pinchAround && (i$1.pinchAround = e$2.pinchAround);
					const o$1 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r$1 = {};
					if (i$1.pan.mag()) {
						const a$1 = Or(i$1.pan.mag(), o$1, t.e({}, zr, e$1 || {})), s$1 = i$1.pan.mult(a$1.amount / i$1.pan.mag()), n$1 = this._map.cameraHelper.handlePanInertia(s$1, this._map.transform);
						r$1.center = n$1.easingCenter, r$1.offset = n$1.easingOffset, Br(r$1, a$1);
					}
					if (i$1.zoom) {
						const e$2 = Or(i$1.zoom, o$1, Dr);
						r$1.zoom = this._map.transform.zoom + e$2.amount, Br(r$1, e$2);
					}
					if (i$1.bearing) {
						const e$2 = Or(i$1.bearing, o$1, Ar);
						r$1.bearing = this._map.transform.bearing + t.ah(e$2.amount, -179, 179), Br(r$1, e$2);
					}
					if (i$1.pitch) {
						const e$2 = Or(i$1.pitch, o$1, Lr);
						r$1.pitch = this._map.transform.pitch + e$2.amount, Br(r$1, e$2);
					}
					if (i$1.roll) {
						const e$2 = Or(i$1.roll, o$1, kr);
						r$1.roll = this._map.transform.roll + t.ah(e$2.amount, -179, 179), Br(r$1, e$2);
					}
					if (r$1.zoom || r$1.bearing) {
						const e$2 = void 0 === i$1.pinchAround ? i$1.around : i$1.pinchAround;
						r$1.around = e$2 ? this._map.unproject(e$2) : this._map.getCenter();
					}
					return this.clear(), t.e(r$1, { noMoveStart: !0 });
				}
			}
			function Br(e$1, t$1) {
				(!e$1.duration || e$1.duration < t$1.duration) && (e$1.duration = t$1.duration, e$1.easing = t$1.easing);
			}
			function Or(e$1, i$1, o$1) {
				const { maxSpeed: r$1, linearity: a$1, deceleration: s$1 } = o$1, n$1 = t.ah(e$1 * a$1 / (i$1 / 1e3), -r$1, r$1), l$1 = Math.abs(n$1) / (s$1 * a$1);
				return {
					easing: o$1.easing,
					duration: 1e3 * l$1,
					amount: n$1 * (l$1 / 2)
				};
			}
			class jr extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, o$1, r$1 = {}) {
					o$1 = o$1 instanceof MouseEvent ? o$1 : new MouseEvent(e$1, o$1);
					const a$1 = n.mousePos(i$1.getCanvas(), o$1), s$1 = i$1.unproject(a$1);
					super(e$1, t.e({
						point: a$1,
						lngLat: s$1,
						originalEvent: o$1
					}, r$1)), this._defaultPrevented = !1, this.target = i$1;
				}
			}
			class Nr extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, i$1, o$1) {
					const r$1 = "touchend" === e$1 ? o$1.changedTouches : o$1.touches, a$1 = n.touchPos(i$1.getCanvasContainer(), r$1), s$1 = a$1.map(((e$2) => i$1.unproject(e$2))), l$1 = a$1.reduce(((e$2, t$1, i$2, o$2) => e$2.add(t$1.div(o$2.length))), new t.P(0, 0));
					super(e$1, {
						points: a$1,
						point: l$1,
						lngLats: s$1,
						lngLat: i$1.unproject(l$1),
						originalEvent: o$1
					}), this._defaultPrevented = !1;
				}
			}
			class Ur extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e$1, t$1, i$1) {
					super(e$1, { originalEvent: i$1 }), this._defaultPrevented = !1;
				}
			}
			class Zr {
				constructor(e$1, t$1) {
					this._map = e$1, this._clickTolerance = t$1.clickTolerance;
				}
				reset() {
					delete this._mousedownPos;
				}
				wheel(e$1) {
					return this._firePreventable(new Ur(e$1.type, this._map, e$1));
				}
				mousedown(e$1, t$1) {
					return this._mousedownPos = t$1, this._firePreventable(new jr(e$1.type, this._map, e$1));
				}
				mouseup(e$1) {
					this._map.fire(new jr(e$1.type, this._map, e$1));
				}
				click(e$1, t$1) {
					this._mousedownPos && this._mousedownPos.dist(t$1) >= this._clickTolerance || this._map.fire(new jr(e$1.type, this._map, e$1));
				}
				dblclick(e$1) {
					return this._firePreventable(new jr(e$1.type, this._map, e$1));
				}
				mouseover(e$1) {
					this._map.fire(new jr(e$1.type, this._map, e$1));
				}
				mouseout(e$1) {
					this._map.fire(new jr(e$1.type, this._map, e$1));
				}
				touchstart(e$1) {
					return this._firePreventable(new Nr(e$1.type, this._map, e$1));
				}
				touchmove(e$1) {
					this._map.fire(new Nr(e$1.type, this._map, e$1));
				}
				touchend(e$1) {
					this._map.fire(new Nr(e$1.type, this._map, e$1));
				}
				touchcancel(e$1) {
					this._map.fire(new Nr(e$1.type, this._map, e$1));
				}
				_firePreventable(e$1) {
					if (this._map.fire(e$1), e$1.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class Gr {
				constructor(e$1) {
					this._map = e$1;
				}
				reset() {
					this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
				}
				mousemove(e$1) {
					this._map.fire(new jr(e$1.type, this._map, e$1));
				}
				mousedown() {
					this._delayContextMenu = !0, this._ignoreContextMenu = !1;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new jr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e$1) {
					this._delayContextMenu ? this._contextMenuEvent = e$1 : this._ignoreContextMenu || this._map.fire(new jr(e$1.type, this._map, e$1)), this._map.listens("contextmenu") && e$1.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class Vr {
				constructor(e$1) {
					this._map = e$1;
				}
				get transform() {
					return this._map._requestedCameraState || this._map.transform;
				}
				get center() {
					return {
						lng: this.transform.center.lng,
						lat: this.transform.center.lat
					};
				}
				get zoom() {
					return this.transform.zoom;
				}
				get pitch() {
					return this.transform.pitch;
				}
				get bearing() {
					return this.transform.bearing;
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this._map.terrain);
				}
			}
			class $r {
				constructor(e$1, t$1) {
					this._map = e$1, this._tr = new Vr(e$1), this._el = e$1.getCanvasContainer(), this._container = e$1.getContainer(), this._clickTolerance = t$1.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e$1, t$1) {
					this.isEnabled() && e$1.shiftKey && 0 === e$1.button && (n.disableDrag(), this._startPos = this._lastPos = t$1, this._active = !0);
				}
				mousemoveWindow(e$1, t$1) {
					if (!this._active) return;
					const i$1 = t$1;
					if (this._lastPos.equals(i$1) || !this._box && i$1.dist(this._startPos) < this._clickTolerance) return;
					const o$1 = this._startPos;
					this._lastPos = i$1, this._box || (this._box = n.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e$1));
					const r$1 = Math.min(o$1.x, i$1.x), a$1 = Math.max(o$1.x, i$1.x), s$1 = Math.min(o$1.y, i$1.y), l$1 = Math.max(o$1.y, i$1.y);
					n.setTransform(this._box, `translate(${r$1}px,${s$1}px)`), this._box.style.width = a$1 - r$1 + "px", this._box.style.height = l$1 - s$1 + "px";
				}
				mouseupWindow(e$1, i$1) {
					if (!this._active) return;
					if (0 !== e$1.button) return;
					const o$1 = this._startPos, r$1 = i$1;
					if (this.reset(), n.suppressClick(), o$1.x !== r$1.x || o$1.y !== r$1.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e$1 })), { cameraAnimation: (e$2) => e$2.fitScreenCoordinates(o$1, r$1, this._tr.bearing, { linear: !0 }) };
					this._fireEvent("boxzoomcancel", e$1);
				}
				keydown(e$1) {
					this._active && 27 === e$1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e$1));
				}
				reset() {
					this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(e$1, i$1) {
					return this._map.fire(new t.l(e$1, { originalEvent: i$1 }));
				}
			}
			function qr(e$1, t$1) {
				if (e$1.length !== t$1.length) throw new Error(`The number of touches and points are not equal - touches ${e$1.length}, points ${t$1.length}`);
				const i$1 = {};
				for (let o$1 = 0; o$1 < e$1.length; o$1++) i$1[e$1[o$1].identifier] = t$1[o$1];
				return i$1;
			}
			class Wr {
				constructor(e$1) {
					this.reset(), this.numTouches = e$1.numTouches;
				}
				reset() {
					delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
				}
				touchstart(e$1, i$1, o$1) {
					(this.centroid || o$1.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e$1.timeStamp), o$1.length === this.numTouches && (this.centroid = function(e$2) {
						const i$2 = new t.P(0, 0);
						for (const t$1 of e$2) i$2._add(t$1);
						return i$2.div(e$2.length);
					}(i$1), this.touches = qr(o$1, i$1)));
				}
				touchmove(e$1, t$1, i$1) {
					if (this.aborted || !this.centroid) return;
					const o$1 = qr(i$1, t$1);
					for (const e$2 in this.touches) {
						const t$2 = o$1[e$2];
						(!t$2 || t$2.dist(this.touches[e$2]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e$1, t$1, i$1) {
					if ((!this.centroid || e$1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i$1.length) {
						const e$2 = !this.aborted && this.centroid;
						if (this.reset(), e$2) return e$2;
					}
				}
			}
			class Hr {
				constructor(e$1) {
					this.singleTap = new Wr(e$1), this.numTaps = e$1.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, delete this.lastTap, this.count = 0, this.singleTap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this.singleTap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this.singleTap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this.singleTap.touchend(e$1, t$1, i$1);
					if (o$1) {
						const t$2 = e$1.timeStamp - this.lastTime < 500, i$2 = !this.lastTap || this.lastTap.dist(o$1) < 30;
						if (t$2 && i$2 || this.reset(), this.count++, this.lastTime = e$1.timeStamp, this.lastTap = o$1, this.count === this.numTaps) return this.reset(), o$1;
					}
				}
			}
			class Xr {
				constructor(e$1) {
					this._tr = new Vr(e$1), this._zoomIn = new Hr({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new Hr({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e$1, t$1, i$1) {
					this._zoomIn.touchstart(e$1, t$1, i$1), this._zoomOut.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					this._zoomIn.touchmove(e$1, t$1, i$1), this._zoomOut.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					const o$1 = this._zoomIn.touchend(e$1, t$1, i$1), r$1 = this._zoomOut.touchend(e$1, t$1, i$1), a$1 = this._tr;
					return o$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: a$1.zoom + 1,
						around: a$1.unproject(o$1)
					}, { originalEvent: e$1 }) }) : r$1 ? (this._active = !0, e$1.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t$2) => t$2.easeTo({
						duration: 300,
						zoom: a$1.zoom - 1,
						around: a$1.unproject(r$1)
					}, { originalEvent: e$1 }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Kr {
				constructor(e$1) {
					this._enabled = !!e$1.enable, this._moveStateManager = e$1.moveStateManager, this._clickTolerance = e$1.clickTolerance || 1, this._moveFunction = e$1.move, this._activateOnStart = !!e$1.activateOnStart, e$1.assignEvents(this), this.reset();
				}
				reset(e$1) {
					this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e$1);
				}
				_move(...e$1) {
					const t$1 = this._moveFunction(...e$1);
					if (t$1.bearingDelta || t$1.pitchDelta || t$1.rollDelta || t$1.around || t$1.panDelta) return this._active = !0, t$1;
				}
				dragStart(e$1, t$1) {
					this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e$1) && (this._moveStateManager.startMove(e$1), this._lastPoint = Array.isArray(t$1) ? t$1[0] : t$1, this._activateOnStart && this._lastPoint && (this._active = !0));
				}
				dragMove(e$1, t$1) {
					if (!this.isEnabled()) return;
					const i$1 = this._lastPoint;
					if (!i$1) return;
					if (e$1.preventDefault(), !this._moveStateManager.isValidMoveEvent(e$1)) return void this.reset(e$1);
					const o$1 = Array.isArray(t$1) ? t$1[0] : t$1;
					return !this._moved && o$1.dist(i$1) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = o$1, this._move(i$1, o$1));
				}
				dragEnd(e$1) {
					this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e$1) && (this._moved && n.suppressClick(), this.reset(e$1));
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				getClickTolerance() {
					return this._clickTolerance;
				}
			}
			const Yr = 0, Qr = 2, Jr = {
				[Yr]: 1,
				[Qr]: 2
			};
			class ea {
				constructor(e$1) {
					this._correctEvent = e$1.checkCorrectEvent;
				}
				startMove(e$1) {
					this._eventButton = n.mouseButton(e$1);
				}
				endMove(e$1) {
					delete this._eventButton;
				}
				isValidStartEvent(e$1) {
					return this._correctEvent(e$1);
				}
				isValidMoveEvent(e$1) {
					return !function(e$2, t$1) {
						const i$1 = Jr[t$1];
						return void 0 === e$2.buttons || (e$2.buttons & i$1) !== i$1;
					}(e$1, this._eventButton);
				}
				isValidEndEvent(e$1) {
					return n.mouseButton(e$1) === this._eventButton;
				}
			}
			class ta {
				constructor() {
					this._firstTouch = void 0;
				}
				_isOneFingerTouch(e$1) {
					return 1 === e$1.targetTouches.length;
				}
				_isSameTouchEvent(e$1) {
					return e$1.targetTouches[0].identifier === this._firstTouch;
				}
				startMove(e$1) {
					this._firstTouch = e$1.targetTouches[0].identifier;
				}
				endMove(e$1) {
					delete this._firstTouch;
				}
				isValidStartEvent(e$1) {
					return this._isOneFingerTouch(e$1);
				}
				isValidMoveEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
				isValidEndEvent(e$1) {
					return this._isOneFingerTouch(e$1) && this._isSameTouchEvent(e$1);
				}
			}
			class ia {
				constructor(e$1 = new ea({ checkCorrectEvent: () => !0 }), t$1 = new ta()) {
					this.mouseMoveStateManager = e$1, this.oneFingerTouchMoveStateManager = t$1;
				}
				_executeRelevantHandler(e$1, t$1, i$1) {
					return e$1 instanceof MouseEvent ? t$1(e$1) : "undefined" != typeof TouchEvent && e$1 instanceof TouchEvent ? i$1(e$1) : void 0;
				}
				startMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.startMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.startMove(e$2)));
				}
				endMove(e$1) {
					this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.endMove(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.endMove(e$2)));
				}
				isValidStartEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidStartEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e$2)));
				}
				isValidMoveEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidMoveEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e$2)));
				}
				isValidEndEvent(e$1) {
					return this._executeRelevantHandler(e$1, ((e$2) => this.mouseMoveStateManager.isValidEndEvent(e$2)), ((e$2) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e$2)));
				}
			}
			const oa = (e$1) => {
				e$1.mousedown = e$1.dragStart, e$1.mousemoveWindow = e$1.dragMove, e$1.mouseup = e$1.dragEnd, e$1.contextmenu = (e$2) => {
					e$2.preventDefault();
				};
			};
			class ra {
				constructor(e$1, t$1) {
					this._clickTolerance = e$1.clickTolerance || 1, this._map = t$1, this.reset();
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new t.P(0, 0);
				}
				_shouldBePrevented(e$1) {
					return e$1 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
				}
				touchstart(e$1, t$1, i$1) {
					return this._calculateTransform(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._active) {
						if (!this._shouldBePrevented(i$1.length)) return e$1.preventDefault(), this._calculateTransform(e$1, t$1, i$1);
						this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e$1);
					}
				}
				touchend(e$1, t$1, i$1) {
					this._calculateTransform(e$1, t$1, i$1), this._active && this._shouldBePrevented(i$1.length) && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(e$1, i$1, o$1) {
					o$1.length > 0 && (this._active = !0);
					const r$1 = qr(o$1, i$1), a$1 = new t.P(0, 0), s$1 = new t.P(0, 0);
					let n$1 = 0;
					for (const e$2 in r$1) {
						const t$1 = r$1[e$2], i$2 = this._touches[e$2];
						i$2 && (a$1._add(t$1), s$1._add(t$1.sub(i$2)), n$1++, r$1[e$2] = t$1);
					}
					if (this._touches = r$1, this._shouldBePrevented(n$1) || !s$1.mag()) return;
					const l$1 = s$1.div(n$1);
					return this._sum._add(l$1), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: a$1.div(n$1),
						panDelta: l$1
					};
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class aa {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, delete this._firstTwoTouches;
				}
				touchstart(e$1, t$1, i$1) {
					this._firstTwoTouches || i$1.length < 2 || (this._firstTwoTouches = [i$1[0].identifier, i$1[1].identifier], this._start([t$1[0], t$1[1]]));
				}
				touchmove(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					e$1.preventDefault();
					const [o$1, r$1] = this._firstTwoTouches, a$1 = sa(i$1, t$1, o$1), s$1 = sa(i$1, t$1, r$1);
					if (!a$1 || !s$1) return;
					const n$1 = this._aroundCenter ? null : a$1.add(s$1).div(2);
					return this._move([a$1, s$1], n$1, e$1);
				}
				touchend(e$1, t$1, i$1) {
					if (!this._firstTwoTouches) return;
					const [o$1, r$1] = this._firstTwoTouches, a$1 = sa(i$1, t$1, o$1), s$1 = sa(i$1, t$1, r$1);
					a$1 && s$1 || (this._active && n.suppressClick(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e$1) {
					this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
			}
			function sa(e$1, t$1, i$1) {
				for (let o$1 = 0; o$1 < e$1.length; o$1++) if (e$1[o$1].identifier === i$1) return t$1[o$1];
			}
			function na(e$1, t$1) {
				return Math.log(e$1 / t$1) / Math.LN2;
			}
			class la extends aa {
				reset() {
					super.reset(), delete this._distance, delete this._startDistance;
				}
				_start(e$1) {
					this._startDistance = this._distance = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1) {
					const i$1 = this._distance;
					if (this._distance = e$1[0].dist(e$1[1]), this._active || !(Math.abs(na(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: na(this._distance, i$1),
						pinchAround: t$1
					};
				}
			}
			function ca(e$1, t$1) {
				return 180 * e$1.angleWith(t$1) / Math.PI;
			}
			class ha extends aa {
				reset() {
					super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
				}
				_start(e$1) {
					this._startVector = this._vector = e$1[0].sub(e$1[1]), this._minDiameter = e$1[0].dist(e$1[1]);
				}
				_move(e$1, t$1, i$1) {
					const o$1 = this._vector;
					if (this._vector = e$1[0].sub(e$1[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
						bearingDelta: ca(this._vector, o$1),
						pinchAround: t$1
					};
				}
				_isBelowThreshold(e$1) {
					this._minDiameter = Math.min(this._minDiameter, e$1.mag());
					const t$1 = 25 / (Math.PI * this._minDiameter) * 360, i$1 = ca(e$1, this._startVector);
					return Math.abs(i$1) < t$1;
				}
			}
			function ua(e$1) {
				return Math.abs(e$1.y) > Math.abs(e$1.x);
			}
			class da extends aa {
				constructor(e$1) {
					super(), this._currentTouchCount = 0, this._map = e$1;
				}
				reset() {
					super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
				}
				touchstart(e$1, t$1, i$1) {
					super.touchstart(e$1, t$1, i$1), this._currentTouchCount = i$1.length;
				}
				_start(e$1) {
					this._lastPoints = e$1, ua(e$1[0].sub(e$1[1])) && (this._valid = !1);
				}
				_move(e$1, t$1, i$1) {
					if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
					const o$1 = e$1[0].sub(this._lastPoints[0]), r$1 = e$1[1].sub(this._lastPoints[1]);
					return this._valid = this.gestureBeginsVertically(o$1, r$1, i$1.timeStamp), this._valid ? (this._lastPoints = e$1, this._active = !0, { pitchDelta: (o$1.y + r$1.y) / 2 * -.5 }) : void 0;
				}
				gestureBeginsVertically(e$1, t$1, i$1) {
					if (void 0 !== this._valid) return this._valid;
					const o$1 = e$1.mag() >= 2, r$1 = t$1.mag() >= 2;
					if (!o$1 && !r$1) return;
					if (!o$1 || !r$1) return void 0 === this._firstMove && (this._firstMove = i$1), i$1 - this._firstMove < 100 && void 0;
					const a$1 = e$1.y > 0 == t$1.y > 0;
					return ua(e$1) && ua(t$1) && a$1;
				}
			}
			const _a = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class pa {
				constructor(e$1) {
					this._tr = new Vr(e$1);
					const t$1 = _a;
					this._panStep = t$1.panStep, this._bearingStep = t$1.bearingStep, this._pitchStep = t$1.pitchStep, this._rotationDisabled = !1;
				}
				reset() {
					this._active = !1;
				}
				keydown(e$1) {
					if (e$1.altKey || e$1.ctrlKey || e$1.metaKey) return;
					let t$1 = 0, i$1 = 0, o$1 = 0, r$1 = 0, a$1 = 0;
					switch (e$1.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							t$1 = 1;
							break;
						case 189:
						case 109:
						case 173:
							t$1 = -1;
							break;
						case 37:
							e$1.shiftKey ? i$1 = -1 : (e$1.preventDefault(), r$1 = -1);
							break;
						case 39:
							e$1.shiftKey ? i$1 = 1 : (e$1.preventDefault(), r$1 = 1);
							break;
						case 38:
							e$1.shiftKey ? o$1 = 1 : (e$1.preventDefault(), a$1 = -1);
							break;
						case 40:
							e$1.shiftKey ? o$1 = -1 : (e$1.preventDefault(), a$1 = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (i$1 = 0, o$1 = 0), { cameraAnimation: (s$1) => {
						const n$1 = this._tr;
						s$1.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: ma,
							zoom: t$1 ? Math.round(n$1.zoom) + t$1 * (e$1.shiftKey ? 2 : 1) : n$1.zoom,
							bearing: n$1.bearing + i$1 * this._bearingStep,
							pitch: n$1.pitch + o$1 * this._pitchStep,
							offset: [-r$1 * this._panStep, -a$1 * this._panStep],
							center: n$1.center
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function ma(e$1) {
				return e$1 * (2 - e$1);
			}
			const fa = 4.000244140625, ga = 1 / 450;
			class va {
				constructor(e$1, t$1) {
					this._onTimeout = (e$2) => {
						this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e$2);
					}, this._map = e$1, this._tr = new Vr(e$1), this._triggerRenderFrame = t$1, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = ga;
				}
				setZoomRate(e$1) {
					this._defaultZoomRate = e$1;
				}
				setWheelZoomRate(e$1) {
					this._wheelZoomRate = e$1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active || void 0 !== this._finishTimeout;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e$1) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e$1 && "center" === e$1.around);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				_shouldBePrevented(e$1) {
					return !!this._map.cooperativeGestures.isEnabled() && !(e$1.ctrlKey || this._map.cooperativeGestures.isBypassed(e$1));
				}
				wheel(e$1) {
					if (!this.isEnabled()) return;
					if (this._shouldBePrevented(e$1)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e$1);
					let t$1 = e$1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e$1.deltaY : e$1.deltaY;
					const i$1 = s.now(), o$1 = i$1 - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = i$1, 0 !== t$1 && t$1 % fa == 0 ? this._type = "wheel" : 0 !== t$1 && Math.abs(t$1) < 4 ? this._type = "trackpad" : o$1 > 400 ? (this._type = null, this._lastValue = t$1, this._timeout = setTimeout(this._onTimeout, 40, e$1)) : this._type || (this._type = Math.abs(o$1 * t$1) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t$1 += this._lastValue)), e$1.shiftKey && t$1 && (t$1 /= 4), this._type && (this._lastWheelEvent = e$1, this._delta -= t$1, this._active || this._start(e$1)), e$1.preventDefault();
				}
				_start(e$1) {
					if (!this._delta) return;
					this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					const i$1 = n.mousePos(this._map.getCanvas(), e$1), o$1 = this._tr;
					this._aroundPoint = this._aroundCenter ? o$1.transform.locationToScreenPoint(t.S.convert(o$1.center)) : i$1, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId) return;
					if (this._frameId = null, !this.isActive()) return;
					const e$1 = this._tr.transform;
					if ("number" == typeof this._lastExpectedZoom) {
						const t$1 = e$1.zoom - this._lastExpectedZoom;
						"number" == typeof this._startZoom && (this._startZoom += t$1), "number" == typeof this._targetZoom && (this._targetZoom += t$1);
					}
					if (0 !== this._delta) {
						const i$2 = "wheel" === this._type && Math.abs(this._delta) > fa ? this._wheelZoomRate : this._defaultZoomRate;
						let o$2 = 2 / (1 + Math.exp(-Math.abs(this._delta * i$2)));
						this._delta < 0 && 0 !== o$2 && (o$2 = 1 / o$2);
						const r$2 = "number" != typeof this._targetZoom ? e$1.scale : t.af(this._targetZoom);
						this._targetZoom = e$1.getConstrained(e$1.getCameraLngLat(), t.ak(r$2 * o$2)).zoom, "wheel" === this._type && (this._startZoom = e$1.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
					}
					const i$1 = "number" != typeof this._targetZoom ? e$1.zoom : this._targetZoom, o$1 = this._startZoom, r$1 = this._easing;
					let a$1, n$1 = !1;
					if ("wheel" === this._type && o$1 && r$1) {
						const e$2 = s.now() - this._lastWheelEventTime, l$1 = Math.min((e$2 + 5) / 200, 1), c$1 = r$1(l$1);
						a$1 = t.C.number(o$1, i$1, c$1), l$1 < 1 ? this._frameId || (this._frameId = !0) : n$1 = !0;
					} else a$1 = i$1, n$1 = !0;
					return this._active = !0, n$1 && (this._active = !1, this._finishTimeout = setTimeout((() => {
						this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
					}), 200)), this._lastExpectedZoom = a$1, {
						noInertia: !0,
						needsRenderFrame: !n$1,
						zoomDelta: a$1 - e$1.zoom,
						around: this._aroundPoint,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(e$1) {
					let i$1 = t.co;
					if (this._prevEase) {
						const e$2 = this._prevEase, o$1 = (s.now() - e$2.start) / e$2.duration, r$1 = e$2.easing(o$1 + .01) - e$2.easing(o$1), a$1 = .27 / Math.sqrt(r$1 * r$1 + 1e-4) * .01, n$1 = Math.sqrt(.0729 - a$1 * a$1);
						i$1 = t.cm(a$1, n$1, .25, 1);
					}
					return this._prevEase = {
						start: s.now(),
						duration: e$1,
						easing: i$1
					}, i$1;
				}
				reset() {
					this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
				}
			}
			class ba {
				constructor(e$1, t$1) {
					this._clickZoom = e$1, this._tapZoom = t$1;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class xa {
				constructor(e$1) {
					this._tr = new Vr(e$1), this.reset();
				}
				reset() {
					this._active = !1;
				}
				dblclick(e$1, t$1) {
					return e$1.preventDefault(), { cameraAnimation: (i$1) => {
						i$1.easeTo({
							duration: 300,
							zoom: this._tr.zoom + (e$1.shiftKey ? -1 : 1),
							around: this._tr.unproject(t$1)
						}, { originalEvent: e$1 });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class ya {
				constructor() {
					this._tap = new Hr({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
				}
				touchstart(e$1, t$1, i$1) {
					if (!this._swipePoint) if (this._tapTime) {
						const o$1 = t$1[0], r$1 = e$1.timeStamp - this._tapTime < 500, a$1 = this._tapPoint.dist(o$1) < 30;
						r$1 && a$1 ? i$1.length > 0 && (this._swipePoint = o$1, this._swipeTouch = i$1[0].identifier) : this.reset();
					} else this._tap.touchstart(e$1, t$1, i$1);
				}
				touchmove(e$1, t$1, i$1) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (i$1[0].identifier !== this._swipeTouch) return;
							const o$1 = t$1[0], r$1 = o$1.y - this._swipePoint.y;
							return this._swipePoint = o$1, e$1.preventDefault(), this._active = !0, { zoomDelta: r$1 / 128 };
						}
					} else this._tap.touchmove(e$1, t$1, i$1);
				}
				touchend(e$1, t$1, i$1) {
					if (this._tapTime) this._swipePoint && 0 === i$1.length && this.reset();
					else {
						const o$1 = this._tap.touchend(e$1, t$1, i$1);
						o$1 && (this._tapTime = e$1.timeStamp, this._tapPoint = o$1);
					}
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class wa {
				constructor(e$1, t$1, i$1) {
					this._el = e$1, this._mousePan = t$1, this._touchPan = i$1;
				}
				enable(e$1) {
					this._inertiaOptions = e$1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class Ta {
				constructor(e$1, t$1, i$1, o$1) {
					this._pitchWithRotate = e$1.pitchWithRotate, this._rollEnabled = e$1.rollEnabled, this._mouseRotate = t$1, this._mousePitch = i$1, this._mouseRoll = o$1;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
				}
			}
			class Pa {
				constructor(e$1, t$1, i$1, o$1) {
					this._el = e$1, this._touchZoom = t$1, this._touchRotate = i$1, this._tapDragZoom = o$1, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e$1) {
					this._touchZoom.enable(e$1), this._rotationDisabled || this._touchRotate.enable(e$1), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			class Ca {
				constructor(e$1, t$1) {
					this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e$1, this._options = t$1, this._enabled = !1;
				}
				isActive() {
					return !1;
				}
				reset() {}
				_setupUI() {
					if (this._container) return;
					const e$1 = this._map.getCanvasContainer();
					e$1.classList.add("maplibregl-cooperative-gestures"), this._container = n.create("div", "maplibregl-cooperative-gesture-screen", e$1);
					let t$1 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
					"metaKey" === this._bypassKey && (t$1 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
					const i$1 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), o$1 = document.createElement("div");
					o$1.className = "maplibregl-desktop-message", o$1.textContent = t$1, this._container.appendChild(o$1);
					const r$1 = document.createElement("div");
					r$1.className = "maplibregl-mobile-message", r$1.textContent = i$1, this._container.appendChild(r$1), this._container.setAttribute("aria-hidden", "true");
				}
				_destroyUI() {
					this._container && (n.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
				}
				enable() {
					this._setupUI(), this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this._destroyUI();
				}
				isEnabled() {
					return this._enabled;
				}
				isBypassed(e$1) {
					return e$1[this._bypassKey];
				}
				notifyGestureBlocked(e$1, i$1) {
					this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", {
						gestureType: e$1,
						originalEvent: i$1
					})), this._container.classList.add("maplibregl-show"), setTimeout((() => {
						this._container.classList.remove("maplibregl-show");
					}), 100));
				}
			}
			const Ia = (e$1) => e$1.zoom || e$1.drag || e$1.roll || e$1.pitch || e$1.rotate;
			class Ma extends t.l {}
			function Sa(e$1) {
				return e$1.panDelta && e$1.panDelta.mag() || e$1.zoomDelta || e$1.bearingDelta || e$1.pitchDelta || e$1.rollDelta;
			}
			class Ea {
				constructor(e$1, i$1) {
					this.handleWindowEvent = (e$2) => {
						this.handleEvent(e$2, `${e$2.type}Window`);
					}, this.handleEvent = (e$2, i$2) => {
						if ("blur" === e$2.type) return void this.stop(!0);
						this._updatingCamera = !0;
						const o$2 = "renderFrame" === e$2.type ? void 0 : e$2, r$1 = { needsRenderFrame: !1 }, a$1 = {}, s$1 = {};
						for (const { handlerName: l$2, handler: c$2, allowed: h$1 } of this._handlers) {
							if (!c$2.isEnabled()) continue;
							let u$1;
							if (this._blockedByActive(s$1, h$1, l$2)) c$2.reset();
							else if (c$2[i$2 || e$2.type]) {
								if (t.cp(e$2, i$2 || e$2.type)) {
									const t$1 = n.mousePos(this._map.getCanvas(), e$2);
									u$1 = c$2[i$2 || e$2.type](e$2, t$1);
								} else if (t.cq(e$2, i$2 || e$2.type)) {
									const t$1 = this._getMapTouches(e$2.touches), o$3 = n.touchPos(this._map.getCanvas(), t$1);
									u$1 = c$2[i$2 || e$2.type](e$2, o$3, t$1);
								} else t.cr(i$2 || e$2.type) || (u$1 = c$2[i$2 || e$2.type](e$2));
								this.mergeHandlerResult(r$1, a$1, u$1, l$2, o$2), u$1 && u$1.needsRenderFrame && this._triggerRenderFrame();
							}
							(u$1 || c$2.isActive()) && (s$1[l$2] = c$2);
						}
						const l$1 = {};
						for (const e$3 in this._previousActiveHandlers) s$1[e$3] || (l$1[e$3] = o$2);
						this._previousActiveHandlers = s$1, (Object.keys(l$1).length || Sa(r$1)) && (this._changes.push([
							r$1,
							a$1,
							l$1
						]), this._triggerRenderFrame()), (Object.keys(s$1).length || Sa(r$1)) && this._map._stop(!0), this._updatingCamera = !1;
						const { cameraAnimation: c$1 } = r$1;
						c$1 && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], c$1(this._map));
					}, this._map = e$1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Fr(e$1), this._bearingSnap = i$1.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i$1);
					const o$1 = this._el;
					this._listeners = [
						[
							o$1,
							"touchstart",
							{ passive: !0 }
						],
						[
							o$1,
							"touchmove",
							{ passive: !1 }
						],
						[
							o$1,
							"touchend",
							void 0
						],
						[
							o$1,
							"touchcancel",
							void 0
						],
						[
							o$1,
							"mousedown",
							void 0
						],
						[
							o$1,
							"mousemove",
							void 0
						],
						[
							o$1,
							"mouseup",
							void 0
						],
						[
							document,
							"mousemove",
							{ capture: !0 }
						],
						[
							document,
							"mouseup",
							void 0
						],
						[
							o$1,
							"mouseover",
							void 0
						],
						[
							o$1,
							"mouseout",
							void 0
						],
						[
							o$1,
							"dblclick",
							void 0
						],
						[
							o$1,
							"click",
							void 0
						],
						[
							o$1,
							"keydown",
							{ capture: !1 }
						],
						[
							o$1,
							"keyup",
							void 0
						],
						[
							o$1,
							"wheel",
							{ passive: !1 }
						],
						[
							o$1,
							"contextmenu",
							void 0
						],
						[
							window,
							"blur",
							void 0
						]
					];
					for (const [e$2, t$1, i$2] of this._listeners) n.addEventListener(e$2, t$1, e$2 === document ? this.handleWindowEvent : this.handleEvent, i$2);
				}
				destroy() {
					for (const [e$1, t$1, i$1] of this._listeners) n.removeEventListener(e$1, t$1, e$1 === document ? this.handleWindowEvent : this.handleEvent, i$1);
				}
				_addDefaultHandlers(e$1) {
					const i$1 = this._map, o$1 = i$1.getCanvasContainer();
					this._add("mapEvent", new Zr(i$1, e$1));
					const r$1 = i$1.boxZoom = new $r(i$1, e$1);
					this._add("boxZoom", r$1), e$1.interactive && e$1.boxZoom && r$1.enable();
					const a$1 = i$1.cooperativeGestures = new Ca(i$1, e$1.cooperativeGestures);
					this._add("cooperativeGestures", a$1), e$1.cooperativeGestures && a$1.enable();
					const s$1 = new Xr(i$1), l$1 = new xa(i$1);
					i$1.doubleClickZoom = new ba(l$1, s$1), this._add("tapZoom", s$1), this._add("clickZoom", l$1), e$1.interactive && e$1.doubleClickZoom && i$1.doubleClickZoom.enable();
					const c$1 = new ya();
					this._add("tapDragZoom", c$1);
					const h$1 = i$1.touchPitch = new da(i$1);
					this._add("touchPitch", h$1), e$1.interactive && e$1.touchPitch && i$1.touchPitch.enable(e$1.touchPitch);
					const u$1 = () => i$1.project(i$1.getCenter()), d$1 = function({ enable: e$2, clickTolerance: i$2, aroundCenter: o$2 = !0, minPixelCenterThreshold: r$2 = 100, rotateDegreesPerPixelMoved: a$2 = .8 }, s$2) {
						const l$2 = new ea({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && e$3.ctrlKey || 2 === n.mouseButton(e$3) && !e$3.ctrlKey });
						return new Kr({
							clickTolerance: i$2,
							move: (e$3, i$3) => {
								const n$1 = s$2();
								if (o$2 && Math.abs(n$1.y - e$3.y) > r$2) return { bearingDelta: t.cn(new t.P(e$3.x, i$3.y), i$3, n$1) };
								let l$3 = (i$3.x - e$3.x) * a$2;
								return o$2 && i$3.y < n$1.y && (l$3 = -l$3), { bearingDelta: l$3 };
							},
							moveStateManager: l$2,
							enable: e$2,
							assignEvents: oa
						});
					}(e$1, u$1), _$1 = function({ enable: e$2, clickTolerance: t$1, pitchDegreesPerPixelMoved: i$2 = -.5 }) {
						const o$2 = new ea({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && e$3.ctrlKey || 2 === n.mouseButton(e$3) });
						return new Kr({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({ pitchDelta: (t$2.y - e$3.y) * i$2 }),
							moveStateManager: o$2,
							enable: e$2,
							assignEvents: oa
						});
					}(e$1), p$1 = function({ enable: e$2, clickTolerance: t$1, rollDegreesPerPixelMoved: i$2 = .3 }, o$2) {
						const r$2 = new ea({ checkCorrectEvent: (e$3) => 2 === n.mouseButton(e$3) && e$3.ctrlKey });
						return new Kr({
							clickTolerance: t$1,
							move: (e$3, t$2) => {
								const r$3 = o$2();
								let a$2 = (t$2.x - e$3.x) * i$2;
								return t$2.y < r$3.y && (a$2 = -a$2), { rollDelta: a$2 };
							},
							moveStateManager: r$2,
							enable: e$2,
							assignEvents: oa
						});
					}(e$1, u$1);
					i$1.dragRotate = new Ta(e$1, d$1, _$1, p$1), this._add("mouseRotate", d$1, ["mousePitch"]), this._add("mousePitch", _$1, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p$1, ["mousePitch"]), e$1.interactive && e$1.dragRotate && i$1.dragRotate.enable();
					const m$1 = function({ enable: e$2, clickTolerance: t$1 }) {
						const i$2 = new ea({ checkCorrectEvent: (e$3) => 0 === n.mouseButton(e$3) && !e$3.ctrlKey });
						return new Kr({
							clickTolerance: t$1,
							move: (e$3, t$2) => ({
								around: t$2,
								panDelta: t$2.sub(e$3)
							}),
							activateOnStart: !0,
							moveStateManager: i$2,
							enable: e$2,
							assignEvents: oa
						});
					}(e$1), f$1 = new ra(e$1, i$1);
					i$1.dragPan = new wa(o$1, m$1, f$1), this._add("mousePan", m$1), this._add("touchPan", f$1, ["touchZoom", "touchRotate"]), e$1.interactive && e$1.dragPan && i$1.dragPan.enable(e$1.dragPan);
					const g$1 = new ha(), v$1 = new la();
					i$1.touchZoomRotate = new Pa(o$1, v$1, g$1, c$1), this._add("touchRotate", g$1, ["touchPan", "touchZoom"]), this._add("touchZoom", v$1, ["touchPan", "touchRotate"]), e$1.interactive && e$1.touchZoomRotate && i$1.touchZoomRotate.enable(e$1.touchZoomRotate);
					const b$1 = i$1.scrollZoom = new va(i$1, (() => this._triggerRenderFrame()));
					this._add("scrollZoom", b$1, ["mousePan"]), e$1.interactive && e$1.scrollZoom && i$1.scrollZoom.enable(e$1.scrollZoom);
					const x$1 = i$1.keyboard = new pa(i$1);
					this._add("keyboard", x$1), e$1.interactive && e$1.keyboard && i$1.keyboard.enable(), this._add("blockableMapEvent", new Gr(i$1));
				}
				_add(e$1, t$1, i$1) {
					this._handlers.push({
						handlerName: e$1,
						handler: t$1,
						allowed: i$1
					}), this._handlersById[e$1] = t$1;
				}
				stop(e$1) {
					if (!this._updatingCamera) {
						for (const { handler: e$2 } of this._handlers) e$2.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e$1), this._changes = [];
					}
				}
				isActive() {
					for (const { handler: e$1 } of this._handlers) if (e$1.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return Boolean(Ia(this._eventsInProgress)) || this.isZooming();
				}
				_blockedByActive(e$1, t$1, i$1) {
					for (const o$1 in e$1) if (o$1 !== i$1 && (!t$1 || t$1.indexOf(o$1) < 0)) return !0;
					return !1;
				}
				_getMapTouches(e$1) {
					const t$1 = [];
					for (const i$1 of e$1) this._el.contains(i$1.target) && t$1.push(i$1);
					return t$1;
				}
				mergeHandlerResult(e$1, i$1, o$1, r$1, a$1) {
					if (!o$1) return;
					t.e(e$1, o$1);
					const s$1 = {
						handlerName: r$1,
						originalEvent: o$1.originalEvent || a$1
					};
					void 0 !== o$1.zoomDelta && (i$1.zoom = s$1), void 0 !== o$1.panDelta && (i$1.drag = s$1), void 0 !== o$1.rollDelta && (i$1.roll = s$1), void 0 !== o$1.pitchDelta && (i$1.pitch = s$1), void 0 !== o$1.bearingDelta && (i$1.rotate = s$1);
				}
				_applyChanges() {
					const e$1 = {}, i$1 = {}, o$1 = {};
					for (const [r$1, a$1, s$1] of this._changes) r$1.panDelta && (e$1.panDelta = (e$1.panDelta || new t.P(0, 0))._add(r$1.panDelta)), r$1.zoomDelta && (e$1.zoomDelta = (e$1.zoomDelta || 0) + r$1.zoomDelta), r$1.bearingDelta && (e$1.bearingDelta = (e$1.bearingDelta || 0) + r$1.bearingDelta), r$1.pitchDelta && (e$1.pitchDelta = (e$1.pitchDelta || 0) + r$1.pitchDelta), r$1.rollDelta && (e$1.rollDelta = (e$1.rollDelta || 0) + r$1.rollDelta), void 0 !== r$1.around && (e$1.around = r$1.around), void 0 !== r$1.pinchAround && (e$1.pinchAround = r$1.pinchAround), r$1.noInertia && (e$1.noInertia = r$1.noInertia), t.e(i$1, a$1), t.e(o$1, s$1);
					this._updateMapTransform(e$1, i$1, o$1), this._changes = [];
				}
				_updateMapTransform(e$1, t$1, i$1) {
					const o$1 = this._map, r$1 = o$1._getTransformForUpdate(), a$1 = o$1.terrain;
					if (!(Sa(e$1) || a$1 && this._terrainMovement)) return this._fireEvents(t$1, i$1, !0);
					o$1._stop(!0);
					let { panDelta: s$1, zoomDelta: n$1, bearingDelta: l$1, pitchDelta: c$1, rollDelta: h$1, around: u$1, pinchAround: d$1 } = e$1;
					void 0 !== d$1 && (u$1 = d$1), u$1 = u$1 || o$1.transform.centerPoint, a$1 && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const _$1 = {
						panDelta: s$1,
						zoomDelta: n$1,
						rollDelta: h$1,
						pitchDelta: c$1,
						bearingDelta: l$1,
						around: u$1
					};
					this._map.cameraHelper.useGlobeControls && !r$1.isPointOnMapSurface(u$1) && (u$1 = r$1.centerPoint);
					const p$1 = u$1.distSqr(r$1.centerPoint) < .01 ? r$1.center : r$1.screenPointToLocation(s$1 ? u$1.sub(s$1) : u$1);
					this._handleMapControls({
						terrain: a$1,
						tr: r$1,
						deltasForHelper: _$1,
						preZoomAroundLoc: p$1,
						combinedEventsInProgress: t$1,
						panDelta: s$1
					}), o$1._applyUpdatedTransform(r$1), this._map._update(), e$1.noInertia || this._inertia.record(e$1), this._fireEvents(t$1, i$1, !0);
				}
				_handleMapControls({ terrain: e$1, tr: t$1, deltasForHelper: i$1, preZoomAroundLoc: o$1, combinedEventsInProgress: r$1, panDelta: a$1 }) {
					const s$1 = this._map.cameraHelper;
					if (s$1.handleMapControlsRollPitchBearingZoom(i$1, t$1), e$1) return s$1.useGlobeControls ? (this._terrainMovement || !r$1.drag && !r$1.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void s$1.handleMapControlsPan(i$1, t$1, o$1)) : this._terrainMovement || !r$1.drag && !r$1.zoom ? void (r$1.drag && this._terrainMovement && a$1 ? t$1.setCenter(t$1.screenPointToLocation(t$1.centerPoint.sub(a$1))) : s$1.handleMapControlsPan(i$1, t$1, o$1)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void s$1.handleMapControlsPan(i$1, t$1, o$1));
					s$1.handleMapControlsPan(i$1, t$1, o$1);
				}
				_fireEvents(e$1, i$1, o$1) {
					const r$1 = Ia(this._eventsInProgress), a$1 = Ia(e$1), n$1 = {};
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._eventsInProgress[t$1] || (n$1[`${t$1}start`] = i$2), this._eventsInProgress[t$1] = e$1[t$1];
					}
					!r$1 && a$1 && this._fireEvent("movestart", a$1.originalEvent);
					for (const e$2 in n$1) this._fireEvent(e$2, n$1[e$2]);
					a$1 && this._fireEvent("move", a$1.originalEvent);
					for (const t$1 in e$1) {
						const { originalEvent: i$2 } = e$1[t$1];
						this._fireEvent(t$1, i$2);
					}
					const l$1 = {};
					let c$1;
					for (const e$2 in this._eventsInProgress) {
						const { handlerName: t$1, originalEvent: o$2 } = this._eventsInProgress[e$2];
						this._handlersById[t$1].isActive() || (delete this._eventsInProgress[e$2], c$1 = i$1[t$1] || o$2, l$1[`${e$2}end`] = c$1);
					}
					for (const e$2 in l$1) this._fireEvent(e$2, l$1[e$2]);
					const h$1 = Ia(this._eventsInProgress), u$1 = (r$1 || a$1) && !h$1;
					if (u$1 && this._terrainMovement) {
						this._map._elevationFreeze = !1, this._terrainMovement = !1;
						const e$2 = this._map._getTransformForUpdate();
						this._map.getCenterClampedToGround() && e$2.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e$2);
					}
					if (o$1 && u$1) {
						this._updatingCamera = !0;
						const e$2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i$2 = (e$3) => 0 !== e$3 && -this._bearingSnap < e$3 && e$3 < this._bearingSnap;
						!e$2 || !e$2.essential && s.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c$1 })), i$2(this._map.getBearing()) && this._map.resetNorth()) : (i$2(e$2.bearing || this._map.getBearing()) && (e$2.bearing = 0), e$2.freezeElevation = !0, this._map.easeTo(e$2, { originalEvent: c$1 })), this._updatingCamera = !1;
					}
				}
				_fireEvent(e$1, i$1) {
					this._map.fire(new t.l(e$1, i$1 ? { originalEvent: i$1 } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e$1) => {
						delete this._frameId, this.handleEvent(new Ma("renderFrame", { timeStamp: e$1 })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					void 0 === this._frameId && (this._frameId = this._requestFrame());
				}
			}
			class Ra extends t.E {
				constructor(e$1, t$1, i$1) {
					super(), this._renderFrameCallback = () => {
						const e$2 = Math.min((s.now() - this._easeStart) / this._easeOptions.duration, 1);
						this._onEaseFrame(this._easeOptions.easing(e$2)), e$2 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
					}, this._moving = !1, this._zooming = !1, this.transform = e$1, this._bearingSnap = i$1.bearingSnap, this.cameraHelper = t$1, this.on("moveend", (() => {
						delete this._requestedCameraState;
					}));
				}
				migrateProjection(e$1, t$1) {
					e$1.apply(this.transform), this.transform = e$1, this.cameraHelper = t$1;
				}
				getCenter() {
					return new t.S(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e$1, t$1) {
					return this.jumpTo({ center: e$1 }, t$1);
				}
				getCenterElevation() {
					return this.transform.elevation;
				}
				setCenterElevation(e$1, t$1) {
					return this.jumpTo({ elevation: e$1 }, t$1), this;
				}
				getCenterClampedToGround() {
					return this._centerClampedToGround;
				}
				setCenterClampedToGround(e$1) {
					this._centerClampedToGround = e$1;
				}
				panBy(e$1, i$1, o$1) {
					return e$1 = t.P.convert(e$1).mult(-1), this.panTo(this.transform.center, t.e({ offset: e$1 }, i$1), o$1);
				}
				panTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ center: e$1 }, i$1), o$1);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e$1, t$1) {
					return this.jumpTo({ zoom: e$1 }, t$1), this;
				}
				zoomTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ zoom: e$1 }, i$1), o$1);
				}
				zoomIn(e$1, t$1) {
					return this.zoomTo(this.getZoom() + 1, e$1, t$1), this;
				}
				zoomOut(e$1, t$1) {
					return this.zoomTo(this.getZoom() - 1, e$1, t$1), this;
				}
				getVerticalFieldOfView() {
					return this.transform.fov;
				}
				setVerticalFieldOfView(e$1, i$1) {
					return e$1 != this.transform.fov && (this.transform.setFov(e$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)).fire(new t.l("moveend", i$1))), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setBearing(e$1, t$1) {
					return this.jumpTo({ bearing: e$1 }, t$1), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e$1, t$1) {
					return this.jumpTo({ padding: e$1 }, t$1), this;
				}
				rotateTo(e$1, i$1, o$1) {
					return this.easeTo(t.e({ bearing: e$1 }, i$1), o$1);
				}
				resetNorth(e$1, i$1) {
					return this.rotateTo(0, t.e({ duration: 1e3 }, e$1), i$1), this;
				}
				resetNorthPitch(e$1, i$1) {
					return this.easeTo(t.e({
						bearing: 0,
						pitch: 0,
						roll: 0,
						duration: 1e3
					}, e$1), i$1), this;
				}
				snapToNorth(e$1, t$1) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e$1, t$1) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e$1, t$1) {
					return this.jumpTo({ pitch: e$1 }, t$1), this;
				}
				getRoll() {
					return this.transform.roll;
				}
				setRoll(e$1, t$1) {
					return this.jumpTo({ roll: e$1 }, t$1), this;
				}
				cameraForBounds(e$1, t$1) {
					e$1 = G.convert(e$1).adjustAntiMeridian();
					const i$1 = t$1 && t$1.bearing || 0;
					return this._cameraForBoxAndBearing(e$1.getNorthWest(), e$1.getSouthEast(), i$1, t$1);
				}
				_cameraForBoxAndBearing(e$1, i$1, o$1, r$1) {
					const a$1 = {
						top: 0,
						bottom: 0,
						right: 0,
						left: 0
					};
					if ("number" == typeof (r$1 = t.e({
						padding: a$1,
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, r$1)).padding) {
						const e$2 = r$1.padding;
						r$1.padding = {
							top: e$2,
							bottom: e$2,
							right: e$2,
							left: e$2
						};
					}
					const s$1 = t.e(a$1, r$1.padding);
					r$1.padding = s$1;
					const n$1 = this.transform, l$1 = new G(e$1, i$1);
					return this.cameraHelper.cameraForBoxAndBearing(r$1, s$1, l$1, o$1, n$1);
				}
				fitBounds(e$1, t$1, i$1) {
					return this._fitInternal(this.cameraForBounds(e$1, t$1), t$1, i$1);
				}
				fitScreenCoordinates(e$1, i$1, o$1, r$1, a$1) {
					return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e$1)), this.transform.screenPointToLocation(t.P.convert(i$1)), o$1, r$1), r$1, a$1);
				}
				_fitInternal(e$1, i$1, o$1) {
					return e$1 ? (delete (i$1 = t.e(e$1, i$1)).padding, i$1.linear ? this.easeTo(i$1, o$1) : this.flyTo(i$1, o$1)) : this;
				}
				jumpTo(e$1, i$1) {
					this.stop();
					const o$1 = this._getTransformForUpdate();
					let r$1 = !1, a$1 = !1, s$1 = !1;
					const n$1 = o$1.zoom;
					this.cameraHelper.handleJumpToCenterZoom(o$1, e$1);
					const l$1 = o$1.zoom !== n$1;
					return "elevation" in e$1 && o$1.elevation !== +e$1.elevation && o$1.setElevation(+e$1.elevation), "bearing" in e$1 && o$1.bearing !== +e$1.bearing && (r$1 = !0, o$1.setBearing(+e$1.bearing)), "pitch" in e$1 && o$1.pitch !== +e$1.pitch && (a$1 = !0, o$1.setPitch(+e$1.pitch)), "roll" in e$1 && o$1.roll !== +e$1.roll && (s$1 = !0, o$1.setRoll(+e$1.roll)), null == e$1.padding || o$1.isPaddingEqual(e$1.padding) || o$1.setPadding(e$1.padding), this._applyUpdatedTransform(o$1), this.fire(new t.l("movestart", i$1)).fire(new t.l("move", i$1)), l$1 && this.fire(new t.l("zoomstart", i$1)).fire(new t.l("zoom", i$1)).fire(new t.l("zoomend", i$1)), r$1 && this.fire(new t.l("rotatestart", i$1)).fire(new t.l("rotate", i$1)).fire(new t.l("rotateend", i$1)), a$1 && this.fire(new t.l("pitchstart", i$1)).fire(new t.l("pitch", i$1)).fire(new t.l("pitchend", i$1)), s$1 && this.fire(new t.l("rollstart", i$1)).fire(new t.l("roll", i$1)).fire(new t.l("rollend", i$1)), this.fire(new t.l("moveend", i$1));
				}
				calculateCameraOptionsFromTo(e$1, i$1, o$1, r$1 = 0) {
					const a$1 = t.a1.fromLngLat(e$1, i$1), s$1 = t.a1.fromLngLat(o$1, r$1), n$1 = s$1.x - a$1.x, l$1 = s$1.y - a$1.y, c$1 = s$1.z - a$1.z, h$1 = Math.hypot(n$1, l$1, c$1);
					if (0 === h$1) throw new Error("Can't calculate camera options with same From and To");
					const u$1 = Math.hypot(n$1, l$1), d$1 = t.ak(this.transform.cameraToCenterDistance / h$1 / this.transform.tileSize), _$1 = 180 * Math.atan2(n$1, -l$1) / Math.PI;
					let p$1 = 180 * Math.acos(u$1 / h$1) / Math.PI;
					return p$1 = c$1 < 0 ? 90 - p$1 : 90 + p$1, {
						center: s$1.toLngLat(),
						elevation: r$1,
						zoom: d$1,
						pitch: p$1,
						bearing: _$1
					};
				}
				calculateCameraOptionsFromCameraLngLatAltRotation(e$1, t$1, i$1, o$1, r$1) {
					const a$1 = this.transform.calculateCenterFromCameraLngLatAlt(e$1, t$1, i$1, o$1);
					return {
						center: a$1.center,
						elevation: a$1.elevation,
						zoom: a$1.zoom,
						bearing: i$1,
						pitch: o$1,
						roll: r$1
					};
				}
				easeTo(e$1, i$1) {
					this._stop(!1, e$1.easeId), (!1 === (e$1 = t.e({
						offset: [0, 0],
						duration: 500,
						easing: t.co
					}, e$1)).animate || !e$1.essential && s.prefersReducedMotion) && (e$1.duration = 0);
					const o$1 = this._getTransformForUpdate(), r$1 = this.getBearing(), a$1 = o$1.pitch, n$1 = o$1.roll, l$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, c$1 = "pitch" in e$1 ? +e$1.pitch : a$1, h$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, n$1) : n$1, u$1 = "padding" in e$1 ? e$1.padding : o$1.padding, d$1 = t.P.convert(e$1.offset);
					let _$1, p$1;
					e$1.around && (_$1 = t.S.convert(e$1.around), p$1 = o$1.locationToScreenPoint(_$1));
					const m$1 = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching,
						rolling: this._rolling
					}, f$1 = this.cameraHelper.handleEaseTo(o$1, {
						bearing: l$1,
						pitch: c$1,
						roll: h$1,
						padding: u$1,
						around: _$1,
						aroundPoint: p$1,
						offsetAsPoint: d$1,
						offset: e$1.offset,
						zoom: e$1.zoom,
						center: e$1.center
					});
					return this._rotating = this._rotating || r$1 !== l$1, this._pitching = this._pitching || c$1 !== a$1, this._rolling = this._rolling || h$1 !== n$1, this._padding = !o$1.isPaddingEqual(u$1), this._zooming = this._zooming || f$1.isZooming, this._easeId = e$1.easeId, this._prepareEase(i$1, e$1.noMoveStart, m$1), this.terrain && this._prepareElevation(f$1.elevationCenter), this._ease(((t$1) => {
						f$1.easeFunc(t$1), this.terrain && !e$1.freezeElevation && this._updateElevation(t$1), this._applyUpdatedTransform(o$1), this._fireMoveEvents(i$1);
					}), ((t$1) => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1, t$1);
					}), e$1), this;
				}
				_prepareEase(e$1, i$1, o$1 = {}) {
					this._moving = !0, i$1 || o$1.moving || this.fire(new t.l("movestart", e$1)), this._zooming && !o$1.zooming && this.fire(new t.l("zoomstart", e$1)), this._rotating && !o$1.rotating && this.fire(new t.l("rotatestart", e$1)), this._pitching && !o$1.pitching && this.fire(new t.l("pitchstart", e$1)), this._rolling && !o$1.rolling && this.fire(new t.l("rollstart", e$1));
				}
				_prepareElevation(e$1) {
					this._elevationCenter = e$1, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e$1, this.transform.tileZoom), this._elevationFreeze = !0;
				}
				_updateElevation(e$1) {
					void 0 !== this._elevationStart && void 0 !== this._elevationCenter || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
					const i$1 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
					if (e$1 < 1 && i$1 !== this._elevationTarget) {
						const t$1 = this._elevationTarget - this._elevationStart;
						this._elevationStart += e$1 * (t$1 - (i$1 - (t$1 * e$1 + this._elevationStart)) / (1 - e$1)), this._elevationTarget = i$1;
					}
					this.transform.setElevation(t.C.number(this._elevationStart, this._elevationTarget, e$1));
				}
				_finalizeElevation() {
					this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
				}
				_getTransformForUpdate() {
					return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
				}
				_elevateCameraIfInsideTerrain(e$1) {
					if (!this.terrain && e$1.elevation >= 0 && e$1.pitch <= 90) return {};
					const t$1 = e$1.getCameraLngLat(), i$1 = e$1.getCameraAltitude(), o$1 = this.terrain ? this.terrain.getElevationForLngLatZoom(t$1, e$1.zoom) : 0;
					if (i$1 < o$1) {
						const i$2 = this.calculateCameraOptionsFromTo(t$1, o$1, e$1.center, e$1.elevation);
						return {
							pitch: i$2.pitch,
							zoom: i$2.zoom
						};
					}
					return {};
				}
				_applyUpdatedTransform(e$1) {
					const t$1 = [];
					if (t$1.push(((e$2) => this._elevateCameraIfInsideTerrain(e$2))), this.transformCameraUpdate && t$1.push(((e$2) => this.transformCameraUpdate(e$2))), !t$1.length) return;
					const i$1 = e$1.clone();
					for (const e$2 of t$1) {
						const t$2 = i$1.clone(), { center: o$1, zoom: r$1, roll: a$1, pitch: s$1, bearing: n$1, elevation: l$1 } = e$2(t$2);
						o$1 && t$2.setCenter(o$1), void 0 !== l$1 && t$2.setElevation(l$1), void 0 !== r$1 && t$2.setZoom(r$1), void 0 !== a$1 && t$2.setRoll(a$1), void 0 !== s$1 && t$2.setPitch(s$1), void 0 !== n$1 && t$2.setBearing(n$1), i$1.apply(t$2);
					}
					this.transform.apply(i$1);
				}
				_fireMoveEvents(e$1) {
					this.fire(new t.l("move", e$1)), this._zooming && this.fire(new t.l("zoom", e$1)), this._rotating && this.fire(new t.l("rotate", e$1)), this._pitching && this.fire(new t.l("pitch", e$1)), this._rolling && this.fire(new t.l("roll", e$1));
				}
				_afterEase(e$1, i$1) {
					if (this._easeId && i$1 && this._easeId === i$1) return;
					delete this._easeId;
					const o$1 = this._zooming, r$1 = this._rotating, a$1 = this._pitching, s$1 = this._rolling;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o$1 && this.fire(new t.l("zoomend", e$1)), r$1 && this.fire(new t.l("rotateend", e$1)), a$1 && this.fire(new t.l("pitchend", e$1)), s$1 && this.fire(new t.l("rollend", e$1)), this.fire(new t.l("moveend", e$1));
				}
				flyTo(e$1, i$1) {
					if (!e$1.essential && s.prefersReducedMotion) {
						const o$2 = t.Q(e$1, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"roll",
							"elevation"
						]);
						return this.jumpTo(o$2, i$1);
					}
					this.stop(), e$1 = t.e({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: t.co
					}, e$1);
					const o$1 = this._getTransformForUpdate(), r$1 = o$1.bearing, a$1 = o$1.pitch, n$1 = o$1.roll, l$1 = o$1.padding, c$1 = "bearing" in e$1 ? this._normalizeBearing(e$1.bearing, r$1) : r$1, h$1 = "pitch" in e$1 ? +e$1.pitch : a$1, u$1 = "roll" in e$1 ? this._normalizeBearing(e$1.roll, n$1) : n$1, d$1 = "padding" in e$1 ? e$1.padding : o$1.padding, _$1 = t.P.convert(e$1.offset);
					let p$1 = o$1.centerPoint.add(_$1);
					const m$1 = o$1.screenPointToLocation(p$1), f$1 = this.cameraHelper.handleFlyTo(o$1, {
						bearing: c$1,
						pitch: h$1,
						roll: u$1,
						padding: d$1,
						locationAtOffset: m$1,
						offsetAsPoint: _$1,
						center: e$1.center,
						minZoom: e$1.minZoom,
						zoom: e$1.zoom
					});
					let g$1 = e$1.curve;
					const v$1 = Math.max(o$1.width, o$1.height), b$1 = v$1 / f$1.scaleOfZoom, x$1 = f$1.pixelPathLength;
					"number" == typeof f$1.scaleOfMinZoom && (g$1 = Math.sqrt(v$1 / f$1.scaleOfMinZoom / x$1 * 2));
					const y$1 = g$1 * g$1;
					function w$1(e$2) {
						const t$1 = (b$1 * b$1 - v$1 * v$1 + (e$2 ? -1 : 1) * y$1 * y$1 * x$1 * x$1) / (2 * (e$2 ? b$1 : v$1) * y$1 * x$1);
						return Math.log(Math.sqrt(t$1 * t$1 + 1) - t$1);
					}
					function T$1(e$2) {
						return (Math.exp(e$2) - Math.exp(-e$2)) / 2;
					}
					function P$1(e$2) {
						return (Math.exp(e$2) + Math.exp(-e$2)) / 2;
					}
					const C$1 = w$1(!1);
					let I$1 = function(e$2) {
						return P$1(C$1) / P$1(C$1 + g$1 * e$2);
					}, M$1 = function(e$2) {
						return v$1 * ((P$1(C$1) * (T$1(t$1 = C$1 + g$1 * e$2) / P$1(t$1)) - T$1(C$1)) / y$1) / x$1;
						var t$1;
					}, S$1 = (w$1(!0) - C$1) / g$1;
					if (Math.abs(x$1) < 2e-6 || !isFinite(S$1)) {
						if (Math.abs(v$1 - b$1) < 1e-6) return this.easeTo(e$1, i$1);
						const t$1 = b$1 < v$1 ? -1 : 1;
						S$1 = Math.abs(Math.log(b$1 / v$1)) / g$1, M$1 = () => 0, I$1 = (e$2) => Math.exp(t$1 * g$1 * e$2);
					}
					return e$1.duration = "duration" in e$1 ? +e$1.duration : 1e3 * S$1 / ("screenSpeed" in e$1 ? +e$1.screenSpeed / g$1 : +e$1.speed), e$1.maxDuration && e$1.duration > e$1.maxDuration && (e$1.duration = 0), this._zooming = !0, this._rotating = r$1 !== c$1, this._pitching = h$1 !== a$1, this._rolling = u$1 !== n$1, this._padding = !o$1.isPaddingEqual(d$1), this._prepareEase(i$1, !1), this.terrain && this._prepareElevation(f$1.targetCenter), this._ease(((s$1) => {
						const m$2 = s$1 * S$1, g$2 = 1 / I$1(m$2), v$2 = M$1(m$2);
						this._rotating && o$1.setBearing(t.C.number(r$1, c$1, s$1)), this._pitching && o$1.setPitch(t.C.number(a$1, h$1, s$1)), this._rolling && o$1.setRoll(t.C.number(n$1, u$1, s$1)), this._padding && (o$1.interpolatePadding(l$1, d$1, s$1), p$1 = o$1.centerPoint.add(_$1)), f$1.easeFunc(s$1, g$2, v$2, p$1), this.terrain && !e$1.freezeElevation && this._updateElevation(s$1), this._applyUpdatedTransform(o$1), this._fireMoveEvents(i$1);
					}), (() => {
						this.terrain && e$1.freezeElevation && this._finalizeElevation(), this._afterEase(i$1);
					}), e$1), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_stop(e$1, t$1) {
					var i$1;
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
						const e$2 = this._onEaseEnd;
						delete this._onEaseEnd, e$2.call(this, t$1);
					}
					return e$1 || null === (i$1 = this.handlers) || void 0 === i$1 || i$1.stop(!1), this;
				}
				_ease(e$1, t$1, i$1) {
					!1 === i$1.animate || 0 === i$1.duration ? (e$1(1), t$1()) : (this._easeStart = s.now(), this._easeOptions = i$1, this._onEaseFrame = e$1, this._onEaseEnd = t$1, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_normalizeBearing(e$1, i$1) {
					e$1 = t.aO(e$1, -180, 180);
					const o$1 = Math.abs(e$1 - i$1);
					return Math.abs(e$1 - 360 - i$1) < o$1 && (e$1 -= 360), Math.abs(e$1 + 360 - i$1) < o$1 && (e$1 += 360), e$1;
				}
				queryTerrainElevation(e$1) {
					return this.terrain ? this.terrain.getElevationForLngLatZoom(t.S.convert(e$1), this.transform.tileZoom) : null;
				}
			}
			const za = {
				compact: !0,
				customAttribution: "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>"
			};
			class Da {
				constructor(e$1 = za) {
					this._toggleAttribution = () => {
						this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
					}, this._updateData = (e$2) => {
						!e$2 || "metadata" !== e$2.sourceDataType && "visibility" !== e$2.sourceDataType && "style" !== e$2.dataType && "terrain" !== e$2.type || this._updateAttributions();
					}, this._updateCompact = () => {
						this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
					}, this._updateCompactMinimize = () => {
						this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e$1) {
					return this._map = e$1, this._compact = this.options.compact, this._container = n.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
				}
				_setElementTitle(e$1, t$1) {
					const i$1 = this._map._getUIString(`AttributionControl.${t$1}`);
					e$1.title = i$1, e$1.setAttribute("aria-label", i$1);
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e$1 = [];
					if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e$1 = e$1.concat(this.options.customAttribution.map(((e$2) => "string" != typeof e$2 ? "" : e$2))) : "string" == typeof this.options.customAttribution && e$1.push(this.options.customAttribution)), this._map.style.stylesheet) {
						const e$2 = this._map.style.stylesheet;
						this.styleOwner = e$2.owner, this.styleId = e$2.id;
					}
					const t$1 = this._map.style.sourceCaches;
					for (const i$2 in t$1) {
						const o$1 = t$1[i$2];
						if (o$1.used || o$1.usedForTerrain) {
							const t$2 = o$1.getSource();
							t$2.attribution && e$1.indexOf(t$2.attribution) < 0 && e$1.push(t$2.attribution);
						}
					}
					e$1 = e$1.filter(((e$2) => String(e$2).trim())), e$1.sort(((e$2, t$2) => e$2.length - t$2.length)), e$1 = e$1.filter(((t$2, i$2) => {
						for (let o$1 = i$2 + 1; o$1 < e$1.length; o$1++) if (e$1[o$1].indexOf(t$2) >= 0) return !1;
						return !0;
					}));
					const i$1 = e$1.join(" | ");
					i$1 !== this._attribHTML && (this._attribHTML = i$1, e$1.length ? (this._innerContainer.innerHTML = n.sanitize(i$1), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
				}
			}
			class Aa {
				constructor(e$1 = {}) {
					this._updateCompact = () => {
						const e$2 = this._container.children;
						if (e$2.length) {
							const t$1 = e$2[0];
							this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t$1.classList.add("maplibregl-compact") : t$1.classList.remove("maplibregl-compact");
						}
					}, this.options = e$1;
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					this._map = e$1, this._compact = this.options && this.options.compact, this._container = n.create("div", "maplibregl-ctrl");
					const t$1 = n.create("a", "maplibregl-ctrl-logo");
					return t$1.target = "_blank", t$1.rel = "noopener nofollow", t$1.href = "https://maplibre.org/", t$1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t$1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t$1), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
				}
			}
			class La {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e$1) {
					const t$1 = ++this._id;
					return this._queue.push({
						callback: e$1,
						id: t$1,
						cancelled: !1
					}), t$1;
				}
				remove(e$1) {
					const t$1 = this._currentlyRunning, i$1 = t$1 ? this._queue.concat(t$1) : this._queue;
					for (const t$2 of i$1) if (t$2.id === e$1) return void (t$2.cancelled = !0);
				}
				run(e$1 = 0) {
					if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
					const t$1 = this._currentlyRunning = this._queue;
					this._queue = [];
					for (const i$1 of t$1) if (!i$1.cancelled && (i$1.callback(e$1), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			var ka = t.aJ([{
				name: "a_pos3d",
				type: "Int16",
				components: 3
			}]);
			class Fa extends t.E {
				constructor(e$1) {
					super(), this._lastTilesetChange = s.now(), this.sourceCache = e$1, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e$1._source.tileSize * 2 ** this.deltaZoom, e$1.usedForTerrain = !0, e$1.tileSize = this.tileSize;
				}
				destruct() {
					this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
				}
				update(e$1, i$1) {
					this.sourceCache.update(e$1, i$1), this._renderableTilesKeys = [];
					const o$1 = {};
					for (const r$1 of ve(e$1, {
						tileSize: this.tileSize,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						reparseOverscaled: !1,
						terrain: i$1,
						calculateTileZoom: this.sourceCache._source.calculateTileZoom
					})) o$1[r$1.key] = !0, this._renderableTilesKeys.push(r$1.key), this._tiles[r$1.key] || (r$1.terrainRttPosMatrix32f = new Float64Array(16), t.bY(r$1.terrainRttPosMatrix32f, 0, t.$, t.$, 0, 0, 1), this._tiles[r$1.key] = new re(r$1, this.tileSize), this._lastTilesetChange = s.now());
					for (const e$2 in this._tiles) o$1[e$2] || delete this._tiles[e$2];
				}
				freeRtt(e$1) {
					for (const t$1 in this._tiles) {
						const i$1 = this._tiles[t$1];
						(!e$1 || i$1.tileID.equals(e$1) || i$1.tileID.isChildOf(e$1) || e$1.isChildOf(i$1.tileID)) && (i$1.rtt = []);
					}
				}
				getRenderableTiles() {
					return this._renderableTilesKeys.map(((e$1) => this.getTileByID(e$1)));
				}
				getTileByID(e$1) {
					return this._tiles[e$1];
				}
				getTerrainCoords(e$1, t$1) {
					return t$1 ? this._getTerrainCoordsForTileRanges(e$1, t$1) : this._getTerrainCoordsForRegularTile(e$1);
				}
				_getTerrainCoordsForRegularTile(e$1) {
					const i$1 = {};
					for (const o$1 of this._renderableTilesKeys) {
						const r$1 = this._tiles[o$1].tileID, a$1 = e$1.clone(), s$1 = t.ba();
						if (r$1.canonical.equals(e$1.canonical)) t.bY(s$1, 0, t.$, t.$, 0, 0, 1);
						else if (r$1.canonical.isChildOf(e$1.canonical)) {
							const i$2 = r$1.canonical.z - e$1.canonical.z, o$2 = r$1.canonical.x - (r$1.canonical.x >> i$2 << i$2), a$2 = r$1.canonical.y - (r$1.canonical.y >> i$2 << i$2), n$1 = t.$ >> i$2;
							t.bY(s$1, 0, n$1, n$1, 0, 0, 1), t.M(s$1, s$1, [
								-o$2 * n$1,
								-a$2 * n$1,
								0
							]);
						} else {
							if (!e$1.canonical.isChildOf(r$1.canonical)) continue;
							{
								const i$2 = e$1.canonical.z - r$1.canonical.z, o$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), a$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), n$1 = t.$ >> i$2;
								t.bY(s$1, 0, t.$, t.$, 0, 0, 1), t.M(s$1, s$1, [
									o$2 * n$1,
									a$2 * n$1,
									0
								]), t.N(s$1, s$1, [
									1 / 2 ** i$2,
									1 / 2 ** i$2,
									0
								]);
							}
						}
						a$1.terrainRttPosMatrix32f = new Float32Array(s$1), i$1[o$1] = a$1;
					}
					return i$1;
				}
				_getTerrainCoordsForTileRanges(e$1, i$1) {
					const o$1 = {};
					for (const r$1 of this._renderableTilesKeys) {
						const a$1 = this._tiles[r$1].tileID;
						if (!this._isWithinTileRanges(a$1, i$1)) continue;
						const s$1 = e$1.clone(), n$1 = t.ba();
						if (a$1.canonical.z === e$1.canonical.z) {
							const i$2 = e$1.canonical.x - a$1.canonical.x, o$2 = e$1.canonical.y - a$1.canonical.y;
							t.bY(n$1, 0, t.$, t.$, 0, 0, 1), t.M(n$1, n$1, [
								i$2 * t.$,
								o$2 * t.$,
								0
							]);
						} else if (a$1.canonical.z > e$1.canonical.z) {
							const i$2 = a$1.canonical.z - e$1.canonical.z, o$2 = a$1.canonical.x - (a$1.canonical.x >> i$2 << i$2), r$2 = a$1.canonical.y - (a$1.canonical.y >> i$2 << i$2), s$2 = e$1.canonical.x - (a$1.canonical.x >> i$2), l$1 = e$1.canonical.y - (a$1.canonical.y >> i$2), c$1 = t.$ >> i$2;
							t.bY(n$1, 0, c$1, c$1, 0, 0, 1), t.M(n$1, n$1, [
								-o$2 * c$1 + s$2 * t.$,
								-r$2 * c$1 + l$1 * t.$,
								0
							]);
						} else {
							const i$2 = e$1.canonical.z - a$1.canonical.z, o$2 = e$1.canonical.x - (e$1.canonical.x >> i$2 << i$2), r$2 = e$1.canonical.y - (e$1.canonical.y >> i$2 << i$2), s$2 = (e$1.canonical.x >> i$2) - a$1.canonical.x, l$1 = (e$1.canonical.y >> i$2) - a$1.canonical.y, c$1 = t.$ << i$2;
							t.bY(n$1, 0, c$1, c$1, 0, 0, 1), t.M(n$1, n$1, [
								o$2 * t.$ + s$2 * c$1,
								r$2 * t.$ + l$1 * c$1,
								0
							]);
						}
						s$1.terrainRttPosMatrix32f = new Float32Array(n$1), o$1[r$1] = s$1;
					}
					return o$1;
				}
				getSourceTile(e$1, t$1) {
					const i$1 = this.sourceCache._source;
					let o$1 = e$1.overscaledZ - this.deltaZoom;
					if (o$1 > i$1.maxzoom && (o$1 = i$1.maxzoom), o$1 < i$1.minzoom) return null;
					this._sourceTileCache[e$1.key] || (this._sourceTileCache[e$1.key] = e$1.scaledTo(o$1).key);
					let r$1 = this.sourceCache.getTileByID(this._sourceTileCache[e$1.key]);
					if ((!r$1 || !r$1.dem) && t$1) for (; o$1 >= i$1.minzoom && (!r$1 || !r$1.dem);) r$1 = this.sourceCache.getTileByID(e$1.scaledTo(o$1--).key);
					return r$1;
				}
				anyTilesAfterTime(e$1 = Date.now()) {
					return this._lastTilesetChange >= e$1;
				}
				_isWithinTileRanges(e$1, t$1) {
					return t$1[e$1.canonical.z] && e$1.canonical.x >= t$1[e$1.canonical.z].minTileX && e$1.canonical.x <= t$1[e$1.canonical.z].maxTileX && e$1.canonical.y >= t$1[e$1.canonical.z].minTileY && e$1.canonical.y <= t$1[e$1.canonical.z].maxTileY;
				}
			}
			class Ba {
				constructor(e$1, t$1, i$1) {
					this._meshCache = {}, this.painter = e$1, this.sourceCache = new Fa(t$1), this.options = i$1, this.exaggeration = "number" == typeof i$1.exaggeration ? i$1.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
				}
				getDEMElevation(e$1, i$1, o$1, r$1 = t.$) {
					var a$1;
					if (!(i$1 >= 0 && i$1 < r$1 && o$1 >= 0 && o$1 < r$1)) return 0;
					const s$1 = this.getTerrainData(e$1), n$1 = null === (a$1 = s$1.tile) || void 0 === a$1 ? void 0 : a$1.dem;
					if (!n$1) return 0;
					const l$1 = t.cs([], [i$1 / r$1 * t.$, o$1 / r$1 * t.$], s$1.u_terrain_matrix), c$1 = [l$1[0] * n$1.dim, l$1[1] * n$1.dim], h$1 = Math.floor(c$1[0]), u$1 = Math.floor(c$1[1]), d$1 = c$1[0] - h$1, _$1 = c$1[1] - u$1;
					return n$1.get(h$1, u$1) * (1 - d$1) * (1 - _$1) + n$1.get(h$1 + 1, u$1) * d$1 * (1 - _$1) + n$1.get(h$1, u$1 + 1) * (1 - d$1) * _$1 + n$1.get(h$1 + 1, u$1 + 1) * d$1 * _$1;
				}
				getElevationForLngLatZoom(e$1, i$1) {
					if (!t.ct(i$1, e$1.wrap())) return 0;
					const { tileID: o$1, mercatorX: r$1, mercatorY: a$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, i$1);
					return this.getElevation(o$1, r$1 % t.$, a$1 % t.$, t.$);
				}
				getElevation(e$1, i$1, o$1, r$1 = t.$) {
					return this.getDEMElevation(e$1, i$1, o$1, r$1) * this.exaggeration;
				}
				getTerrainData(e$1) {
					if (!this._emptyDemTexture) {
						const e$2 = this.painter.context, i$2 = new t.R({
							width: 1,
							height: 1
						}, new Uint8Array(4));
						this._emptyDepthTexture = new t.T(e$2, i$2, e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [
							0,
							0,
							0,
							0
						], this._emptyDemTexture = new t.T(e$2, new t.R({
							width: 1,
							height: 1
						}), e$2.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ag([]);
					}
					const i$1 = this.sourceCache.getSourceTile(e$1, !0);
					if (i$1 && i$1.dem && (!i$1.demTexture || i$1.needsTerrainPrepare)) {
						const e$2 = this.painter.context;
						i$1.demTexture = this.painter.getTileTexture(i$1.dem.stride), i$1.demTexture ? i$1.demTexture.update(i$1.dem.getPixels(), { premultiply: !1 }) : i$1.demTexture = new t.T(e$2, i$1.dem.getPixels(), e$2.gl.RGBA, { premultiply: !1 }), i$1.demTexture.bind(e$2.gl.NEAREST, e$2.gl.CLAMP_TO_EDGE), i$1.needsTerrainPrepare = !1;
					}
					const o$1 = i$1 && i$1 + i$1.tileID.key + e$1.key;
					if (o$1 && !this._demMatrixCache[o$1]) {
						const o$2 = this.sourceCache.sourceCache._source.maxzoom;
						let r$1 = e$1.canonical.z - i$1.tileID.canonical.z;
						e$1.overscaledZ > e$1.canonical.z && (e$1.canonical.z >= o$2 ? r$1 = e$1.canonical.z - o$2 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
						const a$1 = e$1.canonical.x - (e$1.canonical.x >> r$1 << r$1), s$1 = e$1.canonical.y - (e$1.canonical.y >> r$1 << r$1), n$1 = t.cu(new Float64Array(16), [
							1 / (t.$ << r$1),
							1 / (t.$ << r$1),
							0
						]);
						t.M(n$1, n$1, [
							a$1 * t.$,
							s$1 * t.$,
							0
						]), this._demMatrixCache[e$1.key] = {
							matrix: n$1,
							coord: e$1
						};
					}
					return {
						u_depth: 2,
						u_terrain: 3,
						u_terrain_dim: i$1 && i$1.dem && i$1.dem.dim || 1,
						u_terrain_matrix: o$1 ? this._demMatrixCache[e$1.key].matrix : this._emptyDemMatrix,
						u_terrain_unpack: i$1 && i$1.dem && i$1.dem.getUnpackVector() || this._emptyDemUnpack,
						u_terrain_exaggeration: this.exaggeration,
						texture: (i$1 && i$1.demTexture || this._emptyDemTexture).texture,
						depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
						tile: i$1
					};
				}
				getFramebuffer(e$1) {
					const i$1 = this.painter, o$1 = i$1.width / devicePixelRatio, r$1 = i$1.height / devicePixelRatio;
					return !this._fbo || this._fbo.width === o$1 && this._fbo.height === r$1 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i$1.context, {
						width: o$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i$1.context, {
						width: o$1,
						height: r$1,
						data: null
					}, i$1.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i$1.context.gl.NEAREST, i$1.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i$1.context.createFramebuffer(o$1, r$1, !0, !1), this._fbo.depthAttachment.set(i$1.context.createRenderbuffer(i$1.context.gl.DEPTH_COMPONENT16, o$1, r$1))), this._fbo.colorAttachment.set("coords" === e$1 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
				}
				getCoordsTexture() {
					const e$1 = this.painter.context;
					if (this._coordsTexture) return this._coordsTexture;
					const i$1 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
					for (let e$2 = 0, t$1 = 0; e$2 < this._coordsTextureSize; e$2++) for (let o$2 = 0; o$2 < this._coordsTextureSize; o$2++, t$1 += 4) i$1[t$1 + 0] = 255 & o$2, i$1[t$1 + 1] = 255 & e$2, i$1[t$1 + 2] = o$2 >> 8 << 4 | e$2 >> 8, i$1[t$1 + 3] = 0;
					const o$1 = new t.R({
						width: this._coordsTextureSize,
						height: this._coordsTextureSize
					}, new Uint8Array(i$1.buffer)), r$1 = new t.T(e$1, o$1, e$1.gl.RGBA, { premultiply: !1 });
					return r$1.bind(e$1.gl.NEAREST, e$1.gl.CLAMP_TO_EDGE), this._coordsTexture = r$1, r$1;
				}
				pointCoordinate(e$1) {
					this.painter.maybeDrawDepthAndCoords(!0);
					const i$1 = new Uint8Array(4), o$1 = this.painter.context, r$1 = o$1.gl, a$1 = Math.round(e$1.x * this.painter.pixelRatio / devicePixelRatio), s$1 = Math.round(e$1.y * this.painter.pixelRatio / devicePixelRatio), n$1 = Math.round(this.painter.height / devicePixelRatio);
					o$1.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r$1.readPixels(a$1, n$1 - s$1 - 1, 1, 1, r$1.RGBA, r$1.UNSIGNED_BYTE, i$1), o$1.bindFramebuffer.set(null);
					const l$1 = i$1[0] + (i$1[2] >> 4 << 8), c$1 = i$1[1] + ((15 & i$1[2]) << 8), h$1 = this.coordsIndex[255 - i$1[3]], u$1 = h$1 && this.sourceCache.getTileByID(h$1);
					if (!u$1) return null;
					const d$1 = this._coordsTextureSize, _$1 = (1 << u$1.tileID.canonical.z) * d$1;
					return new t.a1((u$1.tileID.canonical.x * d$1 + l$1) / _$1 + u$1.tileID.wrap, (u$1.tileID.canonical.y * d$1 + c$1) / _$1, this.getElevation(u$1.tileID, l$1, c$1, d$1));
				}
				depthAtPoint(e$1) {
					const t$1 = new Uint8Array(4), i$1 = this.painter.context, o$1 = i$1.gl;
					return i$1.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), o$1.readPixels(e$1.x, this.painter.height / devicePixelRatio - e$1.y - 1, 1, 1, o$1.RGBA, o$1.UNSIGNED_BYTE, t$1), i$1.bindFramebuffer.set(null), (t$1[0] / 16777216 + t$1[1] / 65536 + t$1[2] / 256 + t$1[3]) / 256;
				}
				getTerrainMesh(e$1) {
					var i$1;
					const o$1 = (null === (i$1 = this.painter.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0, r$1 = o$1 && 0 === e$1.canonical.y, a$1 = o$1 && e$1.canonical.y === (1 << e$1.canonical.z) - 1, s$1 = `m_${r$1 ? "n" : ""}_${a$1 ? "s" : ""}`;
					if (this._meshCache[s$1]) return this._meshCache[s$1];
					const n$1 = this.painter.context, l$1 = new t.cv(), c$1 = new t.aN(), h$1 = this.meshSize, u$1 = t.$ / h$1, d$1 = h$1 * h$1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) for (let t$1 = 0; t$1 <= h$1; t$1++) l$1.emplaceBack(t$1 * u$1, e$2 * u$1, 0);
					for (let e$2 = 0; e$2 < d$1; e$2 += h$1 + 1) for (let t$1 = 0; t$1 < h$1; t$1++) c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 1, h$1 + t$1 + e$2 + 2), c$1.emplaceBack(t$1 + e$2, h$1 + t$1 + e$2 + 2, t$1 + e$2 + 1);
					const _$1 = l$1.length, p$1 = _$1 + (h$1 + 1), m$1 = (h$1 + 1) * h$1, f$1 = r$1 ? t.bh : 0, g$1 = r$1 ? 0 : 1, v$1 = a$1 ? t.bi : t.$, b$1 = a$1 ? 0 : 1;
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, f$1, g$1);
					for (let e$2 = 0; e$2 <= h$1; e$2++) l$1.emplaceBack(e$2 * u$1, v$1, b$1);
					for (let e$2 = 0; e$2 < h$1; e$2++) c$1.emplaceBack(m$1 + e$2, p$1 + e$2, p$1 + e$2 + 1), c$1.emplaceBack(m$1 + e$2, p$1 + e$2 + 1, m$1 + e$2 + 1), c$1.emplaceBack(0 + e$2, _$1 + e$2 + 1, _$1 + e$2), c$1.emplaceBack(0 + e$2, 0 + e$2 + 1, _$1 + e$2 + 1);
					const x$1 = l$1.length, y$1 = x$1 + 2 * (h$1 + 1);
					for (const e$2 of [0, 1]) for (let i$2 = 0; i$2 <= h$1; i$2++) for (const o$2 of [0, 1]) l$1.emplaceBack(e$2 * t.$, i$2 * u$1, o$2);
					for (let e$2 = 0; e$2 < 2 * h$1; e$2 += 2) c$1.emplaceBack(x$1 + e$2, x$1 + e$2 + 1, x$1 + e$2 + 3), c$1.emplaceBack(x$1 + e$2, x$1 + e$2 + 3, x$1 + e$2 + 2), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 3, y$1 + e$2 + 1), c$1.emplaceBack(y$1 + e$2, y$1 + e$2 + 2, y$1 + e$2 + 3);
					const w$1 = new wt(n$1.createVertexBuffer(l$1, ka.members), n$1.createIndexBuffer(c$1), t.aM.simpleSegment(0, 0, l$1.length, c$1.length));
					return this._meshCache[s$1] = w$1, w$1;
				}
				getMeshFrameDelta(e$1) {
					return 2 * Math.PI * t.bu / Math.pow(2, Math.max(e$1, 0)) / 5;
				}
				getMinTileElevationForLngLatZoom(e$1, t$1) {
					var i$1;
					const { tileID: o$1 } = this._getOverscaledTileIDFromLngLatZoom(e$1, t$1);
					return null !== (i$1 = this.getMinMaxElevation(o$1).minElevation) && void 0 !== i$1 ? i$1 : 0;
				}
				getMinMaxElevation(e$1) {
					const t$1 = this.getTerrainData(e$1).tile, i$1 = {
						minElevation: null,
						maxElevation: null
					};
					return t$1 && t$1.dem && (i$1.minElevation = t$1.dem.min * this.exaggeration, i$1.maxElevation = t$1.dem.max * this.exaggeration), i$1;
				}
				_getOverscaledTileIDFromLngLatZoom(e$1, i$1) {
					const o$1 = t.a1.fromLngLat(e$1.wrap()), r$1 = (1 << i$1) * t.$, a$1 = o$1.x * r$1, s$1 = o$1.y * r$1, n$1 = Math.floor(a$1 / t.$), l$1 = Math.floor(s$1 / t.$);
					return {
						tileID: new t.Z(i$1, 0, i$1, n$1, l$1),
						mercatorX: a$1,
						mercatorY: s$1
					};
				}
			}
			class Oa {
				constructor(e$1, t$1, i$1) {
					this._context = e$1, this._size = t$1, this._tileSize = i$1, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
				}
				destruct() {
					for (const e$1 of this._objects) e$1.texture.destroy(), e$1.fbo.destroy();
				}
				_createObject(e$1) {
					const i$1 = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o$1 = new t.T(this._context, {
						width: this._tileSize,
						height: this._tileSize,
						data: null
					}, this._context.gl.RGBA);
					return o$1.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i$1.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i$1.colorAttachment.set(o$1.texture), {
						id: e$1,
						fbo: i$1,
						texture: o$1,
						stamp: -1,
						inUse: !1
					};
				}
				getObjectForId(e$1) {
					return this._objects[e$1];
				}
				useObject(e$1) {
					e$1.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((t$1) => e$1.id !== t$1)), this._recentlyUsed.push(e$1.id);
				}
				stampObject(e$1) {
					e$1.stamp = ++this._stamp;
				}
				getOrCreateFreeObject() {
					for (const e$2 of this._recentlyUsed) if (!this._objects[e$2].inUse) return this._objects[e$2];
					if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
					const e$1 = this._createObject(this._objects.length);
					return this._objects.push(e$1), e$1;
				}
				freeObject(e$1) {
					e$1.inUse = !1;
				}
				freeAllObjects() {
					for (const e$1 of this._objects) this.freeObject(e$1);
				}
				isFull() {
					return !(this._objects.length < this._size) && !1 === this._objects.some(((e$1) => !e$1.inUse));
				}
			}
			const ja = {
				background: !0,
				fill: !0,
				line: !0,
				raster: !0,
				hillshade: !0,
				"color-relief": !0
			};
			class Na {
				constructor(e$1, t$1) {
					this.painter = e$1, this.terrain = t$1, this.pool = new Oa(e$1.context, 30, t$1.sourceCache.tileSize * t$1.qualityFactor);
				}
				destruct() {
					this.pool.destruct();
				}
				getTexture(e$1) {
					return this.pool.getObjectForId(e$1.rtt[this._stacks.length - 1].id).texture;
				}
				prepareForRender(e$1, t$1) {
					this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e$1._order.filter(((i$1) => !e$1._layers[i$1].isHidden(t$1))), this._coordsAscending = {};
					for (const t$2 in e$1.sourceCaches) {
						this._coordsAscending[t$2] = {};
						const i$1 = e$1.sourceCaches[t$2].getVisibleCoordinates(), o$1 = e$1.sourceCaches[t$2].getSource(), r$1 = o$1 instanceof X ? o$1.terrainTileRanges : null;
						for (const e$2 of i$1) {
							const i$2 = this.terrain.sourceCache.getTerrainCoords(e$2, r$1);
							for (const e$3 in i$2) this._coordsAscending[t$2][e$3] || (this._coordsAscending[t$2][e$3] = []), this._coordsAscending[t$2][e$3].push(i$2[e$3]);
						}
					}
					this._coordsAscendingStr = {};
					for (const t$2 of e$1._order) {
						const i$1 = e$1._layers[t$2], o$1 = i$1.source;
						if (ja[i$1.type] && !this._coordsAscendingStr[o$1]) {
							this._coordsAscendingStr[o$1] = {};
							for (const e$2 in this._coordsAscending[o$1]) this._coordsAscendingStr[o$1][e$2] = this._coordsAscending[o$1][e$2].map(((e$3) => e$3.key)).sort().join();
						}
					}
					for (const e$2 of this._renderableTiles) for (const t$2 in this._coordsAscendingStr) {
						const i$1 = this._coordsAscendingStr[t$2][e$2.tileID.key];
						i$1 && i$1 !== e$2.rttCoords[t$2] && (e$2.rtt = []);
					}
				}
				renderLayer(e$1, i$1) {
					if (e$1.isHidden(this.painter.transform.zoom)) return !1;
					const o$1 = Object.assign(Object.assign({}, i$1), { isRenderingToTexture: !0 }), r$1 = e$1.type, a$1 = this.painter, s$1 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e$1.id;
					if (ja[r$1] && (this._prevType && ja[this._prevType] || this._stacks.push([]), this._prevType = r$1, this._stacks[this._stacks.length - 1].push(e$1.id), !s$1)) return !0;
					if (ja[this._prevType] || ja[r$1] && s$1) {
						this._prevType = r$1;
						const e$2 = this._stacks.length - 1, i$2 = this._stacks[e$2] || [];
						for (const r$2 of this._renderableTiles) {
							if (this.pool.isFull() && (Cr(this.painter, this.terrain, this._rttTiles, o$1), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(r$2), r$2.rtt[e$2]) {
								const t$1 = this.pool.getObjectForId(r$2.rtt[e$2].id);
								if (t$1.stamp === r$2.rtt[e$2].stamp) {
									this.pool.useObject(t$1);
									continue;
								}
							}
							const s$2 = this.pool.getOrCreateFreeObject();
							this.pool.useObject(s$2), this.pool.stampObject(s$2), r$2.rtt[e$2] = {
								id: s$2.id,
								stamp: s$2.stamp
							}, a$1.context.bindFramebuffer.set(s$2.fbo.framebuffer), a$1.context.clear({
								color: t.bf.transparent,
								stencil: 0
							}), a$1.currentStencilSource = void 0;
							for (let e$3 = 0; e$3 < i$2.length; e$3++) {
								const t$1 = a$1.style._layers[i$2[e$3]], n$1 = t$1.source ? this._coordsAscending[t$1.source][r$2.tileID.key] : [r$2.tileID];
								a$1.context.viewport.set([
									0,
									0,
									s$2.fbo.width,
									s$2.fbo.height
								]), a$1._renderTileClippingMasks(t$1, n$1, !0), a$1.renderLayer(a$1, a$1.style.sourceCaches[t$1.source], t$1, n$1, o$1), t$1.source && (r$2.rttCoords[t$1.source] = this._coordsAscendingStr[t$1.source][r$2.tileID.key]);
							}
						}
						return Cr(this.painter, this.terrain, this._rttTiles, o$1), this._rttTiles = [], this.pool.freeAllObjects(), ja[r$1];
					}
					return !1;
				}
			}
			const Ua = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"AttributionControl.MapFeedback": "Map feedback",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "MapLibre logo",
				"Map.Title": "Map",
				"Marker.Title": "Map marker",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"Popup.Close": "Close popup",
				"ScaleControl.Feet": "ft",
				"ScaleControl.Meters": "m",
				"ScaleControl.Kilometers": "km",
				"ScaleControl.Miles": "mi",
				"ScaleControl.NauticalMiles": "nm",
				"GlobeControl.Enable": "Enable globe",
				"GlobeControl.Disable": "Disable globe",
				"TerrainControl.Enable": "Enable terrain",
				"TerrainControl.Disable": "Disable terrain",
				"CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
				"CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
				"CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
			}, Za = i, Ga = {
				hash: !1,
				interactive: !0,
				bearingSnap: 7,
				attributionControl: za,
				maplibreLogo: !1,
				refreshExpiredTiles: !0,
				canvasContextAttributes: {
					antialias: !1,
					preserveDrawingBuffer: !1,
					powerPreference: "high-performance",
					failIfMajorPerformanceCaveat: !1,
					desynchronized: !1,
					contextType: void 0
				},
				scrollZoom: !0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 60,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				trackResize: !0,
				center: [0, 0],
				elevation: 0,
				zoom: 0,
				bearing: 0,
				pitch: 0,
				roll: 0,
				renderWorldCopies: !0,
				maxTileCacheSize: null,
				maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS,
				transformRequest: null,
				transformCameraUpdate: null,
				fadeDuration: 300,
				crossSourceCollisions: !0,
				clickTolerance: 3,
				localIdeographFontFamily: "sans-serif",
				pitchWithRotate: !0,
				rollEnabled: !1,
				validateStyle: !0,
				maxCanvasSize: [4096, 4096],
				cancelPendingTileRequestsWhileZooming: !0,
				centerClampedToGround: !0
			}, Va = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1,
				visualizeRoll: !0
			};
			class $a {
				constructor(e$1, i$1, o$1 = !1) {
					this.mousedown = (e$2) => {
						this.startMove(e$2, n.mousePos(this.element, e$2)), n.addEventListener(window, "mousemove", this.mousemove), n.addEventListener(window, "mouseup", this.mouseup);
					}, this.mousemove = (e$2) => {
						this.move(e$2, n.mousePos(this.element, e$2));
					}, this.mouseup = (e$2) => {
						this._rotatePitchHandler.dragEnd(e$2), this.offTemp();
					}, this.touchstart = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e$2.targetTouches)[0], this.startMove(e$2, this._startPos), n.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.addEventListener(window, "touchend", this.touchend));
					}, this.touchmove = (e$2) => {
						1 !== e$2.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, e$2.targetTouches)[0], this.move(e$2, this._lastPos));
					}, this.touchend = (e$2) => {
						0 === e$2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this.reset = () => {
						this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this._clickTolerance = 10, this.element = i$1;
					const r$1 = new ia();
					this._rotatePitchHandler = new Kr({
						clickTolerance: 3,
						move: (e$2, r$2) => {
							const a$1 = i$1.getBoundingClientRect(), s$1 = new t.P((a$1.bottom - a$1.top) / 2, (a$1.right - a$1.left) / 2);
							return {
								bearingDelta: t.cn(new t.P(e$2.x, r$2.y), r$2, s$1),
								pitchDelta: o$1 ? -.5 * (r$2.y - e$2.y) : void 0
							};
						},
						moveStateManager: r$1,
						enable: !0,
						assignEvents: () => {}
					}), this.map = e$1, n.addEventListener(i$1, "mousedown", this.mousedown), n.addEventListener(i$1, "touchstart", this.touchstart, { passive: !1 }), n.addEventListener(i$1, "touchcancel", this.reset);
				}
				startMove(e$1, t$1) {
					this._rotatePitchHandler.dragStart(e$1, t$1), n.disableDrag();
				}
				move(e$1, t$1) {
					const i$1 = this.map, { bearingDelta: o$1, pitchDelta: r$1 } = this._rotatePitchHandler.dragMove(e$1, t$1) || {};
					o$1 && i$1.setBearing(i$1.getBearing() + o$1), r$1 && i$1.setPitch(i$1.getPitch() + r$1);
				}
				off() {
					const e$1 = this.element;
					n.removeEventListener(e$1, "mousedown", this.mousedown), n.removeEventListener(e$1, "touchstart", this.touchstart, { passive: !1 }), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend), n.removeEventListener(e$1, "touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					n.enableDrag(), n.removeEventListener(window, "mousemove", this.mousemove), n.removeEventListener(window, "mouseup", this.mouseup), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend);
				}
			}
			let qa;
			function Wa(e$1, i$1, o$1, r$1 = !1) {
				if (r$1 || !o$1.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e$1 ? void 0 : e$1.wrap();
				const a$1 = new t.S(e$1.lng, e$1.lat);
				if (e$1 = new t.S(e$1.lng, e$1.lat), i$1) {
					const r$2 = new t.S(e$1.lng - 360, e$1.lat), a$2 = new t.S(e$1.lng + 360, e$1.lat), s$1 = o$1.locationToScreenPoint(e$1).distSqr(i$1);
					o$1.locationToScreenPoint(r$2).distSqr(i$1) < s$1 ? e$1 = r$2 : o$1.locationToScreenPoint(a$2).distSqr(i$1) < s$1 && (e$1 = a$2);
				}
				for (; Math.abs(e$1.lng - o$1.center.lng) > 180;) {
					const t$1 = o$1.locationToScreenPoint(e$1);
					if (t$1.x >= 0 && t$1.y >= 0 && t$1.x <= o$1.width && t$1.y <= o$1.height) break;
					e$1.lng > o$1.center.lng ? e$1.lng -= 360 : e$1.lng += 360;
				}
				return e$1.lng !== a$1.lng && o$1.isPointOnMapSurface(o$1.locationToScreenPoint(e$1)) ? e$1 : a$1;
			}
			const Ha = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			};
			function Xa(e$1, t$1, i$1) {
				const o$1 = e$1.classList;
				for (const e$2 in Ha) o$1.remove(`maplibregl-${i$1}-anchor-${e$2}`);
				o$1.add(`maplibregl-${i$1}-anchor-${t$1}`);
			}
			class Ka extends t.E {
				constructor(e$1) {
					if (super(), this._onKeyPress = (e$2) => {
						const t$1 = e$2.code, i$1 = e$2.charCode || e$2.keyCode;
						"Space" !== t$1 && "Enter" !== t$1 && 32 !== i$1 && 13 !== i$1 || this.togglePopup();
					}, this._onMapClick = (e$2) => {
						const t$1 = e$2.originalEvent.target, i$1 = this._element;
						this._popup && (t$1 === i$1 || i$1.contains(t$1)) && this.togglePopup();
					}, this._update = (e$2) => {
						if (!this._map) return;
						const t$1 = this._map.loaded() && !this._map.isMoving();
						("terrain" === (null == e$2 ? void 0 : e$2.type) || "render" === (null == e$2 ? void 0 : e$2.type) && !t$1) && this._map.once("render", this._update), this._lngLat = Wa(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
						let i$1 = "";
						"viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i$1 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i$1 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
						let o$1 = "";
						"viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o$1 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o$1 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e$2 && "moveend" !== e$2.type || (this._pos = this._pos.round()), n.setTransform(this._element, `${Ha[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o$1} ${i$1}`), s.frameAsync(new AbortController()).then((() => {
							this._updateOpacity(e$2 && "moveend" === e$2.type);
						})).catch((() => {}));
					}, this._onMove = (e$2) => {
						if (!this._isDragging) {
							const t$1 = this._clickTolerance || this._map._clickTolerance;
							this._isDragging = e$2.point.dist(this._pointerdownPos) >= t$1;
						}
						this._isDragging && (this._pos = e$2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
					}, this._onUp = () => {
						this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
					}, this._addDragHandler = (e$2) => {
						this._element.contains(e$2.originalEvent.target) && (e$2.preventDefault(), this._positionDelta = e$2.point.sub(this._pos).add(this._offset), this._pointerdownPos = e$2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
					}, this._anchor = e$1 && e$1.anchor || "center", this._color = e$1 && e$1.color || "#3FB1CE", this._scale = e$1 && e$1.scale || 1, this._draggable = e$1 && e$1.draggable || !1, this._clickTolerance = e$1 && e$1.clickTolerance || 0, this._subpixelPositioning = e$1 && e$1.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e$1 && e$1.rotation || 0, this._rotationAlignment = e$1 && e$1.rotationAlignment || "auto", this._pitchAlignment = e$1 && e$1.pitchAlignment && "auto" !== e$1.pitchAlignment ? e$1.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e$1 ? void 0 : e$1.opacity, null == e$1 ? void 0 : e$1.opacityWhenCovered), e$1 && e$1.element) this._element = e$1.element, this._offset = t.P.convert(e$1 && e$1.offset || [0, 0]);
					else {
						this._defaultMarker = !0, this._element = n.create("div");
						const i$1 = n.createNS("http://www.w3.org/2000/svg", "svg"), o$1 = 41, r$1 = 27;
						i$1.setAttributeNS(null, "display", "block"), i$1.setAttributeNS(null, "height", `${o$1}px`), i$1.setAttributeNS(null, "width", `${r$1}px`), i$1.setAttributeNS(null, "viewBox", `0 0 ${r$1} ${o$1}`);
						const a$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						a$1.setAttributeNS(null, "stroke", "none"), a$1.setAttributeNS(null, "stroke-width", "1"), a$1.setAttributeNS(null, "fill", "none"), a$1.setAttributeNS(null, "fill-rule", "evenodd");
						const s$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						s$1.setAttributeNS(null, "fill-rule", "nonzero");
						const l$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						l$1.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l$1.setAttributeNS(null, "fill", "#000000");
						for (const e$2 of [
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "9.5",
								ry: "4.77275007"
							},
							{
								rx: "8.5",
								ry: "4.29549936"
							},
							{
								rx: "7.5",
								ry: "3.81822308"
							},
							{
								rx: "6.5",
								ry: "3.34094679"
							},
							{
								rx: "5.5",
								ry: "2.86367051"
							},
							{
								rx: "4.5",
								ry: "2.38636864"
							}
						]) {
							const t$1 = n.createNS("http://www.w3.org/2000/svg", "ellipse");
							t$1.setAttributeNS(null, "opacity", "0.04"), t$1.setAttributeNS(null, "cx", "10.5"), t$1.setAttributeNS(null, "cy", "5.80029008"), t$1.setAttributeNS(null, "rx", e$2.rx), t$1.setAttributeNS(null, "ry", e$2.ry), l$1.appendChild(t$1);
						}
						const h$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						h$1.setAttributeNS(null, "fill", this._color);
						const u$1 = n.createNS("http://www.w3.org/2000/svg", "path");
						u$1.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h$1.appendChild(u$1);
						const d$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						d$1.setAttributeNS(null, "opacity", "0.25"), d$1.setAttributeNS(null, "fill", "#000000");
						const _$1 = n.createNS("http://www.w3.org/2000/svg", "path");
						_$1.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d$1.appendChild(_$1);
						const p$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						p$1.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p$1.setAttributeNS(null, "fill", "#FFFFFF");
						const m$1 = n.createNS("http://www.w3.org/2000/svg", "g");
						m$1.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
						const f$1 = n.createNS("http://www.w3.org/2000/svg", "circle");
						f$1.setAttributeNS(null, "fill", "#000000"), f$1.setAttributeNS(null, "opacity", "0.25"), f$1.setAttributeNS(null, "cx", "5.5"), f$1.setAttributeNS(null, "cy", "5.5"), f$1.setAttributeNS(null, "r", "5.4999962");
						const g$1 = n.createNS("http://www.w3.org/2000/svg", "circle");
						g$1.setAttributeNS(null, "fill", "#FFFFFF"), g$1.setAttributeNS(null, "cx", "5.5"), g$1.setAttributeNS(null, "cy", "5.5"), g$1.setAttributeNS(null, "r", "5.4999962"), m$1.appendChild(f$1), m$1.appendChild(g$1), s$1.appendChild(l$1), s$1.appendChild(h$1), s$1.appendChild(d$1), s$1.appendChild(p$1), s$1.appendChild(m$1), i$1.appendChild(s$1), i$1.setAttributeNS(null, "height", o$1 * this._scale + "px"), i$1.setAttributeNS(null, "width", r$1 * this._scale + "px"), this._element.appendChild(i$1), this._offset = t.P.convert(e$1 && e$1.offset || [0, -14]);
					}
					if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e$2) => {
						e$2.preventDefault();
					})), this._element.addEventListener("mousedown", ((e$2) => {
						e$2.preventDefault();
					})), Xa(this._element, this._anchor, "marker"), e$1 && e$1.className) for (const t$1 of e$1.className.split(" ")) this._element.classList.add(t$1);
					this._popup = null;
				}
				addTo(e$1) {
					return this.remove(), this._map = e$1, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e$1._getUIString("Marker.Title")), e$1.getCanvasContainer().appendChild(this._element), e$1.on("move", this._update), e$1.on("moveend", this._update), e$1.on("terrain", this._update), e$1.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
				}
				remove() {
					return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.S.convert(e$1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
				}
				getElement() {
					return this._element;
				}
				setPopup(e$1) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e$1) {
						if (!("offset" in e$1.options)) {
							const t$1 = 38.1, i$1 = 13.5, o$1 = Math.abs(i$1) / Math.SQRT2;
							e$1.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t$1],
								"bottom-left": [o$1, -1 * (t$1 - i$1 + o$1)],
								"bottom-right": [-o$1, -1 * (t$1 - i$1 + o$1)],
								left: [i$1, -1 * (t$1 - i$1)],
								right: [-i$1, -1 * (t$1 - i$1)]
							} : this._offset;
						}
						this._popup = e$1, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
					}
					return this;
				}
				setSubpixelPositioning(e$1) {
					return this._subpixelPositioning = e$1, this;
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					const e$1 = this._popup;
					return this._element.style.opacity === this._opacityWhenCovered ? this : e$1 ? (e$1.isOpen() ? e$1.remove() : (e$1.setLngLat(this._lngLat), e$1.addTo(this._map)), this) : this;
				}
				_updateOpacity(e$1 = !1) {
					var i$1, o$1;
					const r$1 = null === (i$1 = this._map) || void 0 === i$1 ? void 0 : i$1.terrain, a$1 = this._map.transform.isLocationOccluded(this._lngLat);
					if (!r$1 || a$1) {
						const e$2 = a$1 ? this._opacityWhenCovered : this._opacity;
						this._element.style.opacity !== e$2 && (this._element.style.opacity = e$2);
						return;
					}
					if (e$1) this._opacityTimeout = null;
					else {
						if (this._opacityTimeout) return;
						this._opacityTimeout = setTimeout((() => {
							this._opacityTimeout = null;
						}), 100);
					}
					const s$1 = this._map, n$1 = s$1.terrain.depthAtPoint(this._pos), l$1 = s$1.terrain.getElevationForLngLatZoom(this._lngLat, s$1.transform.tileZoom);
					if (s$1.transform.lngLatToCameraDepth(this._lngLat, l$1) - n$1 < .006) return void (this._element.style.opacity = this._opacity);
					const c$1 = -this._offset.y / s$1.transform.pixelsPerMeter, h$1 = Math.sin(s$1.getPitch() * Math.PI / 180) * c$1, u$1 = s$1.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d$1 = s$1.transform.lngLatToCameraDepth(this._lngLat, l$1 + h$1) - u$1 > .006;
					!(null === (o$1 = this._popup) || void 0 === o$1) && o$1.isOpen() && d$1 && this._popup.remove(), this._element.style.opacity = d$1 ? this._opacityWhenCovered : this._opacity;
				}
				getOffset() {
					return this._offset;
				}
				setOffset(e$1) {
					return this._offset = t.P.convert(e$1), this._update(), this;
				}
				addClassName(e$1) {
					this._element.classList.add(e$1);
				}
				removeClassName(e$1) {
					this._element.classList.remove(e$1);
				}
				toggleClassName(e$1) {
					return this._element.classList.toggle(e$1);
				}
				setDraggable(e$1) {
					return this._draggable = !!e$1, this._map && (e$1 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e$1) {
					return this._rotation = e$1 || 0, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e$1) {
					return this._rotationAlignment = e$1 || "auto", this._update(), this;
				}
				getRotationAlignment() {
					return this._rotationAlignment;
				}
				setPitchAlignment(e$1) {
					return this._pitchAlignment = e$1 && "auto" !== e$1 ? e$1 : this._rotationAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return this._pitchAlignment;
				}
				setOpacity(e$1, t$1) {
					return (void 0 === this._opacity || void 0 === e$1 && void 0 === t$1) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e$1 && (this._opacity = e$1), void 0 !== t$1 && (this._opacityWhenCovered = t$1), this._map && this._updateOpacity(!0), this;
				}
			}
			const Ya = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0
			};
			let Qa = 0, Ja = !1;
			const es = {
				maxWidth: 100,
				unit: "metric"
			};
			function ts(e$1, t$1, i$1) {
				const o$1 = i$1 && i$1.maxWidth || 100, r$1 = e$1._container.clientHeight / 2, a$1 = e$1._container.clientWidth / 2, s$1 = e$1.unproject([a$1 - o$1 / 2, r$1]), n$1 = e$1.unproject([a$1 + o$1 / 2, r$1]), l$1 = Math.round(e$1.project(n$1).x - e$1.project(s$1).x), c$1 = Math.min(o$1, l$1, e$1._container.clientWidth), h$1 = s$1.distanceTo(n$1);
				if (i$1 && "imperial" === i$1.unit) {
					const i$2 = 3.2808 * h$1;
					i$2 > 5280 ? is(t$1, c$1, i$2 / 5280, e$1._getUIString("ScaleControl.Miles")) : is(t$1, c$1, i$2, e$1._getUIString("ScaleControl.Feet"));
				} else i$1 && "nautical" === i$1.unit ? is(t$1, c$1, h$1 / 1852, e$1._getUIString("ScaleControl.NauticalMiles")) : h$1 >= 1e3 ? is(t$1, c$1, h$1 / 1e3, e$1._getUIString("ScaleControl.Kilometers")) : is(t$1, c$1, h$1, e$1._getUIString("ScaleControl.Meters"));
			}
			function is(e$1, t$1, i$1, o$1) {
				const r$1 = function(e$2) {
					const t$2 = Math.pow(10, `${Math.floor(e$2)}`.length - 1);
					let i$2 = e$2 / t$2;
					return i$2 = i$2 >= 10 ? 10 : i$2 >= 5 ? 5 : i$2 >= 3 ? 3 : i$2 >= 2 ? 2 : i$2 >= 1 ? 1 : function(e$3) {
						const t$3 = Math.pow(10, Math.ceil(-Math.log(e$3) / Math.LN10));
						return Math.round(e$3 * t$3) / t$3;
					}(i$2), t$2 * i$2;
				}(i$1);
				e$1.style.width = t$1 * (r$1 / i$1) + "px", e$1.innerHTML = `${r$1}&nbsp;${o$1}`;
			}
			const os = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				subpixelPositioning: !1,
				locationOccludedOpacity: void 0
			}, rs = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function as(e$1) {
				if (e$1) {
					if ("number" == typeof e$1) {
						const i$1 = Math.round(Math.abs(e$1) / Math.SQRT2);
						return {
							center: new t.P(0, 0),
							top: new t.P(0, e$1),
							"top-left": new t.P(i$1, i$1),
							"top-right": new t.P(-i$1, i$1),
							bottom: new t.P(0, -e$1),
							"bottom-left": new t.P(i$1, -i$1),
							"bottom-right": new t.P(-i$1, -i$1),
							left: new t.P(e$1, 0),
							right: new t.P(-e$1, 0)
						};
					}
					if (e$1 instanceof t.P || Array.isArray(e$1)) {
						const i$1 = t.P.convert(e$1);
						return {
							center: i$1,
							top: i$1,
							"top-left": i$1,
							"top-right": i$1,
							bottom: i$1,
							"bottom-left": i$1,
							"bottom-right": i$1,
							left: i$1,
							right: i$1
						};
					}
					return {
						center: t.P.convert(e$1.center || [0, 0]),
						top: t.P.convert(e$1.top || [0, 0]),
						"top-left": t.P.convert(e$1["top-left"] || [0, 0]),
						"top-right": t.P.convert(e$1["top-right"] || [0, 0]),
						bottom: t.P.convert(e$1.bottom || [0, 0]),
						"bottom-left": t.P.convert(e$1["bottom-left"] || [0, 0]),
						"bottom-right": t.P.convert(e$1["bottom-right"] || [0, 0]),
						left: t.P.convert(e$1.left || [0, 0]),
						right: t.P.convert(e$1.right || [0, 0])
					};
				}
				return as(new t.P(0, 0));
			}
			const ss = i;
			e.AJAXError = t.cz, e.Event = t.l, e.Evented = t.E, e.LngLat = t.S, e.MercatorCoordinate = t.a1, e.Point = t.P, e.addProtocol = t.cA, e.config = t.a, e.removeProtocol = t.cB, e.AttributionControl = Da, e.BoxZoomHandler = $r, e.CanvasSource = Y, e.CooperativeGesturesHandler = Ca, e.DoubleClickZoomHandler = ba, e.DragPanHandler = wa, e.DragRotateHandler = Ta, e.EdgeInsets = Mt, e.FullscreenControl = class extends t.E {
				constructor(e$1 = {}) {
					super(), this._onFullscreenChange = () => {
						var e$2;
						let t$1 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
						for (; null === (e$2 = null == t$1 ? void 0 : t$1.shadowRoot) || void 0 === e$2 ? void 0 : e$2.fullscreenElement;) t$1 = t$1.shadowRoot.fullscreenElement;
						t$1 === this._container !== this._fullscreen && this._handleFullscreenChange();
					}, this._onClickFullscreen = () => {
						this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
					}, this._fullscreen = !1, e$1 && e$1.container && (e$1.container instanceof HTMLElement ? this._container = e$1.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
				}
				onAdd(e$1) {
					return this._map = e$1, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
				}
				onRemove() {
					n.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_setupUI() {
					const e$1 = this._fullscreenButton = n.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
					n.create("span", "maplibregl-ctrl-icon", e$1).setAttribute("aria-hidden", "true"), e$1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_updateTitle() {
					const e$1 = this._getTitle();
					this._fullscreenButton.setAttribute("aria-label", e$1), this._fullscreenButton.title = e$1;
				}
				_getTitle() {
					return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
				}
				_isFullscreen() {
					return this._fullscreen;
				}
				_handleFullscreenChange() {
					this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
				}
				_exitFullscreen() {
					window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
				}
				_requestFullscreen() {
					this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
				}
				_togglePseudoFullScreen() {
					this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
				}
			}, e.GeoJSONSource = H, e.GeolocateControl = class extends t.E {
				constructor(e$1) {
					super(), this._onSuccess = (e$2) => {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(e$2)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e$2)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = e$2, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR":
									this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
									break;
								default: throw new Error(`Unexpected watchState ${this._watchState}`);
							}
							this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e$2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e$2), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e$2)), this._finish();
						}
					}, this._updateCamera = (e$2) => {
						const i$1 = new t.S(e$2.coords.longitude, e$2.coords.latitude), o$1 = e$2.coords.accuracy, r$1 = this._map.getBearing(), a$1 = t.e({ bearing: r$1 }, this.options.fitBoundsOptions), s$1 = G.fromLngLat(i$1, o$1);
						this._map.fitBounds(s$1, a$1, { geolocateSource: !0 });
					}, this._updateMarker = (e$2) => {
						if (e$2) {
							const i$1 = new t.S(e$2.coords.longitude, e$2.coords.latitude);
							this._accuracyCircleMarker.setLngLat(i$1).addTo(this._map), this._userLocationDotMarker.setLngLat(i$1).addTo(this._map), this._accuracy = e$2.coords.accuracy, this._updateCircleRadiusIfNeeded();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}, this._onUpdate = () => {
						this._updateCircleRadiusIfNeeded();
					}, this._onError = (e$2) => {
						if (this._map) {
							if (1 === e$2.code) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3), void 0 !== this._geolocationWatchID && this._clearWatch();
							} else {
								if (3 === e$2.code && Ja) return;
								this._setErrorState();
							}
							"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e$2)), this._finish();
						}
					}, this._finish = () => {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}, this._setupUI = () => {
						this._map && (this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this._geolocateButton = n.create("button", "maplibregl-ctrl-geolocate", this._container), n.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
					}, this._finishSetupUI = (e$2) => {
						if (this._map) {
							if (!1 === e$2) {
								t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								const e$3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							} else {
								const e$3 = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.disabled = !1, this._geolocateButton.title = e$3, this._geolocateButton.setAttribute("aria-label", e$3);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ka({ element: this._dotElement }), this._circleElement = n.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ka({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((e$3) => {
								const i$1 = (null == e$3 ? void 0 : e$3[0]) instanceof ResizeObserverEntry;
								e$3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i$1 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
							}));
						}
					}, this.options = t.e({}, Ya, e$1);
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
						return t._(this, arguments, void 0, (function* (e$2 = !1) {
							if (void 0 !== qa && !e$2) return qa;
							if (void 0 === window.navigator.permissions) return qa = !!window.navigator.geolocation, qa;
							try {
								qa = "denied" !== (yield window.navigator.permissions.query({ name: "geolocation" })).state;
							} catch (e$3) {
								qa = !!window.navigator.geolocation;
							}
							return qa;
						}));
					}().then(((e$2) => this._finishSetupUI(e$2))), this._container;
				}
				onRemove() {
					void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Qa = 0, Ja = !1;
				}
				_isOutOfMapMaxBounds(e$1) {
					const t$1 = this._map.getMaxBounds(), i$1 = e$1.coords;
					return t$1 && (i$1.longitude < t$1.getWest() || i$1.longitude > t$1.getEast() || i$1.latitude < t$1.getSouth() || i$1.latitude > t$1.getNorth());
				}
				_setErrorState() {
					switch (this._watchState) {
						case "WAITING_ACTIVE":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
							break;
						case "ACTIVE_LOCK":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "BACKGROUND":
							this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "ACTIVE_ERROR":
						case "BACKGROUND_ERROR":
						case "OFF":
						case void 0: break;
						default: throw new Error(`Unexpected watchState ${this._watchState}`);
					}
				}
				_updateCircleRadiusIfNeeded() {
					const e$1 = this._userLocationDotMarker.getLngLat();
					if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e$1)) return;
					const t$1 = this._map.project(e$1), i$1 = this._map.unproject([t$1.x + 100, t$1.y]), o$1 = e$1.distanceTo(i$1) / 100, r$1 = 2 * this._accuracy / o$1;
					this._circleElement.style.width = `${r$1.toFixed(2)}px`, this._circleElement.style.height = `${r$1.toFixed(2)}px`;
				}
				trigger() {
					if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1;
					if (this.options.trackUserLocation) {
						switch (this._watchState) {
							case "OFF":
								this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
								break;
							case "WAITING_ACTIVE":
							case "ACTIVE_LOCK":
							case "ACTIVE_ERROR":
							case "BACKGROUND_ERROR":
								Qa--, Ja = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
								break;
							case "BACKGROUND":
								this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
								break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "ACTIVE_LOCK":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "OFF": break;
							default: throw new Error(`Unexpected watchState ${this._watchState}`);
						}
						if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
						else if (void 0 === this._geolocationWatchID) {
							let e$1;
							this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Qa++, Qa > 1 ? (e$1 = {
								maximumAge: 6e5,
								timeout: 0
							}, Ja = !0) : (e$1 = this.options.positionOptions, Ja = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e$1);
						}
					} else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
					return !0;
				}
				_clearWatch() {
					window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
				}
			}, e.GlobeControl = class {
				constructor() {
					this._toggleProjection = () => {
						var e$1;
						const t$1 = null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type;
						this._map.setProjection("mercator" !== t$1 && t$1 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
					}, this._updateGlobeIcon = () => {
						var e$1;
						this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e$1 = this._map.getProjection()) || void 0 === e$1 ? void 0 : e$1.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
					};
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n.create("button", "maplibregl-ctrl-globe", this._container), n.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
				}
			}, e.Hash = Er, e.ImageSource = X, e.KeyboardHandler = pa, e.LngLatBounds = G, e.LogoControl = Aa, e.Map = class extends Ra {
				constructor(e$1) {
					var i$1, o$1;
					t.cw.mark(t.cx.create);
					const r$1 = Object.assign(Object.assign(Object.assign({}, Ga), e$1), { canvasContextAttributes: Object.assign(Object.assign({}, Ga.canvasContextAttributes), e$1.canvasContextAttributes) });
					if (null != r$1.minZoom && null != r$1.maxZoom && r$1.minZoom > r$1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
					if (null != r$1.minPitch && null != r$1.maxPitch && r$1.minPitch > r$1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
					if (null != r$1.minPitch && r$1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (null != r$1.maxPitch && r$1.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
					const a$1 = new Lt(), s$1 = new Ot();
					if (void 0 !== r$1.minZoom && a$1.setMinZoom(r$1.minZoom), void 0 !== r$1.maxZoom && a$1.setMaxZoom(r$1.maxZoom), void 0 !== r$1.minPitch && a$1.setMinPitch(r$1.minPitch), void 0 !== r$1.maxPitch && a$1.setMaxPitch(r$1.maxPitch), void 0 !== r$1.renderWorldCopies && a$1.setRenderWorldCopies(r$1.renderWorldCopies), super(a$1, s$1, { bearingSnap: r$1.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new La(), this._controls = [], this._mapId = t.a7(), this._contextLost = (e$2) => {
						e$2.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t.l("webglcontextlost", { originalEvent: e$2 }));
					}, this._contextRestored = (e$2) => {
						this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e$2 }));
					}, this._onMapScroll = (e$2) => {
						if (e$2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}, this._onWindowOnline = () => {
						this._update();
					}, this._interactive = r$1.interactive, this._maxTileCacheSize = r$1.maxTileCacheSize, this._maxTileCacheZoomLevels = r$1.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, r$1.canvasContextAttributes), this._trackResize = !0 === r$1.trackResize, this._bearingSnap = r$1.bearingSnap, this._centerClampedToGround = r$1.centerClampedToGround, this._refreshExpiredTiles = !0 === r$1.refreshExpiredTiles, this._fadeDuration = r$1.fadeDuration, this._crossSourceCollisions = !0 === r$1.crossSourceCollisions, this._collectResourceTiming = !0 === r$1.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Ua), r$1.locale), this._clickTolerance = r$1.clickTolerance, this._overridePixelRatio = r$1.pixelRatio, this._maxCanvasSize = r$1.maxCanvasSize, this.transformCameraUpdate = r$1.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = !0 === r$1.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p.addThrottleControl((() => this.isMoving())), this._requestManager = new m(r$1.transformRequest), "string" == typeof r$1.container) {
						if (this._container = document.getElementById(r$1.container), !this._container) throw new Error(`Container '${r$1.container}' not found.`);
					} else {
						if (!(r$1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
						this._container = r$1.container;
					}
					if (r$1.maxBounds && this.setMaxBounds(r$1.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
						this.painter.terrainFacilitator.dirty = !0, this._update(!0);
					})), this.once("idle", (() => {
						this._idleTriggered = !0;
					})), "undefined" != typeof window) {
						addEventListener("online", this._onWindowOnline, !1);
						let e$2 = !1;
						const t$1 = Sr(((e$3) => {
							this._trackResize && !this._removed && (this.resize(e$3), this.redraw());
						}), 50);
						this._resizeObserver = new ResizeObserver(((i$2) => {
							e$2 ? t$1(i$2) : e$2 = !0;
						})), this._resizeObserver.observe(this._container);
					}
					this.handlers = new Ea(this, r$1), this._hash = r$1.hash && new Er("string" == typeof r$1.hash && r$1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
						center: r$1.center,
						elevation: r$1.elevation,
						zoom: r$1.zoom,
						bearing: r$1.bearing,
						pitch: r$1.pitch,
						roll: r$1.roll
					}), r$1.bounds && (this.resize(), this.fitBounds(r$1.bounds, t.e({}, r$1.fitBoundsOptions, { duration: 0 }))));
					const n$1 = "string" == typeof r$1.style || !("globe" === (null === (o$1 = null === (i$1 = r$1.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === o$1 ? void 0 : o$1.type));
					this.resize(null, n$1), this._localIdeographFontFamily = r$1.localIdeographFontFamily, this._validateStyle = r$1.validateStyle, r$1.style && this.setStyle(r$1.style, { localIdeographFontFamily: r$1.localIdeographFontFamily }), r$1.attributionControl && this.addControl(new Da("boolean" == typeof r$1.attributionControl ? void 0 : r$1.attributionControl)), r$1.maplibreLogo && this.addControl(new Aa(), r$1.logoPosition), this.on("style.load", (() => {
						if (n$1 || this._resizeTransform(), this.transform.unmodified) {
							const e$2 = t.Q(this.style.stylesheet, [
								"center",
								"zoom",
								"bearing",
								"pitch",
								"roll"
							]);
							this.jumpTo(e$2);
						}
					})), this.on("data", ((e$2) => {
						this._update("style" === e$2.dataType), this.fire(new t.l(`${e$2.dataType}data`, e$2));
					})), this.on("dataloading", ((e$2) => {
						this.fire(new t.l(`${e$2.dataType}dataloading`, e$2));
					})), this.on("dataabort", ((e$2) => {
						this.fire(new t.l("sourcedataabort", e$2));
					}));
				}
				_getMapId() {
					return this._mapId;
				}
				setGlobalStateProperty(e$1, t$1) {
					return this.style.setGlobalStateProperty(e$1, t$1), this._update(!0);
				}
				getGlobalState() {
					return this.style.getGlobalState();
				}
				addControl(e$1, i$1) {
					if (void 0 === i$1 && (i$1 = e$1.getDefaultPosition ? e$1.getDefaultPosition() : "top-right"), !e$1 || !e$1.onAdd) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
					const o$1 = e$1.onAdd(this);
					this._controls.push(e$1);
					const r$1 = this._controlPositions[i$1];
					return -1 !== i$1.indexOf("bottom") ? r$1.insertBefore(o$1, r$1.firstChild) : r$1.appendChild(o$1), this;
				}
				removeControl(e$1) {
					if (!e$1 || !e$1.onRemove) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
					const i$1 = this._controls.indexOf(e$1);
					return i$1 > -1 && this._controls.splice(i$1, 1), e$1.onRemove(this), this;
				}
				hasControl(e$1) {
					return this._controls.indexOf(e$1) > -1;
				}
				coveringTiles(e$1) {
					return ve(this.transform, e$1);
				}
				calculateCameraOptionsFromTo(e$1, t$1, i$1, o$1) {
					return null == o$1 && this.terrain && (o$1 = this.terrain.getElevationForLngLatZoom(i$1, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e$1, t$1, i$1, o$1);
				}
				resize(e$1, i$1 = !0) {
					const [o$1, r$1] = this._containerDimensions(), a$1 = this._getClampedPixelRatio(o$1, r$1);
					if (this._resizeCanvas(o$1, r$1, a$1), this.painter.resize(o$1, r$1, a$1), this.painter.overLimit()) {
						const e$2 = this.painter.context.gl;
						this._maxCanvasSize = [e$2.drawingBufferWidth, e$2.drawingBufferHeight];
						const t$1 = this._getClampedPixelRatio(o$1, r$1);
						this._resizeCanvas(o$1, r$1, t$1), this.painter.resize(o$1, r$1, t$1);
					}
					this._resizeTransform(i$1);
					const s$1 = !this._moving;
					return s$1 && (this.stop(), this.fire(new t.l("movestart", e$1)).fire(new t.l("move", e$1))), this.fire(new t.l("resize", e$1)), s$1 && this.fire(new t.l("moveend", e$1)), this;
				}
				_resizeTransform(e$1 = !0) {
					var t$1;
					const [i$1, o$1] = this._containerDimensions();
					this.transform.resize(i$1, o$1, e$1), null === (t$1 = this._requestedCameraState) || void 0 === t$1 || t$1.resize(i$1, o$1, e$1);
				}
				_getClampedPixelRatio(e$1, t$1) {
					const { 0: i$1, 1: o$1 } = this._maxCanvasSize, r$1 = this.getPixelRatio(), a$1 = e$1 * r$1, s$1 = t$1 * r$1;
					return Math.min(a$1 > i$1 ? i$1 / a$1 : 1, s$1 > o$1 ? o$1 / s$1 : 1) * r$1;
				}
				getPixelRatio() {
					var e$1;
					return null !== (e$1 = this._overridePixelRatio) && void 0 !== e$1 ? e$1 : devicePixelRatio;
				}
				setPixelRatio(e$1) {
					this._overridePixelRatio = e$1, this.resize();
				}
				getBounds() {
					return this.transform.getBounds();
				}
				getMaxBounds() {
					return this.transform.getMaxBounds();
				}
				setMaxBounds(e$1) {
					return this.transform.setMaxBounds(G.convert(e$1)), this._update();
				}
				setMinZoom(e$1) {
					if ((e$1 = null == e$1 ? -2 : e$1) >= -2 && e$1 <= this.transform.maxZoom) return this.transform.setMinZoom(e$1), this._update(), this.getZoom() < e$1 && this.setZoom(e$1), this;
					throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
				}
				getMinZoom() {
					return this.transform.minZoom;
				}
				setMaxZoom(e$1) {
					if ((e$1 = null == e$1 ? 22 : e$1) >= this.transform.minZoom) return this.transform.setMaxZoom(e$1), this._update(), this.getZoom() > e$1 && this.setZoom(e$1), this;
					throw new Error("maxZoom must be greater than the current minZoom");
				}
				getMaxZoom() {
					return this.transform.maxZoom;
				}
				setMinPitch(e$1) {
					if ((e$1 = null == e$1 ? 0 : e$1) < 0) throw new Error("minPitch must be greater than or equal to 0");
					if (e$1 >= 0 && e$1 <= this.transform.maxPitch) return this.transform.setMinPitch(e$1), this._update(), this.getPitch() < e$1 && this.setPitch(e$1), this;
					throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
				}
				getMinPitch() {
					return this.transform.minPitch;
				}
				setMaxPitch(e$1) {
					if ((e$1 = null == e$1 ? 60 : e$1) > 180) throw new Error("maxPitch must be less than or equal to 180");
					if (e$1 >= this.transform.minPitch) return this.transform.setMaxPitch(e$1), this._update(), this.getPitch() > e$1 && this.setPitch(e$1), this;
					throw new Error("maxPitch must be greater than the current minPitch");
				}
				getMaxPitch() {
					return this.transform.maxPitch;
				}
				getRenderWorldCopies() {
					return this.transform.renderWorldCopies;
				}
				setRenderWorldCopies(e$1) {
					return this.transform.setRenderWorldCopies(e$1), this._update();
				}
				project(e$1) {
					return this.transform.locationToScreenPoint(t.S.convert(e$1), this.style && this.terrain);
				}
				unproject(e$1) {
					return this.transform.screenPointToLocation(t.P.convert(e$1), this.terrain);
				}
				isMoving() {
					var e$1;
					return this._moving || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isMoving());
				}
				isZooming() {
					var e$1;
					return this._zooming || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isZooming());
				}
				isRotating() {
					var e$1;
					return this._rotating || (null === (e$1 = this.handlers) || void 0 === e$1 ? void 0 : e$1.isRotating());
				}
				_createDelegatedListener(e$1, t$1, i$1) {
					if ("mouseenter" === e$1 || "mouseover" === e$1) {
						let o$1 = !1;
						const r$1 = (r$2) => {
							const a$1 = t$1.filter(((e$2) => this.getLayer(e$2))), s$1 = 0 !== a$1.length ? this.queryRenderedFeatures(r$2.point, { layers: a$1 }) : [];
							s$1.length ? o$1 || (o$1 = !0, i$1.call(this, new jr(e$1, this, r$2.originalEvent, { features: s$1 }))) : o$1 = !1;
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: () => {
									o$1 = !1;
								}
							}
						};
					}
					if ("mouseleave" === e$1 || "mouseout" === e$1) {
						let o$1 = !1;
						const r$1 = (r$2) => {
							const a$2 = t$1.filter(((e$2) => this.getLayer(e$2)));
							(0 !== a$2.length ? this.queryRenderedFeatures(r$2.point, { layers: a$2 }) : []).length ? o$1 = !0 : o$1 && (o$1 = !1, i$1.call(this, new jr(e$1, this, r$2.originalEvent)));
						}, a$1 = (t$2) => {
							o$1 && (o$1 = !1, i$1.call(this, new jr(e$1, this, t$2.originalEvent)));
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: {
								mousemove: r$1,
								mouseout: a$1
							}
						};
					}
					{
						const o$1 = (e$2) => {
							const o$2 = t$1.filter(((e$3) => this.getLayer(e$3))), r$1 = 0 !== o$2.length ? this.queryRenderedFeatures(e$2.point, { layers: o$2 }) : [];
							r$1.length && (e$2.features = r$1, i$1.call(this, e$2), delete e$2.features);
						};
						return {
							layers: t$1,
							listener: i$1,
							delegates: { [e$1]: o$1 }
						};
					}
				}
				_saveDelegatedListener(e$1, t$1) {
					this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e$1] = this._delegatedListeners[e$1] || [], this._delegatedListeners[e$1].push(t$1);
				}
				_removeDelegatedListener(e$1, t$1, i$1) {
					if (!this._delegatedListeners || !this._delegatedListeners[e$1]) return;
					const o$1 = this._delegatedListeners[e$1];
					for (let e$2 = 0; e$2 < o$1.length; e$2++) {
						const r$1 = o$1[e$2];
						if (r$1.listener === i$1 && r$1.layers.length === t$1.length && r$1.layers.every(((e$3) => t$1.includes(e$3)))) {
							for (const e$3 in r$1.delegates) this.off(e$3, r$1.delegates[e$3]);
							o$1.splice(e$2, 1);
							return;
						}
					}
				}
				on(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.on(e$1, t$1);
					const o$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, o$1, i$1);
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.on(e$2, r$1.delegates[e$2]);
					return { unsubscribe: () => {
						this._removeDelegatedListener(e$1, o$1, i$1);
					} };
				}
				once(e$1, t$1, i$1) {
					if (void 0 === i$1) return super.once(e$1, t$1);
					const o$1 = "string" == typeof t$1 ? [t$1] : t$1, r$1 = this._createDelegatedListener(e$1, o$1, i$1);
					for (const t$2 in r$1.delegates) {
						const a$1 = r$1.delegates[t$2];
						r$1.delegates[t$2] = (...t$3) => {
							this._removeDelegatedListener(e$1, o$1, i$1), a$1(...t$3);
						};
					}
					this._saveDelegatedListener(e$1, r$1);
					for (const e$2 in r$1.delegates) this.once(e$2, r$1.delegates[e$2]);
					return this;
				}
				off(e$1, t$1, i$1) {
					return void 0 === i$1 ? super.off(e$1, t$1) : (this._removeDelegatedListener(e$1, "string" == typeof t$1 ? [t$1] : t$1, i$1), this);
				}
				queryRenderedFeatures(e$1, i$1) {
					if (!this.style) return [];
					let o$1;
					const r$1 = e$1 instanceof t.P || Array.isArray(e$1), a$1 = r$1 ? e$1 : [[0, 0], [this.transform.width, this.transform.height]];
					if (i$1 = i$1 || (r$1 ? {} : e$1) || {}, a$1 instanceof t.P || "number" == typeof a$1[0]) o$1 = [t.P.convert(a$1)];
					else {
						const e$2 = t.P.convert(a$1[0]), i$2 = t.P.convert(a$1[1]);
						o$1 = [
							e$2,
							new t.P(i$2.x, e$2.y),
							i$2,
							new t.P(e$2.x, i$2.y),
							e$2
						];
					}
					return this.style.queryRenderedFeatures(o$1, i$1, this.transform);
				}
				querySourceFeatures(e$1, t$1) {
					return this.style.querySourceFeatures(e$1, t$1);
				}
				setStyle(e$1, i$1) {
					return !1 !== (i$1 = t.e({}, {
						localIdeographFontFamily: this._localIdeographFontFamily,
						validate: this._validateStyle
					}, i$1)).diff && i$1.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e$1 ? (this._diffStyle(e$1, i$1), this) : (this._localIdeographFontFamily = i$1.localIdeographFontFamily, this._updateStyle(e$1, i$1));
				}
				setTransformRequest(e$1) {
					return this._requestManager.setTransformRequest(e$1), this;
				}
				_getUIString(e$1) {
					const t$1 = this._locale[e$1];
					if (null == t$1) throw new Error(`Missing UI string '${e$1}'`);
					return t$1;
				}
				_updateStyle(e$1, t$1) {
					var i$1, o$1;
					if (t$1.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e$1, t$1)));
					const r$1 = this.style && t$1.transformStyle ? this.style.serialize() : void 0;
					return this.style && (this.style.setEventedParent(null), this.style._remove(!e$1)), e$1 ? (this.style = new wi(this, t$1 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e$1 ? this.style.loadURL(e$1, t$1, r$1) : this.style.loadJSON(e$1, t$1, r$1), this) : (null === (o$1 = null === (i$1 = this.style) || void 0 === i$1 ? void 0 : i$1.projection) || void 0 === o$1 || o$1.destroy(), delete this.style, this);
				}
				_lazyInitEmptyStyle() {
					this.style || (this.style = new wi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
				}
				_diffStyle(e$1, i$1) {
					if ("string" == typeof e$1) {
						const o$1 = this._requestManager.transformRequest(e$1, "Style");
						t.j(o$1, new AbortController()).then(((e$2) => {
							this._updateDiff(e$2.data, i$1);
						})).catch(((e$2) => {
							e$2 && this.fire(new t.k(e$2));
						}));
					} else "object" == typeof e$1 && this._updateDiff(e$1, i$1);
				}
				_updateDiff(e$1, i$1) {
					try {
						this.style.setState(e$1, i$1) && this._update(!0);
					} catch (o$1) {
						t.w(`Unable to perform style diff: ${o$1.message || o$1.error || o$1}.  Rebuilding the style from scratch.`), this._updateStyle(e$1, i$1);
					}
				}
				getStyle() {
					if (this.style) return this.style.serialize();
				}
				isStyleLoaded() {
					return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
				}
				addSource(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addSource(e$1, t$1), this._update(!0);
				}
				isSourceLoaded(e$1) {
					const i$1 = this.style && this.style.sourceCaches[e$1];
					if (void 0 !== i$1) return i$1.loaded();
					this.fire(new t.k(/* @__PURE__ */ new Error(`There is no source with ID '${e$1}'`)));
				}
				setTerrain(e$1) {
					if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e$1) {
						const i$1 = this.style.sourceCaches[e$1.source];
						if (!i$1) throw new Error(`cannot load terrain, because there exists no source with ID: ${e$1.source}`);
						null === this.terrain && i$1.reload();
						for (const i$2 in this.style._layers) {
							const o$1 = this.style._layers[i$2];
							"hillshade" === o$1.type && o$1.source === e$1.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === o$1.type && o$1.source === e$1.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
						}
						this.terrain = new Ba(this.painter, i$1, e$1), this.painter.renderToTexture = new Na(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t$1) => {
							var i$2;
							"style" === t$1.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t$1.dataType && t$1.tile && (t$1.sourceId !== e$1.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i$2 = t$1.source) || void 0 === i$2 ? void 0 : i$2.type) ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t$1.tile.tileID));
						}, this.style.on("data", this._terrainDataCallback);
					} else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
					return this.fire(new t.l("terrain", { terrain: e$1 })), this;
				}
				getTerrain() {
					var e$1, t$1;
					return null !== (t$1 = null === (e$1 = this.terrain) || void 0 === e$1 ? void 0 : e$1.options) && void 0 !== t$1 ? t$1 : null;
				}
				areTilesLoaded() {
					const e$1 = this.style && this.style.sourceCaches;
					for (const t$1 in e$1) {
						const i$1 = e$1[t$1]._tiles;
						for (const e$2 in i$1) {
							const t$2 = i$1[e$2];
							if ("loaded" !== t$2.state && "errored" !== t$2.state) return !1;
						}
					}
					return !0;
				}
				removeSource(e$1) {
					return this.style.removeSource(e$1), this._update(!0);
				}
				getSource(e$1) {
					return this.style.getSource(e$1);
				}
				setSourceTileLodParams(e$1, t$1, i$1) {
					if (i$1) {
						const o$1 = this.getSource(i$1);
						if (!o$1) throw new Error(`There is no source with ID "${i$1}", cannot set LOD parameters`);
						o$1.calculateTileZoom = me(Math.max(1, e$1), Math.max(1, t$1));
					} else for (const i$2 in this.style.sourceCaches) this.style.sourceCaches[i$2].getSource().calculateTileZoom = me(Math.max(1, e$1), Math.max(1, t$1));
					return this._update(!0), this;
				}
				refreshTiles(e$1, i$1) {
					const o$1 = this.style.sourceCaches[e$1];
					if (!o$1) throw new Error(`There is no source cache with ID "${e$1}", cannot refresh tile`);
					void 0 === i$1 ? o$1.reload(!0) : o$1.refreshTiles(i$1.map(((e$2) => new t.a4(e$2.z, e$2.x, e$2.y))));
				}
				addImage(e$1, i$1, o$1 = {}) {
					const { pixelRatio: r$1 = 1, sdf: a$1 = !1, stretchX: n$1, stretchY: l$1, content: c$1, textFitWidth: h$1, textFitHeight: u$1 } = o$1;
					if (this._lazyInitEmptyStyle(), !(i$1 instanceof HTMLImageElement || t.b(i$1))) {
						if (void 0 === i$1.width || void 0 === i$1.height) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						{
							const { width: o$2, height: s$1, data: d$1 } = i$1, _$1 = i$1;
							return this.style.addImage(e$1, {
								data: new t.R({
									width: o$2,
									height: s$1
								}, new Uint8Array(d$1)),
								pixelRatio: r$1,
								stretchX: n$1,
								stretchY: l$1,
								content: c$1,
								textFitWidth: h$1,
								textFitHeight: u$1,
								sdf: a$1,
								version: 0,
								userImage: _$1
							}), _$1.onAdd && _$1.onAdd(this, e$1), this;
						}
					}
					{
						const { width: o$2, height: d$1, data: _$1 } = s.getImageData(i$1);
						this.style.addImage(e$1, {
							data: new t.R({
								width: o$2,
								height: d$1
							}, _$1),
							pixelRatio: r$1,
							stretchX: n$1,
							stretchY: l$1,
							content: c$1,
							textFitWidth: h$1,
							textFitHeight: u$1,
							sdf: a$1,
							version: 0
						});
					}
				}
				updateImage(e$1, i$1) {
					const o$1 = this.style.getImage(e$1);
					if (!o$1) return this.fire(new t.k(/* @__PURE__ */ new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
					const { width: a$1, height: n$1, data: l$1 } = i$1 instanceof HTMLImageElement || t.b(i$1) ? s.getImageData(i$1) : i$1;
					if (void 0 === a$1 || void 0 === n$1) return this.fire(new t.k(/* @__PURE__ */ new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
					if (a$1 !== o$1.data.width || n$1 !== o$1.data.height) return this.fire(new t.k(/* @__PURE__ */ new Error("The width and height of the updated image must be that same as the previous version of the image")));
					const c$1 = !(i$1 instanceof HTMLImageElement || t.b(i$1));
					return o$1.data.replace(l$1, c$1), this.style.updateImage(e$1, o$1), this;
				}
				getImage(e$1) {
					return this.style.getImage(e$1);
				}
				hasImage(e$1) {
					return e$1 ? !!this.style.getImage(e$1) : (this.fire(new t.k(/* @__PURE__ */ new Error("Missing required image id"))), !1);
				}
				removeImage(e$1) {
					this.style.removeImage(e$1);
				}
				loadImage(e$1) {
					return p.getImage(this._requestManager.transformRequest(e$1, "Image"), new AbortController());
				}
				listImages() {
					return this.style.listImages();
				}
				addLayer(e$1, t$1) {
					return this._lazyInitEmptyStyle(), this.style.addLayer(e$1, t$1), this._update(!0);
				}
				moveLayer(e$1, t$1) {
					return this.style.moveLayer(e$1, t$1), this._update(!0);
				}
				removeLayer(e$1) {
					return this.style.removeLayer(e$1), this._update(!0);
				}
				getLayer(e$1) {
					return this.style.getLayer(e$1);
				}
				getLayersOrder() {
					return this.style.getLayersOrder();
				}
				setLayerZoomRange(e$1, t$1, i$1) {
					return this.style.setLayerZoomRange(e$1, t$1, i$1), this._update(!0);
				}
				setFilter(e$1, t$1, i$1 = {}) {
					return this.style.setFilter(e$1, t$1, i$1), this._update(!0);
				}
				getFilter(e$1) {
					return this.style.getFilter(e$1);
				}
				setPaintProperty(e$1, t$1, i$1, o$1 = {}) {
					return this.style.setPaintProperty(e$1, t$1, i$1, o$1), this._update(!0);
				}
				getPaintProperty(e$1, t$1) {
					return this.style.getPaintProperty(e$1, t$1);
				}
				setLayoutProperty(e$1, t$1, i$1, o$1 = {}) {
					return this.style.setLayoutProperty(e$1, t$1, i$1, o$1), this._update(!0);
				}
				getLayoutProperty(e$1, t$1) {
					return this.style.getLayoutProperty(e$1, t$1);
				}
				setGlyphs(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setGlyphs(e$1, t$1), this._update(!0);
				}
				getGlyphs() {
					return this.style.getGlyphsUrl();
				}
				addSprite(e$1, t$1, i$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.addSprite(e$1, t$1, i$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				removeSprite(e$1) {
					return this._lazyInitEmptyStyle(), this.style.removeSprite(e$1), this._update(!0);
				}
				getSprite() {
					return this.style.getSprite();
				}
				setSprite(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSprite(e$1, t$1, ((e$2) => {
						e$2 || this._update(!0);
					})), this;
				}
				setLight(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setLight(e$1, t$1), this._update(!0);
				}
				getLight() {
					return this.style.getLight();
				}
				setSky(e$1, t$1 = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSky(e$1, t$1), this._update(!0);
				}
				getSky() {
					return this.style.getSky();
				}
				setFeatureState(e$1, t$1) {
					return this.style.setFeatureState(e$1, t$1), this._update();
				}
				removeFeatureState(e$1, t$1) {
					return this.style.removeFeatureState(e$1, t$1), this._update();
				}
				getFeatureState(e$1) {
					return this.style.getFeatureState(e$1);
				}
				getContainer() {
					return this._container;
				}
				getCanvasContainer() {
					return this._canvasContainer;
				}
				getCanvas() {
					return this._canvas;
				}
				_containerDimensions() {
					let e$1 = 0, t$1 = 0;
					return this._container && (e$1 = this._container.clientWidth || 400, t$1 = this._container.clientHeight || 300), [e$1, t$1];
				}
				_setupContainer() {
					const e$1 = this._container;
					e$1.classList.add("maplibregl-map");
					const t$1 = this._canvasContainer = n.create("div", "maplibregl-canvas-container", e$1);
					this._interactive && t$1.classList.add("maplibregl-interactive"), this._canvas = n.create("canvas", "maplibregl-canvas", t$1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
					const i$1 = this._containerDimensions(), o$1 = this._getClampedPixelRatio(i$1[0], i$1[1]);
					this._resizeCanvas(i$1[0], i$1[1], o$1);
					const r$1 = this._controlContainer = n.create("div", "maplibregl-control-container", e$1), a$1 = this._controlPositions = {};
					[
						"top-left",
						"top-right",
						"bottom-left",
						"bottom-right"
					].forEach(((e$2) => {
						a$1[e$2] = n.create("div", `maplibregl-ctrl-${e$2} `, r$1);
					})), this._container.addEventListener("scroll", this._onMapScroll, !1);
				}
				_resizeCanvas(e$1, t$1, i$1) {
					this._canvas.width = Math.floor(i$1 * e$1), this._canvas.height = Math.floor(i$1 * t$1), this._canvas.style.width = `${e$1}px`, this._canvas.style.height = `${t$1}px`;
				}
				_setupPainter() {
					const e$1 = Object.assign(Object.assign({}, this._canvasContextAttributes), {
						alpha: !0,
						depth: !0,
						stencil: !0,
						premultipliedAlpha: !0
					});
					let t$1 = null;
					this._canvas.addEventListener("webglcontextcreationerror", ((i$2) => {
						t$1 = { requestedAttributes: e$1 }, i$2 && (t$1.statusMessage = i$2.statusMessage, t$1.type = i$2.type);
					}), { once: !0 });
					let i$1 = null;
					if (i$1 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e$1) : this._canvas.getContext("webgl2", e$1) || this._canvas.getContext("webgl", e$1), !i$1) {
						const e$2 = "Failed to initialize WebGL";
						throw t$1 ? (t$1.message = e$2, new Error(JSON.stringify(t$1))) : new Error(e$2);
					}
					this.painter = new Mr(i$1, this.transform), l.testSupport(i$1);
				}
				migrateProjection(e$1, i$1) {
					super.migrateProjection(e$1, i$1), this.painter.transform = e$1, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
				}
				loaded() {
					return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
				}
				_update(e$1) {
					return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e$1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
				}
				_requestRenderFrame(e$1) {
					return this._update(), this._renderTaskQueue.add(e$1);
				}
				_cancelRenderFrame(e$1) {
					this._renderTaskQueue.remove(e$1);
				}
				_render(e$1) {
					var i$1, o$1, r$1, a$1, n$1;
					const l$1 = this._idleTriggered ? this._fadeDuration : 0, c$1 = (null === (i$1 = this.style.projection) || void 0 === i$1 ? void 0 : i$1.transitionState) > 0;
					if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e$1), this._removed) return;
					let h$1 = !1;
					if (this.style && this._styleDirty) {
						this._styleDirty = !1;
						const e$2 = this.transform.zoom, i$2 = s.now();
						this.style.zoomHistory.update(e$2, i$2);
						const o$2 = new t.F(e$2, {
							now: i$2,
							fadeDuration: l$1,
							zoomHistory: this.style.zoomHistory,
							transition: this.style.getTransition()
						}), r$2 = o$2.crossFadingFactor();
						1 === r$2 && r$2 === this._crossFadingFactor || (h$1 = !0, this._crossFadingFactor = r$2), this.style.update(o$2);
					}
					const u$1 = (null === (o$1 = this.style.projection) || void 0 === o$1 ? void 0 : o$1.transitionState) > 0 !== c$1;
					null === (r$1 = this.style.projection) || void 0 === r$1 || r$1.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (a$1 = this.style.projection) || void 0 === a$1 ? void 0 : a$1.transitionState, null === (n$1 = this.style.projection) || void 0 === n$1 ? void 0 : n$1.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u$1) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l$1, this._crossSourceCollisions, u$1), this.painter.render(this.style, {
						showTileBoundaries: this.showTileBoundaries,
						showOverdrawInspector: this._showOverdrawInspector,
						rotating: this.isRotating(),
						zooming: this.isZooming(),
						moving: this.isMoving(),
						fadeDuration: l$1,
						showPadding: this.showPadding
					}), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cw.mark(t.cx.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h$1) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
					const d$1 = this._sourcesDirty || this._styleDirty || this._placementDirty;
					return d$1 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d$1 || (this._fullyLoaded = !0, t.cw.mark(t.cx.fullLoad)), this;
				}
				redraw() {
					return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
				}
				remove() {
					var e$1;
					this._hash && this._hash.remove();
					for (const e$2 of this._controls) e$2.onRemove(this);
					this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, !1), p.removeThrottleControl(this._imageQueueHandle), null === (e$1 = this._resizeObserver) || void 0 === e$1 || e$1.disconnect();
					const i$1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
					null != i$1 && i$1.loseContext && i$1.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), n.remove(this._canvasContainer), n.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cw.clearMetrics(), this._removed = !0, this.fire(new t.l("remove"));
				}
				triggerRepaint() {
					this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s.frame(this._frameRequest, ((e$1) => {
						t.cw.frame(e$1), this._frameRequest = null;
						try {
							this._render(e$1);
						} catch (e$2) {
							if (!t.cy(e$2) && !function(e$3) {
								return e$3.message === qo;
							}(e$2)) throw e$2;
						}
					}), (() => {})));
				}
				get showTileBoundaries() {
					return !!this._showTileBoundaries;
				}
				set showTileBoundaries(e$1) {
					this._showTileBoundaries !== e$1 && (this._showTileBoundaries = e$1, this._update());
				}
				get showPadding() {
					return !!this._showPadding;
				}
				set showPadding(e$1) {
					this._showPadding !== e$1 && (this._showPadding = e$1, this._update());
				}
				get showCollisionBoxes() {
					return !!this._showCollisionBoxes;
				}
				set showCollisionBoxes(e$1) {
					this._showCollisionBoxes !== e$1 && (this._showCollisionBoxes = e$1, e$1 ? this.style._generateCollisionBoxes() : this._update());
				}
				get showOverdrawInspector() {
					return !!this._showOverdrawInspector;
				}
				set showOverdrawInspector(e$1) {
					this._showOverdrawInspector !== e$1 && (this._showOverdrawInspector = e$1, this._update());
				}
				get repaint() {
					return !!this._repaint;
				}
				set repaint(e$1) {
					this._repaint !== e$1 && (this._repaint = e$1, this.triggerRepaint());
				}
				get vertices() {
					return !!this._vertices;
				}
				set vertices(e$1) {
					this._vertices = e$1, this._update();
				}
				get version() {
					return Za;
				}
				getCameraTargetElevation() {
					return this.transform.elevation;
				}
				getProjection() {
					return this.style.getProjection();
				}
				setProjection(e$1) {
					return this._lazyInitEmptyStyle(), this.style.setProjection(e$1), this._update(!0);
				}
			}, e.MapMouseEvent = jr, e.MapTouchEvent = Nr, e.MapWheelEvent = Ur, e.Marker = Ka, e.NavigationControl = class {
				constructor(e$1) {
					this._updateZoomButtons = () => {
						const e$2 = this._map.getZoom(), t$1 = e$2 === this._map.getMaxZoom(), i$1 = e$2 === this._map.getMinZoom();
						this._zoomInButton.disabled = t$1, this._zoomOutButton.disabled = i$1, this._zoomInButton.setAttribute("aria-disabled", t$1.toString()), this._zoomOutButton.setAttribute("aria-disabled", i$1.toString());
					}, this._rotateCompassArrow = () => {
						this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
					}, this._setButtonTitle = (e$2, t$1) => {
						const i$1 = this._map._getUIString(`NavigationControl.${t$1}`);
						e$2.title = i$1, e$2.setAttribute("aria-label", i$1);
					}, this.options = t.e({}, Va, e$1), this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e$2) => e$2.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e$2) => this._map.zoomIn({}, { originalEvent: e$2 }))), n.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e$2) => this._map.zoomOut({}, { originalEvent: e$2 }))), n.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e$2) => {
						this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e$2 }) : this._map.resetNorth({}, { originalEvent: e$2 });
					})), this._compassIcon = n.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
				}
				onAdd(e$1) {
					return this._map = e$1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new $a(this._map, this._compass, this.options.visualizePitch)), this._container;
				}
				onRemove() {
					n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
				}
				_createButton(e$1, t$1) {
					const i$1 = n.create("button", e$1, this._container);
					return i$1.type = "button", i$1.addEventListener("click", t$1), i$1;
				}
			}, e.Popup = class extends t.E {
				constructor(e$1) {
					super(), this._updateOpacity = () => {
						void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
					}, this.remove = () => (this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e$2) => {
						this._update(e$2.point);
					}, this._onMouseMove = (e$2) => {
						this._update(e$2.point);
					}, this._onDrag = (e$2) => {
						this._update(e$2.point);
					}, this._update = (e$2) => {
						if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
						if (!this._container) {
							if (this._container = n.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e$3 of this.options.className.split(" ")) this._container.classList.add(e$3);
							this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
						}
						if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Wa(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e$2) return;
						const t$1 = this._flatPos = this._pos = this._trackPointer && e$2 ? e$2 : this._map.project(this._lngLat);
						this._map.terrain && (this._flatPos = this._trackPointer && e$2 ? e$2 : this._map.transform.locationToScreenPoint(this._lngLat));
						let i$1 = this.options.anchor;
						const o$1 = as(this.options.offset);
						if (!i$1) {
							const e$3 = this._container.offsetWidth, r$2 = this._container.offsetHeight;
							let a$1;
							a$1 = t$1.y + o$1.bottom.y < r$2 ? ["top"] : t$1.y > this._map.transform.height - r$2 ? ["bottom"] : [], t$1.x < e$3 / 2 ? a$1.push("left") : t$1.x > this._map.transform.width - e$3 / 2 && a$1.push("right"), i$1 = 0 === a$1.length ? "bottom" : a$1.join("-");
						}
						let r$1 = t$1.add(o$1[i$1]);
						this.options.subpixelPositioning || (r$1 = r$1.round()), n.setTransform(this._container, `${Ha[i$1]} translate(${r$1.x}px,${r$1.y}px)`), Xa(this._container, i$1, "popup"), this._updateOpacity();
					}, this._onClose = () => {
						this.remove();
					}, this.options = t.e(Object.create(os), e$1);
				}
				addTo(e$1) {
					return this._map && this.remove(), this._map = e$1, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
				}
				isOpen() {
					return !!this._map;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e$1) {
					return this._lngLat = t.S.convert(e$1), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
				}
				trackPointer() {
					return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
				}
				getElement() {
					return this._container;
				}
				setText(e$1) {
					return this.setDOMContent(document.createTextNode(e$1));
				}
				setHTML(e$1) {
					const t$1 = document.createDocumentFragment(), i$1 = document.createElement("body");
					let o$1;
					for (i$1.innerHTML = e$1; o$1 = i$1.firstChild, o$1;) t$1.appendChild(o$1);
					return this.setDOMContent(t$1);
				}
				getMaxWidth() {
					var e$1;
					return null === (e$1 = this._container) || void 0 === e$1 ? void 0 : e$1.style.maxWidth;
				}
				setMaxWidth(e$1) {
					return this.options.maxWidth = e$1, this._update(), this;
				}
				setDOMContent(e$1) {
					if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
					else this._content = n.create("div", "maplibregl-popup-content", this._container);
					return this._content.appendChild(e$1), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
				}
				addClassName(e$1) {
					return this._container && this._container.classList.add(e$1), this;
				}
				removeClassName(e$1) {
					return this._container && this._container.classList.remove(e$1), this;
				}
				setOffset(e$1) {
					return this.options.offset = e$1, this._update(), this;
				}
				toggleClassName(e$1) {
					if (this._container) return this._container.classList.toggle(e$1);
				}
				setSubpixelPositioning(e$1) {
					this.options.subpixelPositioning = e$1;
				}
				_createCloseButton() {
					this.options.closeButton && (this._closeButton = n.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
				}
				_focusFirstElement() {
					if (!this.options.focusAfterOpen || !this._container) return;
					const e$1 = this._container.querySelector(rs);
					e$1 && e$1.focus();
				}
			}, e.RasterDEMTileSource = W, e.RasterTileSource = q, e.ScaleControl = class {
				constructor(e$1) {
					this._onMove = () => {
						ts(this._map, this._container, this.options);
					}, this.setUnit = (e$2) => {
						this.options.unit = e$2, ts(this._map, this._container, this.options);
					}, this.options = Object.assign(Object.assign({}, es), e$1);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e$1.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
				}
			}, e.ScrollZoomHandler = va, e.Style = wi, e.TerrainControl = class {
				constructor(e$1) {
					this._toggleTerrain = () => {
						this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
					}, this._updateTerrainIcon = () => {
						this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
					}, this.options = e$1;
				}
				onAdd(e$1) {
					return this._map = e$1, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n.create("button", "maplibregl-ctrl-terrain", this._container), n.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
				}
				onRemove() {
					n.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
				}
			}, e.TwoFingersTouchPitchHandler = da, e.TwoFingersTouchRotateHandler = ha, e.TwoFingersTouchZoomHandler = la, e.TwoFingersTouchZoomRotateHandler = Pa, e.VectorTileSource = $, e.VideoSource = K, e.addSourceType = (e$1, i$1) => t._(void 0, void 0, void 0, (function* () {
				if (J(e$1)) throw new Error(`A source type called "${e$1}" already exists.`);
				((e$2, t$1) => {
					Q[e$2] = t$1;
				})(e$1, i$1);
			})), e.clearPrewarmedResources = function() {
				const e$1 = A;
				e$1 && (e$1.isPreloaded() && 1 === e$1.numActive() ? (e$1.release(R), A = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, e.createTileMesh = Xt, e.getMaxParallelImageRequests = function() {
				return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
			}, e.getRTLTextPluginStatus = function() {
				return oe().getRTLTextPluginStatus();
			}, e.getVersion = function() {
				return ss;
			}, e.getWorkerCount = function() {
				return z.workerCount;
			}, e.getWorkerUrl = function() {
				return t.a.WORKER_URL;
			}, e.importScriptInWorkers = function(e$1) {
				return B().broadcast("IS", e$1);
			}, e.prewarm = function() {
				k().acquire(R);
			}, e.setMaxParallelImageRequests = function(e$1) {
				t.a.MAX_PARALLEL_IMAGE_REQUESTS = e$1;
			}, e.setRTLTextPlugin = function(e$1, t$1) {
				return oe().setRTLTextPlugin(e$1, t$1);
			}, e.setWorkerCount = function(e$1) {
				z.workerCount = e$1;
			}, e.setWorkerUrl = function(e$1) {
				t.a.WORKER_URL = e$1;
			};
		}));
		return maplibregl;
	}));
}) });

//#endregion
export default require_maplibre_gl();

//# sourceMappingURL=maplibre-gl.js.map